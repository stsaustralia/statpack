

<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<title>v497</title>
<style>
    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background: #f9f9f9;
        color: #000;
        margin: 0;
        padding: 20px;
    }

    h1 {
        color: #007aff;
    }

    .controls {
        margin-bottom: 20px;
    }

    .controls button, .controls label {
        margin-right: 10px;
    }

    input, select, textarea {
        background: #fff;
        color: #000;
        border: 1px solid #ccc;
        padding: 6px 10px;
        border-radius: 6px;
        margin: 4px;
        font-size: 10px;
    }

    .score-columns {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 10px;
    }

    .score-column {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 5px;
    }

    .score-column button {
        width: 135px;
        height: 40px;
        margin: 1px;
        border-radius: 6px;
        border: 1px solid #ccc;
        background: #fff;
    }

    .selected-score {
        background-color: #007aff !important;
        color: #fff !important;
        font-weight: bold;
        border: 2px solid #000;
    }

    table {
        width: 100%;
        border-collapse: collapse;
        background: #fff;
        margin-top: 20px;
    }

    table, th, td {
        border: 1px solid #ccc;
    }

    th, td {
        padding: 10px;
        text-align: center;
        font-size: 12px;
    }
    
    #extraNoteButtons {
        display: grid;
        grid-template-columns: repeat(7, 80px);
        gap: 4px;
        margin-top: 10px;
    }

    .note-btn {
        width: 80px;
        height: 30px;
        font-size: 10px;
        padding: 0;
        border-radius: 6px;
        border: 1px solid #ccc;
        font-weight: bold;
        background: #f2f2f2;
        color: #000;
        transition: box-shadow 0.1s;
        margin: 0;
    }

    .note-btn.selected-score {
        box-shadow: 0 0 0 2px #000;
        color: #fff;
    }

    .note-btn[data-category="gold"] {
        background: gold;
        color: #000;
    }

    .note-btn[data-category="dose"] {
        background: #444;
        color: #fff;
    }

    .note-btn[data-category="blue"] {
        background: #007aff;
        color: #fff;
    }

    .note-btn[data-category="red"] {
        background: red;
        color: #fff;
    }

    .note-btn[data-category="green"] {
        background: green;
        color: #fff;
    }

    .note-btn[data-category="orange"] {
        background: orange;
        color: #000;
    }

    .note-btn[data-category="yellow"] {
        background: #ffeb3b;
        color: #000;
    }

    #scoreModal {
        display: none;
        position: fixed;
        top: 15%;
        left: 50%;
        transform: translateX(-50%);
        background: #fff;
        padding: 20px;
        border: 2px solid #007aff;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        z-index: 1000;
    }

    #scoreModal input {
        width: 60px;
    }
    
  .note-btn[data-category="purple"] {
    background-color: rebeccapurple;
    color: #fff;
  }
</style>
</head>
<body>
<h1>Recorder v497</h1>
<div class="controls">
<button onclick="newTrip()">New Log</button>
<button onclick="resetTimer()">Reset Timer</button>
<button onclick="pauseTimer()">Pause Timer</button>
<label>
<input id="redoseCheckbox" type="checkbox"/>
             Redose
        </label>
<button id="addBtn" onclick="addEntry()">Add Entry</button>
<button onclick="deleteSelected()">Delete Selected</button>
<button onclick="editSelected()">Edit Selected</button>
<button onclick="exportCSV()">Export CSV</button>
<button onclick="openScoreModal()">Manual Score Entry</button>
<button onclick="openEmotionModal()">Emotion Wheel</button>
</div>
<div>
<label>
            Phase: 
            <input id="eventInput" maxlength="50" size="50" type="text"/>
</label>
<br/>
<label>
            Scale: 
            <input id="scaleInput" maxlength="50" size="30" type="text"/>
</label>
<br/>
<label>
            Add:
                  
            <select id="drugSelect">
<option value="">--Select--</option>
<option value="x-PiHP">x-PiHP</option>
<option value="PYRO">PYRO</option>
<option value="Cathinone">Cathinone</option>
<option value="Unknown">Unknown</option>
<option value="NN-DMC">NN-DMC</option>
<option value="MD-PiHP">MD-PiHP</option>
<option value="2ME-PiHP">2ME-PiHP</option>
<option value="A-PiHP">A-PiHP</option>
<option value="3F-PiHP">3F-PiHP</option>
<option value="Meth">Meth</option>
<option value="MDMA">MDMA</option>
<option value="3-MMC">3-MMC</option>
<option value="Dust">Dust</option>
<option value="Speed">Speed</option>
<option value="Crack">Crack</option>
<option value="Vodka">Vodka</option>
<option value="Weed">Weed</option>
<option value="THC">THC</option>
<option value="Alcohol">Alcohol</option>
<option value="LSD">LSD</option>
</select>
</label>
<label>
            qty: 
            <input id="qtyInput" size="6" type="number"/>
</label>
<label>
            Detail: 
            <input id="roaInput" size="10" type="text"/>
</label>
<br/>
<label>Notes:</label>
<br/>
<textarea cols="50" id="notesInput" rows="3"></textarea>
<br/>
<div style="display: flex; gap: 10px;"><label>Last:</label>
<br/>
<textarea cols="50" id="customNotesInput" rows="3"></textarea><div style="display: flex; flex-direction: column;"><label>Next:</label><textarea cols="50" id="customNotesNextInput" rows="3"></textarea></div></div>
</div>
<div style="display: flex; align-items: flex-start; gap: 20px;">
<div class="score-columns" id="scoreColumns"></div>
<div id="noteButtons"></div>
<div id="extraNoteButtons"></div>
</div>
<div id="timer" style="margin-top: 10px;">Time: 00:00:00</div>
<table id="logTable">
<thead>
<tr>
<th>Select</th>
<th>Timestamp</th>
<th>Since</th>
<th>Elapsed</th>
<th>Phase</th>
<th>Scale</th>
<th>Drug</th>
<th>QTY</th>
<th>ROA</th>
<th>Rush</th>
<th>Rush</th>
<th>Mood</th>
<th>Mood</th>
<th>Social</th>
<th>Social</th>
<th>Energy</th>
<th>Energy </th>
<th>Focus</th>
<th>Focus</th>
<th>Anxiety</th>
<th>Anxiety</th>
<th>Impair</th>
<th>Impair</th>
<th>Score</th>
<th>Max</th>
<th>Min</th>
<th>VL</th>
<th>sM</th>
<th>sB</th>
<th>sF</th>
<th>Last</th>
<th>Notes</th>
<th>Weighted</th><th>Score5</th><th>Good</th>
</tr>
</thead>
<tbody></tbody>
</table>
<script>
    const labelMappings = {
        rush: {
            "-2": 'Dysphoric',
            "0": 'No',
            "1": 'Slight',
            "2": 'Some',
            "3": 'Moderate',
            "4": 'Strong',
            "5": 'Intense',
            "9": 'Extreme',
            "10": 'Rush'
, "1.5": "+", "-0.5": "-", "-1.5": "-" },
        mood: {
            "-2": 'Negative',
            "0": 'Neutral',
            "1": 'Noticed',
            "2": 'Ignorable',
            "3": 'Clear',
            "4": 'Obvious',
            "5": 'Euphoric',
            "9": 'Manic',
            "10": 'Rush'
, "1.5": "+", "-0.5": "-", "-1.5": "-" },
        social: {
            "-2": 'Avoidant',
            "0": 'Flat',
            "1": 'Think/Want',
            "2": 'Motivated',
            "3": 'Active',
            "4": 'Social',
            "5": 'Outgoing',
            "9": 'Disinhibited',
            "10": 'Autopilot'
, "1.5": "+", "-0.5": "-", "-1.5": "-" },
        energy: {
            "-2": 'Tired',
            "0": 'None',
            "1": 'Alert',
            "2": 'Increased',
            "3": 'Significant',
            "4": 'Energetic',
            "5": 'Hyper/Manic',
            "9": 'Super',
            "10": 'Rapid'
, "1.5": "+", "-0.5": "-", "-1.5": "-" },
        focus: {
            "-2": 'Scattered',
            "0": 'No',
            "1": 'Alert',
            "2": 'Increased',
            "3": 'Focused',
            "4": 'Wired',
            "5": 'Obsessive',
            "9": 'Laser',
            "10": 'Flow'
, "1.5": "+", "-0.5": "-", "-1.5": "-" },
        anxiety: {
            "0": 'None',
            "1": 'Thinking',
            "2": 'Excessive',
            "3": 'Worrying',
            "4": 'Anxious',
            "5": 'Panic',
            "10": 'Severe'
, "1.5": "+", "-0.5": "-", "-1.5": "-" },
        impair: {
            "-2": 'Motivated',
            "0": 'None',
            "1": 'Tremors',
            "2": 'Excessive',
            "3": 'Affecting',
            "4": 'Controlling',
            "5": 'Crippled',
            "10": 'Severe'
, "1.5": "+", "-0.5": "-", "-1.5": "-" },
    };

    function getLabels(metric, values) {
        if (!Array.isArray(values))
            values = [values];
        return Array.from(new Set(values))
        .sort((a, b) => b - a)
        .map(v => labelMappings[metric][v] || '')
        .filter(Boolean);
    }

    function getSum(arr) {
        return Array.isArray(arr) && arr.length
        ? arr.reduce((a, b) => a + b, 0)
        : 0;
    }

    const metrics = ['rush', 'mood', 'social', 'energy', 'focus', 'anxiety', 'impair'];
    let selections = {},
        logData = [],
        timerInterval,
        startTime,
        doseTime,
        editIndex = null;

    function initSelections() {
        metrics.forEach(m => selections[m] = []);
    }

    function buildButtons() {
        // Score buttons
        const sc = document.getElementById('scoreColumns');
        sc.innerHTML = '';
        metrics.forEach(f => {
            const col = document.createElement('div');
            col.className = 'score-column';
            const t = document.createElement('strong');
            t.innerText = f.charAt(0).toUpperCase() + f.slice(1);
            col.appendChild(t);
           [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1].forEach(v => {
                const b = document.createElement('button');
                let customLabel = '';
if (v === 1.5) customLabel = '+++';
// if (v === -1.1) customLabel = '';
else if (v === 9) customLabel = '++';
else if (v === 10) customLabel = '++++';

else customLabel = labelMappings[f]?.[v] ?? '';
b.innerText = `${v}: ${customLabel}`;
                b.onclick = () => {
                    selections[f] = [v]; // Only one selection per metric
                    const btns = col.querySelectorAll('button');
                    btns.forEach(btn => btn.classList.remove('selected-score'));
                    b.classList.add('selected-score');
                };
                col.appendChild(b);
            });
            sc.appendChild(col);
        
});

        // Original notes
        const noteCont = document.getElementById('noteButtons');
        noteCont.innerHTML = '';
        const palette = {
            CONTEXT: 'other',
            PRE: 'time',
            POST: 'time',
            ONSET: 'time',
            After: 'time',
            Before: 'time',
            Estimate: 'time',
            RUSH: 'effect',
            Good: 'positive',
            Bad: 'negative',
            Anxiety: 'emotional',
            Craving: 'emotional',
            Joy: 'positive',
            Physical: 'physical',
            Visual: 'effect',
            Audio: 'effect',
            Cognitive: 'mental',
            Social: 'effect',
            Paranoia: 'emotional',
            Peaceful: 'positive',
            Insight: 'mental',
            Sleep: 'other',
            Alert: 'effect',
            Fatigue: 'physical',
            Euphoria: 'positive',
            Pain: 'physical',
            Discomfort: 'physical',
            Calm: 'positive',
            Tension: 'emotional',
            Fun: 'positive',
            Confusion: 'mental'
        };
        // Extra notes (gold)
        const extraCont = document.getElementById('extraNoteButtons');
        extraCont.innerHTML = '';
        const extra = ['Up', 'Down', 'Noticed', 'Onset', 'Rush', 'Heartbeat', 'WideEyes', 'BloodPressure', 'Tremors', 'OverCooked', 'AddDrug', 'NothingAdded', 'UsingRemains', 'LeftUsable', 'Usable', 'RemainsLeft', 'ColourFilm', 'SomeColour', 'MostlyColour'];
        extra.forEach(lbl => {
            const b = document.createElement('button');
            b.className = 'note-btn';
            b.innerText = lbl;
            b.setAttribute('data-category', 'gold');
            b.onclick = () => {
                const ta = document.getElementById('notesInput');
                const toks = ta.value.split(/\s+/).filter(Boolean);
                const i = toks.indexOf(lbl);
                if (i >= 0) {
                    toks.splice(i, 1);
                    b.classList.remove('selected-score');
                }
                else {
                    toks.push(lbl);
                    b.classList.add('selected-score');
                }
                ta.value = toks.join(' ');
            };
            extraCont.appendChild(b);
        });

        // Dark grey dose buttons
        const darkLabels = ["NOTE", "CONTEXT", "CHANGE", "REVIEW", "Plan", "Next", "LAST", ">0mg", ">5mg", ">10mg", ">15mg", ">20mg", "<5mg", "<10mg", "<15mg", "<20mg", "RESIDUE", "FILM", "CARBON", "COLOUR", "BURNED"];
        darkLabels.forEach(lbl => {
            const b = document.createElement('button');
            b.className = 'note-btn';
            b.innerText = lbl;
            b.setAttribute('data-category', 'dose');
            b.onclick = () => {
                const ta = document.getElementById('notesInput');
                const toks = ta.value.split(/\s+/).filter(Boolean);
                const i = toks.indexOf(lbl);
                if (i >= 0) {
                    toks.splice(i, 1);
                    b.classList.remove('selected-score');
                }
                else {
                    toks.push(lbl);
                    b.classList.add('selected-score');
                }
                ta.value = toks.join(' ');
            };
            extraCont.appendChild(b);
        });

        // Bright blue custom buttons
        const blueLabels = ['Up', 'Down', 'Pulse', 'Physical', 'Cognitive', 'Visceral', 'HeartBeat', 'BloodPressure', 'Invisible', 'Billowing', 'Warm', 'Plumes', 'BodyTemp'];
        blueLabels.forEach(lbl => {
            const b = document.createElement('button');
            b.className = 'note-btn';
            b.innerText = lbl;
            b.setAttribute('data-category', 'blue');
            b.onclick = () => {
                const ta = document.getElementById('notesInput');
                const toks = ta.value.split(/\s+/).filter(Boolean);
                const i = toks.indexOf(lbl);
                if (i >= 0) {
                    toks.splice(i, 1);
                    b.classList.remove('selected-score');
                } else {
                    toks.push(lbl);
                    b.classList.add('selected-score');
                }
                ta.value = toks.join(' ');
            };
            extraCont.appendChild(b);
        });

        // Bright red custom buttons
        const redLabels = ['ThroatBreath', 'Sucked', 'LipSeal', 'NoSeal', 'Burned', 'Weighed', 'Eyeballed', 'Yes', 'No', 'Maybe', 'Certain', 'Half', 'TRUE', 'FALSE', 'POSITIVE', 'NEGATIVE', 'UNKNOWN', 'UNSURE', 'SOME', 'HALF', 'MOST'];
        redLabels.forEach(lbl => {
            const b = document.createElement('button');
            b.className = 'note-btn';
            b.innerText = lbl;
            b.setAttribute('data-category', 'red');
            b.onclick = () => {
                const ta = document.getElementById('notesInput');
                const toks = ta.value.split(/\s+/).filter(Boolean);
                const i = toks.indexOf(lbl);
                if (i >= 0) {
                    toks.splice(i, 1);
                    b.classList.remove('selected-score');
                } else {
                    toks.push(lbl);
                    b.classList.add('selected-score');
                }
                ta.value = toks.join(' ');
            };
            extraCont.appendChild(b);
        });
        const greenLabels = ["PRE", "POST", "REDOSE", "CONTINUE", "LATE15S", "NOTHING_ADDED", "ADDED_DRUG",
        "EYEBALLED", "WEIGHED", "WAITED", "POOLED", "THROAT_SUCTION", "DEEP_BREATH", "SHALLOW", "GENTLE",
        "ONEHIT", "ONEHEAT", "PLUMES", "WARM", "INVISIBLE", "DARK", "WARM",
        "BURNEDSMELL", "VAPOUR", "POOLED", "OBVIOUS", "BURNED", "USABLE", "CAUTIOUS", "AGGRESSIVE"];
        greenLabels.forEach(lbl => {
            const b = document.createElement('button');
            b.className = 'note-btn';
            b.innerText = lbl;
            b.setAttribute('data-category', 'green');
            b.onclick = () => {
                const ta = document.getElementById('notesInput');
                const toks = ta.value.split(/\s+/).filter(Boolean);
                const i = toks.indexOf(lbl);
                if (i >= 0) {
                    toks.splice(i, 1);
                    b.classList.remove('selected-score');
                } else {
                    toks.push(lbl);
                    b.classList.add('selected-score');
                }
                ta.value = toks.join(' ');
            };
            extraCont.appendChild(b);
        });
        const orangeLabels = ['Soft', 'Close', 'Far', 'OneHit', 'Still', 'Moving', 'Follow', 'Random', 'Loose', 'Liquid', 'Sludge', 'PropyleneGlycol', 'JET', 'BIC', 'HEATED','CLEAN', 'DIRTY', 'SCRAPED', 'MELTED', 'SOMECOLOUR', 'COLOURCHANGE', 'VISIBLE', 'CHUNKS', 'ROLLED', 'RAPIDLY', 'STILL', 'ONSET', 'RUSH', 'BONG', 'PIPE'];
        orangeLabels.forEach(lbl => {
            const b = document.createElement('button');
            b.className = 'note-btn';
            b.innerText = lbl;
            b.setAttribute('data-category', 'orange');
            b.onclick = () => {
                const ta = document.getElementById('notesInput');
                const toks = ta.value.split(/\s+/).filter(Boolean);
                const i = toks.indexOf(lbl);
                if (i >= 0) {
                    toks.splice(i, 1);
                    b.classList.remove('selected-score');
                } else {
                    toks.push(lbl);
                    b.classList.add('selected-score');
                }
                ta.value = toks.join(' ');
            };
            extraCont.appendChild(b);
        });
        const yellowLabels = JSON.parse('["UP","DOWN", "EARS_RING", "WIDE_EYE","BP_INCREASE","BODYTEMP","SWeakT"]');
// Purple category labels
yellowLabels.forEach(lbl => {
            const b = document.createElement('button');
            b.className = 'note-btn';
            b.textContent = lbl;
            b.setAttribute('data-category', 'yellow');
            b.onclick = () => {
                const ta = document.getElementById('notesInput');
                const toks = ta.value.split(/\s+/).filter(Boolean);
                const i = toks.indexOf(lbl);
                if (i >= 0) {
                    toks.splice(i, 1);
                    b.classList.remove('selected-score');
                } else {
                    toks.push(lbl);
                    b.classList.add('selected-score');
                }
                ta.value = toks.join(' ');
            };
            extraCont.appendChild(b);
        });

    // ─── APPEND PURPLE LABELS ───────────────────────────────────────────────
    const purpleLabels = [
      '5_Seconds','Deep','Shallow','Hold','Long','Short','Slow','Rapid','OneBreath','Multiple','Male', 'Female','Others', 'Home', 'NotHome', 'Alone', 'RoomAlone', 'BuildingAlone'
    ];
    const purpleContainer = document.querySelector('#extraNoteButtons');
    purpleLabels.forEach(label => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.textContent = label;
      btn.dataset.category = 'purple';
      btn.classList.add('note-btn');
      btn.addEventListener('click', () => {
        const notes = document.querySelector('#notesInput');
        if (notes.value.includes(label)) {
          notes.value = notes.value.replace(new RegExp(`\\b${label}\\b`, 'g'), '').trim();
        } else {
          notes.value = (notes.value + ' ' + label).trim();
        }
      });
      purpleContainer.appendChild(btn);
    });
    // ──────────────────────────────────────────────────────────────────────────
    }

    function resetTimer() {
        startTime = doseTime = new Date();
        clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            document.getElementById('timer').innerText = 'Trip Time: ' + getElapsed(startTime);
        }, 1000);
    }
    function pauseTimer() {
        clearInterval(timerInterval);
    }
    function newTrip() {
        logData = [];
        localStorage.removeItem('tripLog');
        renderTable();
        clearInterval(timerInterval);
        document.getElementById('timer').innerText = 'Time: 00:00:00';
        startTime = doseTime = null;
    }
    function getElapsed(start) {
        if (!start)
            return "00:00:00";
        let d = Math.floor((new Date() - start) / 1000),
            h = String(Math.floor(d / 3600)).padStart(2, '0'),
            m = String(Math.floor((d % 3600) / 60)).padStart(2, '0'),
            s = String(d % 60).padStart(2, '0');
        return `${h}:${m}:${s}`;
    }
    function scrollToBottom() {
        const table = document.querySelector('#logTable');
        if (table) table.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }

    function addEntry(auto = false) {
        if (!startTime)
            resetTimer();
        const now = new Date(),
            ts = now.toLocaleString('en-AU', {
                hour12: false
            });
        if (document.getElementById('redoseCheckbox').checked && document.getElementById('drugSelect').value)
            doseTime = new Date();
        const entry = {
            _ts: Date.now(),
            timestamp: ts,
            sincedose: getElapsed(doseTime),
            elapsed: getElapsed(startTime),
            info: document.getElementById('eventInput').value,
            scale: document.getElementById('scaleInput').value,
            drug: document.getElementById('drugSelect').value,
            qty: document.getElementById('qtyInput').value,
            roa: document.getElementById('roaInput').value,
            notes: document.getElementById('notesInput').value,
            customNotes: document.getElementById('customNotesInput').value
        };
        metrics.forEach(f => {
            entry[f] = selections[f].length ? Array.from(new Set(selections[f])).sort((a, b) => b - a) : [];
            entry[f + 'Label'] = getLabels(f, entry[f]).join(', ');
            entry[f + 'Sum'] = getSum(entry[f]);
        });
        entry.score = entry.rushSum + entry.moodSum + entry.socialSum + entry.energySum + entry.focusSum - entry.anxietySum - entry.impairSum;
        entry.max = ['rush', 'mood', 'social', 'energy', 'focus'].reduce((a, f) => a + (entry[f + 'Sum'] || 0), 0);
        entry.min = entry.anxietySum + entry.impairSum;
        entry.maxPercent = +(entry.max / 50 * 100).toFixed(1);
        entry.minPercent = +(entry.min / 20 * 100).toFixed(1);
        entry.min = entry.anxietySum + entry.impairSum;
        let val = 0;
        ['rush', 'mood', 'social', 'energy', 'focus'].forEach(m => entry[m].some(v => v >= 3) && val++);
        ['anxiety', 'impair'].forEach(m => entry[m].some(v => v >= 3) && val--);
        entry.valence = val;
        entry.scaleMood = entry.notes.split(/\s+/).includes('Good') ? 3 : 0;
        entry.scaleBad = entry.notes.split(/\s+/).includes('Bad') ? 3 : 0;
        entry.scaleFocus = entry.notes.split(/\s+/).includes('Wired') ? 5 : 0;
entry.weighted = (
    (entry.rushSum || 0) * 4 +
    (entry.socialSum || 0) * 1.5 +
    (entry.moodSum || 0) * 1.5 +
    (entry.energySum || 0) * 1.5 +
    (entry.focusSum || 0) * 1.5
);
entry.goodSum = 0;
        logData.push(entry);
        localStorage.setItem('tripLog', JSON.stringify(logData));
        renderTable();
        ['eventInput', 'scaleInput', 'drugSelect', 'qtyInput', 'roaInput', 'notesInput', 'customNotesInput'].forEach(id => document.getElementById(id).value = '');
        // Backup current selections
        const selectionBackup = JSON.parse(JSON.stringify(selections));
        initSelections();
        buildButtons();
        // Reapply previous selections to keep buttons visually pressed
        metrics.forEach(f => {
            selectionBackup[f]?.forEach(v => {
                selections[f].push(v);
                const idx = metrics.indexOf(f);
                const col = document.querySelectorAll('.score-column')[idx];
                if (col) {
                    const btns = col.querySelectorAll('button');
                    btns.forEach(btn => {
                        if (btn.textContent.trim().startsWith(v + ':') || btn.textContent.trim().startsWith(v + ' ')) {
                            btn.classList.add('selected-score');
                        }
                    });
                }
            });
        });

        // Re-apply button pressed states
        metrics.forEach(f => {
            if (entry[f]) {
                entry[f].forEach(v => {
                    const idx = metrics.indexOf(f);
                    const col = document.querySelectorAll('.score-column')[idx];
                    if (col) {
                        const btns = col.querySelectorAll('button');
                        btns.forEach(btn => {
                            if (btn.textContent.trim().startsWith(v + ':') || btn.textContent.trim().startsWith(v + ' ')) {
                                btn.classList.add('selected-score');
                            }
                        });
                    }
                });
            }
        });
        document.getElementById('addBtn').innerText = 'Add Entry';
    if (!auto) scrollToBottom();
    }
    


function addSummaryRowSum() {
    const fields = ['rush', 'mood', 'social', 'energy', 'focus', 'anxiety', 'impair'];
    const tableBody = document.querySelector('#logTable tbody');
    if (!logData.length) return;

    const now = Date.now();
    const recent = logData.filter(r => r._ts && (now - r._ts <= 5000));
    if (!recent.length) return;

    const getCol = f => recent.map(r => r[f + 'Sum']).filter(v => typeof v === 'number');
    const getMinuteBounds = () => {
        const mins = recent
            .map(r => parseFloat(r.sincedose))
            .filter(v => !isNaN(v))
            .sort((a, b) => a - b);
        const minStart = Math.floor(mins[0] || 0);
        const maxEnd = Math.ceil(mins[mins.length - 1] || 0);
        return [minStart, maxEnd];
    };

    const [sinceMin, elapsedMin] = getMinuteBounds();

    const stats = fields.map(f => {
        const vals = getCol(f).sort((a, b) => a - b);
        const sum = vals.reduce((a, b) => a + b, 0);
        const mean = +(sum / vals.length).toFixed(2);
        return { f, sum, mean };
    });

    const makeRow = (label, prop, baseColor) => {
        const tr = document.createElement('tr');
        tr.style.fontWeight = 'bold';
        tr.style.backgroundColor = '#eee';
        let rowData = {
            timestamp: label,
            sincedose: sinceMin + "m",
            elapsed: elapsedMin + "m"
        };
        tr.innerHTML = `<td colspan="1">${label}</td><td colspan="1">${sinceMin}m</td><td colspan="1">${elapsedMin}m</td><td colspan="6"></td>`;
        stats.forEach(stat => {
            const val = +stat[prop];
            rowData[stat.f + 'Sum'] = val;
            const intensity = Math.min(val / 40, 1);
            const [r, g, b] = baseColor;
            const shaded = `rgba(${r},${g},${b},${intensity.toFixed(2)})`;
            tr.innerHTML += `<td style="background-color:${shaded}">${Math.round(val)}</td><td></td>`;
        });
        tr.innerHTML += '<td colspan="11"></td>';
        tableBody.appendChild(tr);
        logData.push(rowData);
    };

    makeRow('Σ SUM', 'sum', [0, 128, 0]);
    makeRow('μ MEAN', 'mean', [0, 0, 255]);
}


function renderTable() {
        const tb = document.querySelector('#logTable tbody');
        tb.innerHTML = '';
        logData.forEach((r, i) => {
            const tr = document.createElement('tr');
            let h = `<td><input type="checkbox" name="rowSelect" data-index="${i}"></td>`;
            ['timestamp', 'sincedose', 'elapsed', 'info', 'scale', 'drug', 'qty', 'roa'].forEach(k => h += `<td>${r[k] || ''}</td>`);
            metrics.forEach(f => {
                h += `<td data-field="${f}Sum" data-value="${r[f + 'Sum']}">${r[f + 'Sum']}</td>`;
                h += `<td data-label-for="${f}Sum" data-value="${r[f + 'Sum']}">${r[f + 'Label']}</td>`;
            });
            h += `<td>${r.score}</td><td>${r.max || ''} (${r.maxPercent || 0}%)</td><td>${r.min || 0} (${r.minPercent || 0}%)</td><td>${r.valence}</td><td>${r.scaleMood || 0}</td><td>${r.scaleBad || 0}</td><td>${r.scaleFocus || 0}</td><td>${r.customNotes || ''}</td><td>${r.notes || ''}</td><td>${r.weighted || 0}</td><td>${(r.weighted / 10 + 5).toFixed(2)}</td><td>${r.goodSum || ''}</td>`;
            
            tr.innerHTML = h;
            // ─── Additional Cell Shading ───────────────────────────────────────
            const scoreCell = tr.children[23];
            const scoreOpacity = Math.min(r.score, 50) / 50;
            scoreCell.style.backgroundColor = `rgba(0,255,0,${scoreOpacity})`;

            const maxCell = tr.children[24];
            const maxOpacity = Math.min(r.maxPercent, 100) / 100;
            maxCell.style.backgroundColor = `rgba(0,215,0,${maxOpacity})`;

            const minCell = tr.children[25];
            const minOpacity = Math.min(r.minPercent, 100) / 100;
            minCell.style.backgroundColor = `rgba(255,0,0,${minOpacity})`;
            // ─────────────────────────────────────────────────────────────────────

            // ─── Auto-shade Sum cells ────────────────────────────────────────
            const shadeFields = [
                { field: 'rushSum',   colour: [0, 255, 0] },
                { field: 'moodSum',   colour: [0, 255, 0] },
                { field: 'socialSum', colour: [0, 255, 0] },
                { field: 'focusSum',  colour: [255, 215,   0] },
                { field: 'energySum', colour: [255, 215,   0] },
                { field: 'anxietySum',colour: [255,   0,   0] },
                { field: 'impairSum', colour: [255,   0,   0] }
            ];
            shadeFields.forEach(cfg => {
                const cell = tr.querySelector(`td[data-field="${cfg.field}"]`);
                const val = r[cfg.field];
                const opacity = Math.min(val, 10) / 10;
                if (val > 0 && cell) {
                    cell.style.backgroundColor = `rgba(${cfg.colour[0]},${cfg.colour[1]},${cfg.colour[2]},${opacity})`;
                }
            });
            // ───────────────────────────────────────────────────────────────────

            tb.appendChild(tr);
        });
    }
    function deleteSelected() {
        const toDel = Array.from(document.querySelectorAll('input[name="rowSelect"]:checked')).map(cb => +cb.dataset.index);
        logData = logData.filter((_, i) => !toDel.includes(i));
        localStorage.setItem('tripLog', JSON.stringify(logData));
        renderTable();
    }
    function editSelected() {
        const sel = document.querySelector('input[name="rowSelect"]:checked');
        if (!sel)
            return alert('Select one row');
        editIndex = +sel.dataset.index;
        const r = logData[editIndex];
        document.getElementById('eventInput').value = r.info;
        document.getElementById('scaleInput').value = r.scale;
        document.getElementById('drugSelect').value = r.drug;
        document.getElementById('qtyInput').value = r.qty;
        document.getElementById('roaInput').value = r.roa;
        document.getElementById('notesInput').value = r.notes;
        document.getElementById('customNotesInput').value = r.customNotes;
        document.getElementById('addBtn').innerText = 'Save Changes';
        // Backup current selections
        const selectionBackup = JSON.parse(JSON.stringify(selections));
        initSelections();
        buildButtons();
        // Reapply previous selections to keep buttons visually pressed
        metrics.forEach(f => {
            selectionBackup[f]?.forEach(v => {
                selections[f].push(v);
                const idx = metrics.indexOf(f);
                const col = document.querySelectorAll('.score-column')[idx];
                if (col) {
                    const btns = col.querySelectorAll('button');
                    btns.forEach(btn => {
                        if (btn.textContent.trim().startsWith(v + ':') || btn.textContent.trim().startsWith(v + ' ')) {
                            btn.classList.add('selected-score');
                        }
                    });
                }
            });
        });

        // Re-apply button pressed states
        metrics.forEach(f => {
            if (entry[f]) {
                entry[f].forEach(v => {
                    const idx = metrics.indexOf(f);
                    const col = document.querySelectorAll('.score-column')[idx];
                    if (col) {
                        const btns = col.querySelectorAll('button');
                        btns.forEach(btn => {
                            if (btn.textContent.trim().startsWith(v + ':') || btn.textContent.trim().startsWith(v + ' ')) {
                                btn.classList.add('selected-score');
                            }
                        });
                    }
                });
            }
        });
        metrics.forEach((f, idx) => r[f].forEach(v => {
            const btn = document.querySelectorAll('.score-column')[idx].querySelector(`button:nth-child(${8 - v})`);
            btn && btn.classList.add('selected-score');
        }));
    }
    function exportCSV() {
        const h = ["Timestamp", "Since Dose", "Elapsed", "Info", "Scale", "Drug", "Qty", "ROA"];
        h.push("Notes", "Last", "Next");
        metrics.forEach(f => h.push(f.charAt(0).toUpperCase() + f.slice(1) + " Sum", f.charAt(0).toUpperCase() + f.slice(1) + " Label"));
        h.push("Score", "Max", "Min", "Max %", "Min %", "Valence", "scaleMood", "scaleBad", "scaleFocus", "Custom Notes", "Notes", "Weighted","Score5","Good Sum");
        const rows = [h.join(",")];
        logData.forEach(r => {
            const L = [r.timestamp, r.sincedose, r.elapsed, r.info, r.scale, r.drug, r.qty, r.roa];
        L.push(r.notes || "", r.customNotes || "", document.getElementById("customNotesNextInput")?.value || "");
            metrics.forEach(f => L.push(r[f + "Sum"], r[f + "Label"]));
            L.push(r.score, r.max || '', r.min || 0, r.maxPercent || 0, r.minPercent || 0, r.valence, r.scaleMood || 0, r.scaleBad || 0, r.scaleFocus || 0, r.customNotes || '', r.notes || '', r.weighted || 0, (r.weighted / 10 + 5).toFixed(2), r.goodSum || '');
            rows.push(L.map(x => `"${(x + "").replace(/"/g, '""')}"`).join(","))
        });
        const blob = new Blob([rows.join("\n")], {
                type: "text/csv"
            }),
            url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "log.csv";
        a.click();
        URL.revokeObjectURL(url);
    }
    // Manual Score Entry Modal functions
    function openScoreModal() {
        document.getElementById('scoreModal').style.display = 'block';
    }
    function closeScoreModal() {
        document.getElementById('scoreModal').style.display = 'none';
        document.querySelectorAll('#scoreModal input').forEach(inp => inp.value = '');
    }
    function applyManualScores() {
        const fields = ['rush', 'mood', 'social', 'energy', 'focus', 'anxiety', 'impair'];
        fields.forEach(f => {
            const val = parseInt(document.getElementById('manual' + f.charAt(0).toUpperCase() + f.slice(1)).value, 10);
            if (!isNaN(val) && val >= 0 && val <= 10) {
                if (!selections[f])
                    selections[f] = [];
                if (!selections[f].includes(val))
                    selections[f].push(val);
            }
        });
        buildButtons();
        // Reapply previous selections to keep buttons visually pressed
        metrics.forEach(f => {
            selectionBackup[f]?.forEach(v => {
                selections[f].push(v);
                const idx = metrics.indexOf(f);
                const col = document.querySelectorAll('.score-column')[idx];
                if (col) {
                    const btns = col.querySelectorAll('button');
                    btns.forEach(btn => {
                        if (btn.textContent.trim().startsWith(v + ':') || btn.textContent.trim().startsWith(v + ' ')) {
                            btn.classList.add('selected-score');
                        }
                    });
                }
            });
        });

        closeScoreModal();
    }
    window.onload = () => {
    setInterval(() => addEntry(true), 5000);
    setInterval(() => addSummaryRowSum(), 60000);
    
        // Backup current selections
        const selectionBackup = JSON.parse(JSON.stringify(selections));
        initSelections();
        buildButtons();
        // Reapply previous selections to keep buttons visually pressed
        metrics.forEach(f => {
            selectionBackup[f]?.forEach(v => {
                selections[f].push(v);
                const idx = metrics.indexOf(f);
                const col = document.querySelectorAll('.score-column')[idx];
                if (col) {
                    const btns = col.querySelectorAll('button');
                    btns.forEach(btn => {
                        if (btn.textContent.trim().startsWith(v + ':') || btn.textContent.trim().startsWith(v + ' ')) {
                            btn.classList.add('selected-score');
                        }
                    });
                }
            });
        });

        // Re-apply button pressed states
        metrics.forEach(f => {
            if (entry[f]) {
                entry[f].forEach(v => {
                    const idx = metrics.indexOf(f);
                    const col = document.querySelectorAll('.score-column')[idx];
                    if (col) {
                        const btns = col.querySelectorAll('button');
                        btns.forEach(btn => {
                            if (btn.textContent.trim().startsWith(v + ':') || btn.textContent.trim().startsWith(v + ' ')) {
                                btn.classList.add('selected-score');
                            }
                        });
                    }
                });
            }
        });
        try {
            logData = JSON.parse(localStorage.getItem("tripLog")) || [];
        } catch {}
        renderTable();
    };
    </script>
<!-- Manual Score Entry Modal -->
<div id="scoreModal">
<h3>Manual Score Entry</h3>
<label>
            Rush: 
            <input id="manualRush" max="10" min="-10" type="number"/>
</label>
<br/>
<label>
            Mood: 
            <input id="manualMood" max="10" min="-10" type="number"/>
</label>
<br/>
<label>
            Social: 
            <input id="manualSocial" max="10" min="-10" type="number"/>
</label>
<br/>
<label>
            Energy: 
            <input id="manualEnergy" max="10" min="-10" type="number"/>
</label>
<br/>
<label>
            Focus: 
            <input id="manualFocus" max="10" min="-10" type="number"/>
</label>
<br/>
<label>
            Anxiety: 
            <input id="manualAnxiety" max="10" min="-10" type="number"/>
</label>
<br/>
<label>
            Impair: 
            <input id="manualImpair" max="10" min="-10" type="number"/>
</label>
<br/>
<br/>
<button onclick="applyManualScores()">Apply</button>
<button onclick="closeScoreModal()">Cancel</button>
</div>
<!-- Emotion Wheel Modal -->
<div id="emotionModal" style="display:none; position:fixed; top:10%; left:50%; transform:translateX(-50%);
     background:#fff; padding:20px; border:2px solid #007aff; border-radius:8px; box-shadow:0 4px 8px rgba(0,0,0,0.2); z-index:1000; max-height:80%; overflow:auto;">
<h3>Select Emotions</h3>
<img alt="Emotion Wheel" src="emotion_wheel.jpg" style="width:100%; max-width:500px; margin-bottom:10px; border:1px solid #ccc;"/>
<div id="emotionButtons" style="display:flex; flex-wrap:wrap; gap:6px; margin-top:10px; justify-content:center;"></div>
<br/>
<button onclick="closeEmotionModal()">Close</button>
</div>
<script>
document.addEventListener("DOMContentLoaded", () => {
    document.querySelectorAll('.score-column button').forEach(btn => {
        const val = btn.textContent.trim().split(':')[0];
        if (["0", "1", "2", "3", "4", "5"].includes(val)) {
            btn.style.height = '40px';
        }
    });
});
</script></body>
<script>
function openEmotionModal() {
    document.getElementById('emotionModal').style.display = 'block';
    buildEmotionButtons();
}
function closeEmotionModal() {
    document.getElementById('emotionModal').style.display = 'none';
}
function buildEmotionButtons() {
    const container = document.getElementById("emotionButtons");
    if (container.childNodes.length > 0) return; // Avoid rebuilding
    const emotions = [
        "Joy","Happy","Cheerful","Content","Proud","Optimistic","Excited","Energetic","Affectionate","Compassionate","Peaceful","Relieved","Satisfied","Love",
        "Fear","Scared","Frightened","Helpless","Panic","Insecure","Worried","Nervous","Horrified","Terrified","Hysterical","Anxious","Overwhelmed",
        "Anger","Annoyed","Agitated","Frustrated","Mad","Rage","Hostile","Hateful","Jealous","Bitter","Irritated","Exasperated",
        "Sadness","Depressed","Lonely","Isolated","Ashamed","Guilty","Disappointed","Sorrow","Grief","Despair","Hurt","Powerless","Neglected",
        "Surprise","Amazed","Startled","Stunned","Confused","Shocked","Speechless","Awestruck","Overcome","Perplexed","Disillusioned"
    ];
    emotions.forEach(word => {
        const btn = document.createElement('button');
        btn.textContent = word;
        btn.className = 'note-btn';
        btn.style.minWidth = '80px';
        btn.onclick = () => {
            const notes = document.getElementById('notesInput');
            if (!notes.value.includes(word)) {
                notes.value = (notes.value + ' ' + word).trim();
            }
        };
        container.appendChild(btn);
    });
}
</script>
</html>