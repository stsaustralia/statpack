<script>
/* ===== Unified CONFIG (2025/10/31 12:00:00) ===== */
// statpack
(() => {
  'use strict';

  Object.defineProperty(window,'CONFIG',{ value:CONFIG, writable:false, enumerable:true });

  // Back-compat for any legacy reads
  if (!window.STS_UI) window.STS_UI = { table: CONFIG.ui.table };
})();
</script>

<!-- Shared UI rules -->
<style>
  :root {
    --metric-btn-min-w: 64px;
    --metric-btn-min-h: 30px;
    --metric-btn-pad-b: 6px;
    --metric-btn-pad-i: 10px;
    --metric-btn-font: 0.95rem;
    --metric-btn-gap: 6px;
  }
/* Modal-scoped metric button styles */
.modal .metric-btn,
.modal-content .metric-btn {
  min-width: var(--metric-btn-min-w);
  min-height: var(--metric-btn-min-h);
  padding-block: var(--metric-btn-pad-b);
  padding-inline: var(--metric-btn-pad-i);
  font-size: var(--metric-btn-font);
}


  .metric-grid { display:grid; grid-auto-flow:column; gap:var(--metric-btn-gap); align-items:start; }
</style>

<script>
/* Central config for popups/windows (non-breaking defaults) */
window.CONFIG = window.CONFIG || {};
CONFIG.popups = Object.assign({
  rollingAverage: {
    intervalMs: 15000,
    windowRows: 5
  },
  autoEntries: {
    intervalMs: 15000
  },
  autoSliderC: {
    refreshMs: 15000,
    windowRows: 5
  },
  autoSliderD: {
    intervalMs: 30000,
    windowRows: 2
  },
  summary: {
    windowMinutes: 5,
    emitEveryMinute: true
  },
  significant5m: {
    intervalMs: 5 * 60000,
    alignToBoundary: true
  },
  roamingAverage: {
    intervalMs: 15000,
    windowSeconds: 15
  }
}, CONFIG.popups || {});
</script>

<!DOCTYPE html>

<html lang="en">
<head>
<style>


/* === Consolidated CSS (order preserved) === */

/* --- block --- */
#logTable {
  display: block;
/* 
  max-height: calc(20 * 42px); /* ~40px per row incl. padding/border
 */
  max-height: calc(25 * 42px); /* ~40px per row incl. padding/border
 */

  overflow-y: auto;
}
    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background: #f9f9f9;
        color: #000;
        margin: 0;
        padding: 20px;
    }

    h1 {
        color: #007aff;
    }

    .controls {
        margin-bottom: 20px;
    }

    .controls button, .controls label {
        margin-right: 10px;
    }

    input, select, textarea {
        background: #fff;
        color: #000;
        border: 1px solid #ccc;
        padding: 6px 10px;
        border-radius: 6px;
        margin: 4px;
        font-size: 12px;
    }

    .score-columns {
    display: grid;
    grid-template-columns: repeat(7, 1fr); /* exactly 10 columns */
    gap: 5px;
    margin-top: 10px;
}

.score-column {
    display: flex;
	flex-wrap: wrap;
    flex-direction: column;
    align-items: center;
}

    .score-column button {
/* 
        width: 140px;
        height: 30px;
        BOOKMARK
 */
        width: 140px;
        height: 28px;
        margin: 1px;
        border-radius: 6px;
        border: 1px solid #ccc;
        background: #fff;
        font-size: 12px;
    }

    .selected-score {
        background-color: #007aff !important;
        color: #fff !important;
        font-weight: bold;
        border: 2px solid #000;
    }

    table {
        width: 100%;
        border-collapse: collapse;
        background: #fff;
        margin-top: 20px;
    }

    table, th, td {
        border: 1px solid #ccc;
    }

    th, td {
        padding: 10px;
        text-align: center;
        font-size: 12px;
    }

    #extraNoteButtons {
        display: grid;
        grid-template-columns: repeat(7, 80px);
        gap: 2px;
        margin-top: 10px;
    }

    .note-btn {
        width: 80px;
        height: 20px;
        font-size: 11px;
        padding: 0;
        border-radius: 6px;
        border: 1px solid #ccc;
        background: #f2f2f2;
        color: #000;
        transition: box-shadow 0.1s;
        margin: 0;
    }

    .note-btn.selected-score {
        box-shadow: 0 0 0 2px #000;
        color: #fff;
    }

    .note-btn[data-category="gold"] {
        background: gold;
        color: #000;
    }

    .note-btn[data-category="dose"] {
        background: #444;
        color: #fff;
    }

    .note-btn[data-category="blue"] {
        background: #007aff;
        color: #fff;
    }

    .note-btn[data-category="red"] {
        background: red;
        color: #fff;
    }

    .note-btn[data-category="green"] {
        background: green;
        color: #fff;
    }

    .note-btn[data-category="orange"] {
        background: orange;
        color: #000;
    }

    .note-btn[data-category="yellow"] {
        background: #ffeb3b;
        color: #000;
    }

    #scoreModal {
        display: none;
        position: fixed;
        top: 15%;
        left: 50%;
        transform: translateX(-50%);
        background: #fff;
        padding: 20px;
        border: 2px solid #007aff;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        z-index: 1000;
    }

    #scoreModal input {
        width: 60px;
    }

  .note-btn[data-category="purple"] {
    background-color: rebeccapurple;
    color: #fff;
  }

/* Auto-summary Button */
    #autoSummaryToggleBtn{ /* fixed removed */ }

/* Horizontal layout for summary buttons at top-right */

.summary-controls button{
  width:auto; /* allow natural width */
  white-space:nowrap;
}

/* --- block --- */
#autoSummaryDock{
  margin-top: 20px;
}
#autoSummaryTable{
  width:100%;
  border-collapse: collapse;
  background: #fff;
}
#autoSummaryTable th, #autoSummaryTable td{
  border:1px solid #ccc;
  padding:10px;
  text-align:center;
  font-size:11px;
}
#autoSummaryTitle{
  font-weight:600;
  margin:6px 0;
}

/* --- block --- */
/* ==== Summary Controls Layout Override (spread horizontally) ==== */

.summary-controls button{
  position: static !important; /* cancel fixed on individual buttons */
  top: auto !important;
  right: auto !important;
  width: auto;
  white-space: nowrap;
  background: #007aff;
  color: #fff;
  border: none;
  padding: 8px 14px;
  border-radius: 6px;
  cursor: pointer;
}
.summary-controls #autoSummaryToggleBtn{
  background: #008CBA; /* keep distinct colour for Auto */
}

/* Explicitly override any earlier fixed rules on these IDs */
#summary5Btn, #summary15Btn, #summary60Btn, #autoSummaryToggleBtn{
  position: static !important;
  top: auto !important;
  right: auto !important;
}

/* --- block --- */
/* Rated Popup modal */
#ratedPopupModal{display:none; position:fixed; inset:0; z-index:10000;}
#ratedPopupBackdrop{position:absolute; inset:0; background:rgba(0,0,0,0.45);}
#ratedPopupCard{position:relative; margin:8vh auto; width:min(700px,90vw); max-height:84vh; overflow:auto;
  background:#fff; border-radius:12px; box-shadow:0 10px 34px rgba(0,0,0,0.25); padding:16px; border:2px solid #007aff;}
#ratedPopupCard h2{margin:0 0 8px 0; font-size:18px;}
#ratedPopupTable{width:100%; border-collapse:collapse; background:#fff;}
#ratedPopupTable th,#ratedPopupTable td{border:1px solid #ccc; padding:8px; text-align:left; font-size:12px;}

/* --- block --- */

.badge.none{ background:#eee; color:#000; }
.badge.low{ background:red; color:#fff; }
.badge.medium{ background:#ffeb3b; color:#000; }
.badge.high{ background:green; color:#fff; }

/* --- block --- */
/* Category cell shading */
#ratedPopupTable td.cat.none, #allRatedPopupTable td.cat.none { background:#eee; color:#000; }
#ratedPopupTable td.cat.low,  #allRatedPopupTable td.cat.low  { background:red; color:#fff; }
#ratedPopupTable td.cat.medium,#allRatedPopupTable td.cat.medium { background:#ffeb3b; color:#000; }
#ratedPopupTable td.cat.high, #allRatedPopupTable td.cat.high { background:green; color:#fff; }

/* --- block --- */
/* Category cell shading for both popups */
#ratedPopupTable td.cat.none, #allRatedPopupTable td.cat.none { background:transparent; color:inherit; }
#ratedPopupTable td.cat.verylow, #allRatedPopupTable td.cat.verylow { background:rgb(255,0,0); color:#fff; }
#ratedPopupTable td.cat.low, #allRatedPopupTable td.cat.low { background:rgba(255,0,0,0.5); color:#000; }
#ratedPopupTable td.cat.medium, #allRatedPopupTable td.cat.medium { background:#ffeb3b; color:#000; }
#ratedPopupTable td.cat.high, #allRatedPopupTable td.cat.high { background:rgba(0,128,0,0.5); color:#000; }
#ratedPopupTable td.cat.veryhigh, #allRatedPopupTable td.cat.veryhigh { background:rgb(0,128,0); color:#fff; }
/* Badge styling aligns with cell class but cell shading dominates */


/* --- block --- */
#slidingAvgModal {
  display:none; position:fixed; top:8%; left:50%; transform:translateX(-50%);
  background:#fff; color:#000; padding:16px; border:2px solid #007aff;
  border-radius:8px; box-shadow:0 4px 8px rgba(0,0,0,0.2); z-index:10001; max-height:80%;
  overflow:auto; min-width: 70%;
}
#slidingAvgModal table{ width:100%; border-collapse:collapse; background:#fff; margin-top:10px; }
#slidingAvgModal th, #slidingAvgModal td{ border:1px solid #ccc; padding:8px; text-align:center; font-size:11px; }
#slidingAvgClose { background:#ccc; color:#000; border:none; padding:6px 10px; border-radius:6px; cursor:pointer; float:right; }

/* --- block --- */
#autoSliderAModal, #autoSliderBModal {
  display:none; position:fixed; top:8%; left:50%; transform:translateX(-50%);
  background:#fff; color:#000; padding:16px; border:2px solid #007aff;
  border-radius:8px; box-shadow:0 4px 8px rgba(0, 0, 0, 0.2); z-index:10002; max-height:80%;
  overflow:auto; min-width: 72%;
}
#autoSliderAModal table, #autoSliderBModal table { width:100%; border-collapse:collapse; background:#fff; margin-top:10px; }
#autoSliderAModal th, #autoSliderAModal td, #autoSliderBModal th, #autoSliderBModal td {
  border:1px solid #ccc; padding:8px; text-align:center; font-size:11px;
}
.as-toolbar { display:flex; gap:8px; align-items:center; justify-content:flex-end; }
.as-toolbar button { background:#eee; color:#000; border:1px solid #ccc; padding:6px 10px; border-radius:6px; cursor:pointer; }

/* --- block --- */
#labelGearBtn {
    position: fixed; right: 14px; bottom: 18px; z-index: 9999;
    width: 42px; height: 42px; border-radius: 50%;
    border: 1px solid rgba(0,0,0,0.2); background: #fff; cursor: pointer;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    display: flex; align-items: center; justify-content: center; font-size: 22px;
  }
  #labelSettingsModal {
    position: fixed; inset: 0; background: rgba(0,0,0,0.45);
    display: none; align-items: center; justify-content: center; z-index: 10000;
  }
  #labelSettingsCard {
    width: min(900px, 92vw); max-height: 86vh; overflow: auto;
    background: #fff; border-radius: 10px; padding: 16px 18px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.35); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  }
  #labelSettingsCard h2 { margin: 0 0 10px 0; }
  .ls-row { display: grid; grid-template-columns: 160px 1fr; gap: 10px; margin: 6px 0; align-items: center; }
  .ls-controls { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
  .ls-controls button { padding: 6px 10px; }
  #ls-preview { border: 1px solid #ddd; border-radius: 8px; padding: 8px; max-height: 240px; overflow: auto; font-size: 12px; }
  #ls-tabs { display: flex; gap: 8px; margin-bottom: 10px; }
  #ls-tabs button { padding: 6px 10px; border: 1px solid #ccc; background: #f7f7f7; cursor: pointer; border-radius: 6px; }
  #ls-tabs button.active { background: #e9f2ff; border-color: #9cc1ff; }
  .ls-panel { display: none; }
  .ls-panel.active { display: block; }

/* --- block --- */
/* Basic modal styles in case project doesn’t have them */
  .modal { position: fixed; z-index: 9999; left:0; top:0; width:100%; height:100%; overflow:auto; background: rgba(0,0,0,0.5); }
  .modal-content { background: #fff; margin: 4vh auto; padding: 11px 16px; border: 1px solid #888; border-radius: 10px; }
  .modal .close { float:right; font-size: 28px; cursor: pointer; }
  .table.compact th, .table.compact td { padding: 4px 6px; }

/* --- block --- */
/* Tables inside the two new modals */
  #autoEntriesModal table, #rollingAverageModal table{
    width:100%; border-collapse:collapse; background:#fff; margin-top:10px;
  }
  #autoEntriesModal th, #autoEntriesModal td,
  #rollingAverageModal th, #rollingAverageModal td{
    border:1px solid #ccc; padding:8px; text-align:center; font-size:11px;
  }
  .as-toolbar { display:flex; gap:8px; align-items:center; justify-content:flex-end; }
  .as-toolbar button { background:#eee; color:#000; border:1px solid #ccc; padding:6px 10px; border-radius:6px; cursor:pointer; }

/* --- block --- */
#roamingEntriesModal.sts-modal { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.4); z-index:99999; }
#roamingEntriesModal .sts-box { background:#fff; color:#111; width:min(1100px, 96vw); max-height:90vh; margin:3vh auto; border-radius:10px; box-shadow:0 10px 30px rgba(0,0,0,0.2); display:flex; flex-direction:column; overflow:hidden; }
#roamingEntriesModal .sts-hdr { display:flex; align-items:center; justify-content:space-between; gap:11px; padding:11px 16px; border-bottom:1px solid #ddd; }
#roamingEntriesModal .sts-hdr h2 { margin:0; font-size:18px; }
#roamingEntriesModal .sts-hdr .sts-status { font-size:11px; opacity:0.8; }
#roamingEntriesModal .sts-ctl { display:flex; gap:8px; padding:8px 16px; border-bottom:1px solid #eee; flex-wrap:wrap; }
#roamingEntriesModal .sts-ctl button { padding:6px 10px; border-radius:6px; border:1px solid #ccc; background:#f8f8f8; cursor:pointer; }
#roamingEntriesModal .sts-bdy { padding:8px 16px; overflow:auto; }
#roamingEntriesTable { width:100%; border-collapse:collapse; font-size:13px; }
#roamingEntriesTable thead th { position:sticky; top:0; background:#fafafa; border-bottom:1px solid #ddd; text-align:left; padding:6px; }
#roamingEntriesTable tbody td { border-bottom:1px solid #eee; padding:6px; white-space:nowrap; }

/* --- block --- */
#roamingAverageModal.sts-modal { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.4); z-index:99999; }
#roamingAverageModal .sts-box { background:#fff; color:#111; width:min(1100px, 96vw); max-height:90vh; margin:3vh auto; border-radius:10px; box-shadow:0 10px 30px rgba(0,0,0,0.2); display:flex; flex-direction:column; overflow:hidden; }
#roamingAverageModal .sts-hdr { display:flex; align-items:center; justify-content:space-between; gap:11px; padding:11px 16px; border-bottom:1px solid #ddd; }
#roamingAverageModal .sts-hdr h2 { margin:0; font-size:18px; }
#roamingAverageModal .sts-hdr .sts-status { font-size:11px; opacity:0.8; }
#roamingAverageModal .sts-ctl { display:flex; gap:8px; padding:8px 16px; border-bottom:1px solid #eee; flex-wrap:wrap; }
#roamingAverageModal .sts-ctl button { padding:6px 10px; border-radius:6px; border:1px solid #ccc; background:#f8f8f8; cursor:pointer; }
#roamingAverageModal .sts-bdy { padding:8px 16px; overflow:auto; }
#roamingAverageTable { width:100%; border-collapse:collapse; font-size:13px; }
#roamingAverageTable thead th { position:sticky; top:0; background:#fafafa; border-bottom:1px solid #ddd; text-align:left; padding:6px; }
#roamingAverageTable tbody td { border-bottom:1px solid #eee; padding:6px; white-space:nowrap; }

/* --- block --- */
/* === Consolidated overrides === */
.summary-controls{
  position: fixed;
  top: 10px;
  left: 20px;
  right: 20px;
  display: grid;
  grid-template-columns: repeat(12, auto);
  grid-auto-rows: auto;
  align-items: center;
  justify-content: start;
  gap: 8px 11px;
  z-index: 9999;
  pointer-events: auto;
}
.summary-controls button{
  position: static !important;
  width: auto;
  white-space: nowrap;
  background: #007aff;
  color: #fff;
  border: none;
  padding: 8px 14px;
  border-radius: 6px;
  cursor: pointer;
}
.summary-controls #autoSummaryToggleBtn{ background:#008CBA; }

/* Single, consistent badge style (cells control shading; badge is neutral) */
.badge{ display:inline-block; padding:3px 8px; border-radius:10px; font-weight:600; background:transparent; color:inherit; }

</style>

<meta charset="utf-8"/>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27/%3E">
<title>statpack v1.26.7 r2565</title>

<!-- removed fixed-position block for summary buttons (replaced by .summary-controls) -->



<!-- UI CONFIG (auto-injected) -->
<script>
function computeFiveMax(obj){
  const rush    = +obj.rush    || 0;
  const mood    = +obj.mood    || 0;
  const social  = +obj.social  || 0;
  const energy  = +obj.energy  || 0;
  const focus   = +obj.focus   || 0;
  const anxiety = +obj.anxiety || 0;
  const impair  = +obj.impair  || 0;
  return ((rush + mood + social + energy + focus - anxiety - impair) / 5) + 5;
}



function computeWeighted(obj){
  // Expect shape with keys: rush, mood, social, energy, focus, anxiety, impair
  // Coefficients: +6,+4,+4,+3,+3,-4,-6 then divide by 10
  const rush    = +obj.rush    || 0;
  const mood    = +obj.mood    || 0;
  const social  = +obj.social  || 0;
  const energy  = +obj.energy  || 0;
  const focus   = +obj.focus   || 0;
  const anxiety = +obj.anxiety || 0;
  const impair  = +obj.impair  || 0;
  return ((rush*6) + (mood*4) + (social*4) + (energy*3) + (focus*3) - (anxiety*4) - (impair*6)) / 10;
}
(function() {
  const DEFAULTS = {
    shadingEnabled: true,
    tables: {
      main:           { visibleColumns: ["Time","Rush","Mood","Social","Energy","Focus","Anxiety","Impair","Score","TotalScore","TotalWeighted","Min","Max","Weighted","5Max"] },
      roaming:        { visibleColumns: ["Time","Rush","Mood","Social","Energy","Focus","Anxiety","Impair","Score","TotalScore","TotalWeighted","Min","Max"] },
      roamingAverage: { visibleColumns: ["Time","Rush","Mood","Social","Energy","Focus","Anxiety","Impair","Score","TotalScore","TotalWeighted","Min","Max"] },
      slidingAverage: { visibleColumns: ["Time","Rush","Mood","Social","Energy","Focus","Anxiety","Impair","Score","TotalScore","TotalWeighted","Min","Max"] }
    },
    roamingScoreMode: "mean"
  };
  const cur = (window.STS_UI && typeof window.STS_UI === 'object') ? window.STS_UI : {};
  function deepMerge(a, b) {
    const out = Object.assign({}, a);
    for (const k of Object.keys(b)) {
      if (b[k] && typeof b[k] === 'object' && !Array.isArray(b[k])) out[k] = deepMerge(a[k]||{}, b[k]);
      else out[k] = b[k];
    }
    return out;
  }
  window.STS_UI = deepMerge(DEFAULTS, cur);
  window.STS_isColVisible = function(tableKey, colName) {
    try {
      const vis = window.STS_UI.tables?.[tableKey]?.visibleColumns;
      if (Array.isArray(vis)) return vis.includes(colName);
    } catch(e) {}
    return true;
  };
  window.STS_applyShading = function(tr) {
    if (!window.STS_UI?.shadingEnabled) return;
    if (typeof window.applyRowShading === 'function') {
      try { window.applyRowShading(tr); } catch(e) {}
    }
  };
})();
</script>
<!-- /STS: UI CONFIG (auto-injected) -->







<style id="rapid-scores-size-override">
/* 
BOOKMARK FOR SCORING WINDOW SIZES
 */
  /* Scoped size overrides for Rapid Scores modal buttons only BOOKMARK */
  #rapidScoresModal .score-column button {
    width: 140px;
    height: 20px;
    font-size: 12px;
  }
</style>


<style id="unlocked-scores-size-override">
  /* Scoped size overrides for Unlocked Mode modal buttons only */
  #unlockedModeModal .score-column button {
    width: 150px;
    height: 25px;
    font-size: 13px;
  }
</style>
<style id="fast-mode-size-override">
  /* Fast Mode modal button sizing */
  #fastModeModal .score-column button {
    width: 160px;
    height: 25px;
    font-size: 13px;
  }
</style>
<body>

<!-- Column Chooser UI -->
<div id="columnChooser" style="position:fixed; top:70px; right:20px; background:#fff; border:1px solid #ddd; border-radius:8px; padding:12px; box-shadow:0 2px 8px rgba(0,0,0,0.15); z-index:10000; display:none; max-height:70vh; overflow:auto; width:260px;">
  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
    <strong>Columns</strong>
    <button id="colChooserClose" aria-label="Close">×</button>
  </div>
  <div id="columnChooserList"></div>
</div>
<button id="colChooserToggle" style="position:fixed; top:70px; right:20px; z-index:10000;">Columns</button>


<div class="summary-controls">
<button id="summary60Btn" onclick="setSummaryWindowAndOpen(60)">Summary 60m</button>
<button id="unlockedModeBtn" type="button" title="Open Unlocked Mode">Unlocked Mode</button>
<button id="summary15Btn" onclick="setSummaryWindowAndOpen(15)">Summary 15m</button>
<button id="summary5Btn" onclick="setSummaryWindowAndOpen(5)">Summary 5m</button>
<button id="slidingAvgBtn" onclick="openSlidingAverage()">Sliding Average</button>
<button id="doseReviewsBtn" onclick="openDoseReviews()">Dose Reviews</button>
<button id="allRated5mBtn" onclick="openAllRated5MinutesPopup()">All Rated 5-Minute</button>
<button id="autoSliderABtn" onclick="openAutoSliderA()">Auto Slider A</button>
<button id="autoSliderBBtn" onclick="openAutoSliderB()">Auto Slider B</button>
<button id="significant5mBtn" onclick="openSignificant5m()">Summary Significant 5m</button>
<button id="statAnalysisBtn" onclick="openStatAnalysis()">Statistical Analysis</button>
<button id="statAnalysisHourBtn" onclick="openStatAnalysisHourly()">Statistical Analysis (60m)</button>
<button id="statAnalysisDailyBtn" onclick="openStatAnalysisDaily()">Statistical Analysis Daily</button>
<button id="autoSummaryToggleBtn" onclick="toggleAutoSummary()">Auto</button>

<button id="autoSliderA2Btn" onclick="openAutoSliderA2()">Auto Slider A2</button>
<button id="autoSliderCBtn" onclick="openAutoSliderC()">Auto Slider C</button>
<button id="autoSliderDBtn" onclick="openAutoSliderD()">Auto Slider D</button>
<button id="reviewBtn" onclick="openReview()">Review</button>
<button id="autoEntriesBtn" onclick="openAutoEntries()">Auto Entries</button>
<button id="rollingAvgBtn" onclick="openRollingAverage()">Rolling Average</button>
<button id="allRatedRowsBtn" onclick="openAllRatedPopup()">All Rated (Rows)</button>
<button id="allRatedOutOf10Btn" onclick="openAllRatedOutOf10Popup()">All Rated /10</button>

<button id="allRated5m10Btn" onclick="openAllRated5MinutesOutOf10Popup()">All Rated 5m /10</button>

<button id="ratedPopupBtn" onclick="openRatedPopup()">Rated Popup</button>
<button id="allRatedPopupBtn" onclick="openAllRatedPopup()">All Rated Popup</button>
</div>
<h1>statpack</h1>
<div class="controls">
<label style="margin-left:12px;font-size:12px;"><input type="checkbox" id="dualSelToggle" onchange="CONFIG.dualSelectionAdjust.enabled=this.checked;"> Adjust dual‑select (−0.5)</label>
<span style="margin-left:8px; padding:3px 6px; border:1px solid #007aff; border-radius:6px; color:#007aff; font-size:11px;">Append Mode</span>
<button onclick="newTrip()">New Log</button>
<button onclick="resetTimer()">Reset Timer</button>
<button onclick="pauseTimer()">Pause Timer</button>
<label>
<input id="redoseCheckbox" type="checkbox"/>
             Redose
        </label>
<button id="addBtn" onclick="addEntry('main')">Add Entry</button>
<button onclick="deleteSelected()">Delete Selected</button>
<button onclick="editSelected()">Edit Selected</button>
<button onclick="exportCSV()">Export CSV</button>
<button id="openLogBtn" onclick="openExistingLog()">Open Log (Append)</button>
<input accept=".csv,text/csv" id="openLogInput" style="display:none" type="file"/>
<button onclick="openScoreModal()">Manual Score Entry</button><button onclick="openRapidScores()">Rapid Scores</button><button onclick="openFastMode()">Fast Mode</button>
<button onclick="openEmotionModal()">Emotion Wheel</button>
</div>
<div>
<label>
            Phase:
            <input id="eventInput" maxlength="50" size="50" type="text"/>
</label>
<br/>
<label>
            Scale:
            <input id="scaleInput" maxlength="50" size="30" type="text"/>
</label>
<br/>
<label>
            Add:

            <select id="drugSelect">
<option value="">--Select--</option>
<option value="Hit">Hit</option>
<option value="Redose">Redose</option>
<option value="Between">Between</option>
<option value="Finished">Finished</option>
<option value="JustRedosed">JustRedosed</option>
<option value="MidRedose">MidRedose</option>
<option value="MD-PiHP">MD-PiHP</option>
<option value="2ME-PiHP">2ME-PiHP</option>
<option value="A-PiHP">A-PiHP</option>
<option value="3F-PiHP">3F-PiHP</option>
<option value="A-PHP">A-PHP</option>
<option value="A-PVP">A-PVP</option>
<option value="Cathinone">Cathinone</option>
<option value="Unknown">Unknown</option>
<option value="Food">Food</option>
<option value="Drink">Drink</option>
<option value="Sleep">Sleep</option>
<option value="Exercise">Exercise</option>
<option value="NN-DMC">NN-DMC</option>
<option value="Meth">Meth</option>
<option value="MDMA">MDMA</option>
<option value="2-MMC">2-MMC</option>
<option value="3-MMC">3-MMC</option>
<option value="4-MMC">4-MMC</option>
<option value="Mephedrone">Mephedrone</option>
<option value="Dust">Dust</option>
<option value="Speed">Speed</option>
<option value="Cocaine">Cocaine</option>
<option value="Crack">Crack</option>
<option value="Vodka">Vodka</option>
<option value="Weed">Weed</option>
<option value="Cone">Cone</option>
<option value="Brownie">Brownie</option>
<option value="Snowcone">TSnowconeHC</option>
<option value="Edible">Edible</option>
<option value="THC">THC</option>
<option value="Alcohol">Alcohol</option>
<option value="Benzodiazepine">Benzodiazepine</option>
<option value="Diazepam">Diazepam</option>
<option value="Alprazolam">Alprazolam</option>
<option value="Bromazolam">Bromazolam</option>
<option value="LSD">LSD</option>
<option value="Sildenafil">Sildenafil</option>
<option value="Other">Other</option>



</select>
</label>
<label>
            qty:
            <input id="qtyInput" size="6" type="number"/>
</label>
<label>
            Detail:
            <input id="roaInput" size="10" type="text"/>
</label>
<br/>
<label>Notes:</label>
<br/>
<textarea cols="50" id="notesInput" rows="3"></textarea>
<br/>
<div style="display: flex; gap: 10px;"><label>Last:</label>
<br/>
<textarea cols="50" id="customNotesInput" rows="3"></textarea></div>
</div>
<div style="display: flex; align-items: flex-start; gap: 20px;">
<div class="score-columns" id="scoreColumns"></div>
<!-- Note Button Rows (grouped by colour) -->
<div id="noteButtonRows" style="display:flex; flex-direction:column; gap:6px; margin:8px 0;">
<!-- Rows will be populated by JS -->
</div>
<div id="noteButtons"></div>
<div id="extraNoteButtons"></div>
</div>
<div id="timer" style="margin-top: 10px;">Time: 00:00:00</div>
<table id="logTable">
<thead>
<tr>
<th data-col="Select">Select</th>
<th data-col="Timestamp">Timestamp</th>
<th data-col="Since">Since</th>
<th data-col="Elapsed">Elapsed</th>
<th data-col="Phase">Phase</th>
<th data-col="Scale">Scale</th>
<th data-col="Drug">Drug</th>
<th data-col="QTY">QTY</th>
<th data-col="ROA">ROA</th>
<th data-col="Rush">Rush</th>
<th data-col="Rush">Rush</th>
<th data-col="Mood">Mood</th>
<th data-col="Mood">Mood</th>
<th data-col="Social">Social</th>
<th data-col="Social">Social</th>
<th data-col="Energy">Energy</th>
<th data-col="Energy">Energy </th>
<th data-col="Focus">Focus</th>
<th data-col="Focus">Focus</th>
<th data-col="Anxiety">Anxiety</th>
<th data-col="Anxiety">Anxiety</th>
<th data-col="Impair">Impair</th>
<th data-col="Impair">Impair</th><th data-col="change">change</th><th data-col="Change">Change</th><th data-col="Deg">Deg</th><th data-col="D2">D2</th><th data-col="Oth">Oth</th><th data-col="O2">O2</th>
<th data-col="Confidence">Confidence</th><th data-col="Confidence">Confidence</th><th data-col="Auto">Auto</th><th data-col="Auto">Auto</th><th data-col="Jitter">Jitter</th><th data-col="Jitter">Jitter</th><th data-col="Dopamine">Dopamine</th><th data-col="Dopamine">Dopamine</th><th data-col="Score">Score</th>
<th data-col="Max">Max</th>
<th data-col="Min">Min</th>
<th data-col="VL">VL</th>
<th data-col="sM">sM</th>
<th data-col="sB">sB</th>
<th data-col="sF">sF</th>
<th data-col="Last">Last</th>
<th data-col="Notes">Notes</th>
<th data-col="Weighted">Weighted</th><th data-col="5Max">5Max</th><th data-col="GS">GS</th>
</tr>
</thead>
<tbody></tbody>
</table>
<div id="autoSummaryDock">
<div id="autoSummaryTitle">Auto Summary (1m rolling)</div>
<table id="autoSummaryTable">
<thead><tr><th>Time</th><th>Rush</th><th>Mood</th><th>Social</th><th>Energy</th><th>Focus</th><th>Anxiety</th><th>Impair</th><th>Score</th><th>Max</th><th>Min</th><th>Weighted</th><th>5Max</th></tr></thead>
<tbody></tbody>
</table>
</div>
<!-- Additional Summary Docks (separate targets) -->
<div id="summary5Dock" style="margin-top:20px;">
<div id="summary5Title">Summary 5m (rolling)</div>
<div id="backfillRow" style="margin:10px 0; padding:8px; border:1px solid #ccc; background:#f9f9f9;">
<strong>Manual Backfill:</strong>
<button class="ctrl-btn" id="backfillBtn" style="margin-left:10px;">Run Backfill</button>
</div>
<table id="summary5Table" style="width:100%; border-collapse:collapse; background:#fff;">
<thead><tr><th>Time</th><th>Rush</th><th>Mood</th><th>Social</th><th>Energy</th><th>Focus</th><th>Anxiety</th><th>Impair</th><th>Score</th><th>Max</th><th>Min</th><th>Weighted</th><th>5Max</th></tr></thead>
<tbody></tbody>
</table>
</div>
<div id="summary15Dock" style="margin-top:20px;">
<div id="summary15Title">Summary 15m (rolling)</div>
<table id="summary15Table" style="width:100%; border-collapse:collapse; background:#fff;">
<thead><tr><th>Time</th><th>Rush</th><th>Mood</th><th>Social</th><th>Energy</th><th>Focus</th><th>Anxiety</th><th>Impair</th><th>Score</th><th>Max</th><th>Min</th><th>Weighted</th><th>5Max</th></tr></thead>
<tbody></tbody>
</table>
</div>
<div id="summary60Dock" style="margin-top:20px;">
<div id="summary60Title">Summary 60m (rolling)</div>
<table id="summary60Table" style="width:100%; border-collapse:collapse; background:#fff;">
<thead><tr><th>Time</th><th>Rush</th><th>Mood</th><th>Social</th><th>Energy</th><th>Focus</th><th>Anxiety</th><th>Impair</th><th>Score</th><th>Max</th><th>Min</th><th>Weighted</th><th>5Max</th></tr></thead>
<tbody></tbody>
</table>
</div>
<!-- ──────────────────────────────────────────────────────────────────────────
     Dose Reviews Modal
     Mirrors currently visible rows from the MAIN table and adds 4 summary rows
     (Average / Median / Minimum / Maximum) for numeric metrics.
     ───────────────────────────────────────────────────────────────────────── -->
<div id="doseReviewsModal" style="display:none; position:fixed; inset:0; z-index:9999;">
<div id="doseReviewsBackdrop" style="position:absolute; inset:0; background:rgba(0,0,0,0.45);"></div>
<div id="doseReviewsCard" style="
      position:relative; margin:4vh auto; width:min(1200px,94vw); max-height:92vh; overflow:auto;
      background:#fff; border-radius:14px; box-shadow:0 10px 40px rgba(0,0,0,0.25); padding:16px;">
<div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px;">
<div style="font-weight:700; font-size:20px;">Dose Reviews</div>
<div style="display:flex; gap:8px; align-items:center;">
<button onclick="exportDoseReviewsCsv()" title="Export table to CSV">Export CSV</button>
<button aria-label="Close" onclick="closeDoseReviews()">Close</button>
</div>
</div>
<div id="doseReviewsMeta" style="font-size:11px; opacity:0.7; margin-bottom:8px;"></div>
<table id="doseReviewsTable" style="width:100%; border-collapse:collapse; background:#fff;">
<thead>
<tr>
<th>Label</th>
<th>Segment</th>
<th>Time</th><th>Rush</th><th>Mood</th><th>Social</th><th>Energy</th><th>Focus</th><th>Anxiety</th><th>Impair</th>
<th>Score</th><th>Max</th><th>Min</th><th>Weighted</th><th>5Max</th>
</tr>
</thead>
<tbody></tbody>
</table>
<div style="font-size:11px; opacity:0.65; margin-top:6px;">
      Source: visible rows from the main table at open time. Re-open after filtering to refresh.
    </div>
</div>
</div>
<div id="rapidScoresModal" style="display:none; position:fixed; top:15%; left:50%; transform:translateX(-50%); background:#fff; padding:20px; border:2px solid #007aff; border-radius:8px; box-shadow:0 4px 8px rgba(0, 0, 0, 0.2); z-index:1000;">
<div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px;">
<div style="font-weight:700; font-size:18px;">Rapid Scores</div>
<button aria-label="Close" onclick="closeRapidScores()">Close</button>
</div>
<div class="score-columns" id="rapidScoresButtons"></div>
<div style="display:flex; gap:8px; justify-content:flex-end; margin-top:10px;">
<button onclick="applyRapidScores()">Apply</button>
<button onclick="applyRapidScoresAndAdd()">Apply &amp; Add Entry</button>
<button onclick="applyRapidScoresAndAddStay()">Apply, Add &amp; Stay</button></div>
</div>
<div id="unlockedModeModal" style="display:none; position:fixed; top:15%; left:50%; transform:translateX(-50%); background:#fff; padding:20px; border:2px solid #007aff; border-radius:8px; box-shadow:0 4px 8px rgba(0, 0, 0, 0.2); z-index:1000; max-width:min(96vw, 1400px);">
  <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px;">
    <div style="font-weight:700; font-size:18px;">Unlocked Mode</div>
    <button aria-label="Close" onclick="closeUnlockedMode()">Close</button>
  </div>
  <div class="score-columns" id="unlockedModeButtons"></div>
  <div id="unlockedYellowNotes" style="margin-top:14px;">
    <div style="font-weight:600; margin:8px 0 6px 0;">Yellow Notes</div>
    <div id="unlockedYellowGrid" style="display:grid; grid-template-columns: repeat(10, minmax(70px,1fr)); gap:4px;"></div>
  </div>
  <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:12px;">
    <button onclick="applyUnlocked()">Apply</button>
    <button onclick="applyUnlockedAndAdd()">Apply &amp; Add Entry</button>
    <button onclick="applyUnlockedAndAddStay()">Apply, Add &amp; Stay</button>
  </div>
</div>

<script>

// ===== Centralised read-only configuration (edit here to tweak UI/labels/sets) =====
const CONFIG = Object.freeze({
  ui: {
//     hideInUi: ['VL','sM','sB','sF','GS'],
//     hideInUi: ['VL','sM','sB','sF','GS','change',	'Change'	,'Deg'	,'D2'	,'Oth',	'O2','Weighted','5Max','Dopamine','Jitter','Auto','Confidence'],
//     hideInUi: ['VL','sM','sB','sF','GS','change','Deg','Oth'],
    hideInUi: ['sM','sB','sF','GS','change','Deg','Oth','Jitter','Confidence'],
    noShadeCols: [],
    shadeCap: {
      'Score': 30,
      'Max': 30,
      'Min': 12,
      'Weighted': 10,
      '5Max': 10
    },
  /* --- dual-selection behaviour toggle --- */
  dualSelectionAdjust: { enabled: false, delta: 0.5 },

    colorSets: {
      green: ['Rush','Mood','Social','Score','Weighted','5Max','Max'],
      gold:  ['Energy','Focus'],
      red:   ['Anxiety','Impair','Min']
      , blue:  ['Change','D2','O2','change','Deg','Oth']
      , grey:  ['Confidence','Auto','Jitter','Dopamine']}
  },
labels: {
  labelMappings: {
  rush: { 6.00: 'Overwhelming', 5.00: 'Extreme', 4.50: 'Uncontroillable', 4.00: 'Intense', 3.50: 'Energetic', 3.00: 'Energetic', 2.50: 'Physical/Contain', 2.00: 'Physical/Contain', 1.50: 'Mild/Mental', 1.00: 'Mild/Mental', 0.50: 'Present', 0.00: 'No Rush', 0.20: '+', 0.30: '+', 0.25: '+', 0.75: '+' },
  mood: { 6.00: 'Autopilot', 5.00: 'Euphoric', 4.50: 'Obvious', 4.00: 'Obvious', 3.50: 'Clear', 3.00: 'Clear', 2.50: 'Motivated', 2.00: 'Felt', 1.50: 'Felt', 1.00: 'Thought', 0.50: 'Noticed', 0.00: 'No Change', 0.20: '+', 0.30: '+', 0.25: '+', 0.75: '+' },
  social: { 6.00: 'Autopilot', 5.00: 'Disinhibited', 4.50: 'Uninhibited', 4.00: 'Outgoing', 3.50: 'Empathy/Social', 3.00: 'Empathy/Social', 2.50: 'Sociable/Push', 2.00: 'Sociable/Push', 1.50: 'Capable/Able', 1.00: 'Capable/Able', 0.50: 'Functional', 0.00: 'No/Avoidant', 0.20: '+', 0.30: '+', 0.25: '+', 0.75: '+' },
  energy: { 6.00: 'Overdrive', 5.00: 'Manic', 4.50: 'Very High', 4.00: 'Hyper', 3.50: 'Energetic', 3.00: 'Energetic', 2.50: 'Moderate', 2.00: 'Moderate', 1.50: 'Some', 1.00: 'Some', 0.50: 'Inactive', 0.00: 'None/Tired', 0.20: '+', 0.30: '+', 0.25: '+', 0.75: '+' },
  focus: { 6.00: 'Laser', 5.00: 'Wired', 4.50: 'Very Strong', 4.00: 'Obsessive', 3.50: 'Focused', 3.00: 'Focused', 2.50: 'Concentrating', 2.00: 'Concentrating', 1.50: 'Some', 1.00: 'Some', 0.50: 'Effort', 0.00: 'None/Scattered', 0.20: '+', 0.30: '+', 0.25: '+', 0.75: '+' },
  anxiety: { 6.00: 'Severe', 5.00: 'Panic', 4.50: 'Paranoid', 4.00: 'Impact Behaviour', 3.50: 'Affect Choices', 3.00: 'Affect Choices', 2.50: 'Distracting', 2.00: 'Distracting', 1.50: 'Ignorable', 1.00: 'Ignorable', 0.50: 'Negligible', 0.00: 'None', 0.20: '+', 0.30: '+', 0.25: '+', 0.75: '+' },
  impair: { 6.00: 'Dangerous', 5.00: 'Crippled', 4.50: 'Severe', 4.00: 'Adverse', 3.50: 'Serious', 3.00: 'Impacting', 2.50: 'Hinderance', 2.00: 'Some Impairment', 1.50: 'Side Effects', 1.00: 'Side Effects', 0.50: 'Negligible', 0.00: 'None', 0.20: '+', 0.30: '+', 0.25: '+', 0.75: '+' },
  change: { 5.00: 'Autopilot', 4.00: 'Dopamine', 3.00: 'Clear Shakes', 2.00: 'Tremors', 1.00: 'Effect Noticed', 0.00: 'No Change' },
  degree: { 5.00: 'Autopilot', 4.00: 'Controlling', 3.00: 'Dominating', 2.00: 'Significant', 1.00: 'Maybe', 0.00: 'None' },
  other: { 5.00: 'Now', 4.00: 'Last', 3.00: 'Late', 2.00: 'Hit', 1.00: 'Dose', 0.00: 'After' },
  confidence: { 5.00: 'Very High', 4.00: 'High', 3.00: 'Medium', 2.00: 'Low', 1.00: 'Very Low', 0.00: 'None' },
  auto: { 5.00: 'Autopilot', 4.00: 'Yes', 3.00: 'Physical', 2.00: 'Mental', 1.00: 'Maybe', 0.00: 'No' },
  jitter: { 5.00: 'Severe', 4.00: 'Obvious', 3.00: 'Adverse', 2.00: 'Shakes', 1.00: 'Tremor', 0.00: 'None' },
  dopamine: { 5.00: 'Extreme', 4.00: 'Very High', 3.00: 'High', 2.00: 'Medium', 1.00: 'Low', 0.00: 'None' },
    }
, rapidLabels: {
  rush: { 6.00: 'Overwhelming', 5.00: 'Extreme', 4.50: 'Uncontroillable', 4.00: 'Intense', 3.50: 'Energetic', 3.00: 'Energetic', 2.50: 'Physical/Contain', 2.00: 'Physical/Contain', 1.50: 'Mild/Mental', 1.00: 'Mild/Mental', 0.50: 'Present', 0.00: 'No Rush', 0.20: '+', 0.30: '+', 0.25: '+', 0.75: '+' },
  mood: { 6.00: 'Autopilot', 5.00: 'Euphoric', 4.50: 'Obvious', 4.00: 'Obvious', 3.50: 'Clear', 3.00: 'Clear', 2.50: 'Motivated', 2.00: 'Felt', 1.50: 'Felt', 1.00: 'Thought', 0.50: 'Noticed', 0.00: 'No Change', 0.20: '+', 0.30: '+', 0.25: '+', 0.75: '+' },
  social: { 6.00: 'Autopilot', 5.00: 'Disinhibited', 4.50: 'Uninhibited', 4.00: 'Outgoing', 3.50: 'Empathy/Social', 3.00: 'Empathy/Social', 2.50: 'Sociable/Push', 2.00: 'Sociable/Push', 1.50: 'Capable/Able', 1.00: 'Capable/Able', 0.50: 'Functional', 0.00: 'No/Avoidant', 0.20: '+', 0.30: '+', 0.25: '+', 0.75: '+' },
  energy: { 6.00: 'Overdrive', 5.00: 'Manic', 4.50: 'Very High', 4.00: 'Hyper', 3.50: 'Energetic', 3.00: 'Energetic', 2.50: 'Moderate', 2.00: 'Moderate', 1.50: 'Some', 1.00: 'Some', 0.50: 'Inactive', 0.00: 'None/Tired', 0.20: '+', 0.30: '+', 0.25: '+', 0.75: '+' },
  focus: { 6.00: 'Laser', 5.00: 'Wired', 4.50: 'Very Strong', 4.00: 'Obsessive', 3.50: 'Focused', 3.00: 'Focused', 2.50: 'Concentrating', 2.00: 'Concentrating', 1.50: 'Some', 1.00: 'Some', 0.50: 'Effort', 0.00: 'None/Scattered', 0.20: '+', 0.30: '+', 0.25: '+', 0.75: '+' },
  anxiety: { 6.00: 'Severe', 5.00: 'Panic', 4.50: 'Paranoid', 4.00: 'Impact Behaviour', 3.50: 'Affect Choices', 3.00: 'Affect Choices', 2.50: 'Distracting', 2.00: 'Distracting', 1.50: 'Ignorable', 1.00: 'Ignorable', 0.50: 'Negligible', 0.00: 'None', 0.20: '+', 0.30: '+', 0.25: '+', 0.75: '+' },
  impair: { 6.00: 'Dangerous', 5.00: 'Crippled', 4.50: 'Severe', 4.00: 'Adverse', 3.50: 'Serious', 3.00: 'Impacting', 2.50: 'Hinderance', 2.00: 'Some Impairment', 1.50: 'Side Effects', 1.00: 'Side Effects', 0.50: 'Negligible', 0.00: 'None', 0.20: '+', 0.30: '+', 0.25: '+', 0.75: '+' },
  change: { 5.00: 'Autopilot', 4.00: 'Dopamine', 3.00: 'Clear Shakes', 2.00: 'Tremors', 1.00: 'Effect Noticed', 0.00: 'No Change' },
  degree: { 5.00: 'Autopilot', 4.00: 'Controlling', 3.00: 'Dominating', 2.00: 'Significant', 1.00: 'Maybe', 0.00: 'None' },
  other: { 5.00: 'Now', 4.00: 'Last', 3.00: 'Late', 2.00: 'Hit', 1.00: 'Dose', 0.00: 'After' },
  confidence: { 5.00: 'Very High', 4.00: 'High', 3.00: 'Medium', 2.00: 'Low', 1.00: 'Very Low', 0.00: 'None' },
  auto: { 5.00: 'Autopilot', 4.00: 'Yes', 3.00: 'Physical', 2.00: 'Mental', 1.00: 'Maybe', 0.00: 'No' },
  jitter: { 5.00: 'Severe', 4.00: 'Obvious', 3.00: 'Adverse', 2.00: 'Shakes', 1.00: 'Tremor', 0.00: 'None' },
  dopamine: { 5.00: 'Extreme', 4.00: 'Very High', 3.00: 'High', 2.00: 'Medium', 1.00: 'Low', 0.00: 'None' },
      },
  buttonLabelsByMetric: {}},
  buttons: {
    perMetricButtons: {
      rush:[6,5,4.5,4,3.5,3,2.5,2,1.5,1,0.5,0,'',0.25,-0.25,0.75,-0.5],
      mood:[6,5,4.5,4,3.5,3,2.5,2,1.5,1,0.5,0,'',0.25,-0.25,0.75,-0.5],
      social:[6,5,4.5,4,3.5,3,2.5,2,1.5,1,0.5,0,'',0.25,-0.25,0.75,-0.5],
      energy:[6,5,4.5,4,3.5,3,2.5,2,1.5,1,0.5,0,'',0.25,-0.25,0.75,-0.5],
      focus:[6,5,4.5,4,3.5,3,2.5,2,1.5,1,0.5,0,'',0.25,-0.25,0.75,-0.5],
      anxiety:[6,5,4.5,4,3.5,3,2.5,2,1.5,1,0.5,0,'',0.25,-0.25,0.75,-0.5],
      impair:[6,5,4.5,4,3.5,3,2.5,2,1.5,1,0.5,0,'',0.25,-0.25,0.75,-0.5],
//       rush:[6,5,4,3,2,1,0,'',0.25],
//       mood:[6,5,4,3,2,1,0,'',0.25],
//       social:[6,5,4,3,2,1,0,'',0.25],
//       energy:[6,5,4,3,2,1,0,'',0.25],
//       focus:[6,5,4,3,2,1,0,'',0.25],
//       anxiety:[6,5,4,3,2,1,0,'',0.25],
//       impair:[6,5,4,3,2,1,0,'',0.25],
      confidence:[5,4,3,2,1,0],
      auto:[5,4,3,2,1,0],
      jitter:[5,4,3,2,1,0],
      dopamine:[5,4,3,2,1,0],
      change:[5,4,3,2,1,0],
      degree:[5,4,3,2,1,0],
      other: [5,4,3,2,1,0]
    },
    rapidValues: [6,5,4.5,4,3.5,3,2.5,2,1.5,1,0.5,0,'',0.25,-0.25,0.75,-0.5],


    rapidMetrics: ['rush','mood','social','energy','focus','anxiety','impair'],
//     zeroScoreMetrics: ['change','degree','other']
  },
  core: {
    metrics: ['rush','mood','social','energy','focus','anxiety','impair','change','degree','other', 'confidence','auto','jitter','dopamine']
  },
  notes: {
    extra: ['Minor', 'Major', 'Maybe', 'Usable', 'Some', 'Slight', 'Lots', 'Now', 'Then', 'Next', 'Last','Redose', 'Hit', 'Continue', 'AnxietyPreventing', 'Stereotypy', 'Scattered', 'Motivated', 'Productive', 'Neglecting', 'NeglectAware', 'Dysphoric', 'Correlate', 'Flag', 'Changes', 'Note', 'Context', 'Associate', 'Plan', 'Review', 'Hindsight', 'Food', 'Drink', 'Sleep', 'LastRow', 'LastDose', 'LastHit', 'Single', 'Multiple', 'DrugAdded', 'NothingAdded', 'UsingRemains', 'LeftRemains', 'LotsUsable', 'Weighed', 'Eyeballed', 'Guessed', 'Estimate', 'Scales', 'HardToSee', 'LightRoom', 'DarkRoom'],
    dark: [ 'Observe', 'Follow', 'Adaptive', 'Rock', 'Fast', 'Slowly', 'Roll', 'Rapid', 'Spin', 'SideToSide', 'CoatBowl', 'LargeRoll', 'SmallRoll', 'ManyHits', 'OneHit', 'MeltFirst', 'Burned', 'SuddenDrop'],
    blue: ['Plumes', 'Billowing', 'Vapour', 'Visible', 'Invisible', 'LotsOfVapour', 'SoftVapour', 'ThickVapour', 'WarmAir', 'BackPressure', 'Smoke', 'HalfBurned', 'NiceSmell', 'NiceTaste', 'Irritant', 'Pressure', 'Ignition', 'BurnedSmell', 'DarkVapour'],
    red: ['EarsRinging', 'ChestPain', 'SideEffects', 'WideEyes', 'Headache', 'Heartbeat', 'HeartPounding', 'BloodPressure', 'TempIncrease', 'TempDecrease', 'Visceral', 'Feel',  'Chills', 'Sweat', 'Tremor', 'Shakes', 'Nausea', 'AfterEffects', 'DayAfter', 'Hangover', 'JustWoke', 'MorningAfter'],
    green: [ '555Hold', 'DeepBreath', 'ShallowBreath', 'Diaphragm', 'HoldBreath', 'MultipleBreath', 'Sucked', 'SuckedHard', 'Gentle', 'Aggressive', 'OneBreath', 'LipSeal', 'HalfSealed', 'NotSealed', 'MouthOpen', 'ThroatBreath', 'Irritant','SuctionDistance', 'HighHeat', 'LowHeat'],
    orange: [ 'Cone', 'Snowcone', 'Metal', 'Glass', 'Pipe', 'Oral', 'Sublingual', 'Lighter', 'Jet', 'Blowtorch', 'Broken', 'Clean', 'New', 'Dirty', 'Rinsed', 'Scraped', 'Dried', 'Wet', 'Dry', 'Weathered', 'Soaked', 'Damp', 'WasWet', 'HasDried', 'Loose', 'Moving', 'NotMoving', 'Runny', 'Chunk', 'Paste', 'Rock', 'Sludge', 'Crushed', 'NotCrushed', 'Powder', 'Granules', 'Crystal', 'Crystalline', 'Dust', 'Liquid', 'WaterWeighted', 'PropyleneGlycol', 'Water','VapourWait', 'VapourPool', 'PowderIgnites'],
    yellow: ['Positive', 'Negative', 'Colour', 'State', 'StateChange', 'Melt', 'Burn', 'Audible','Neither', 'Flat', 'Unknown', 'Melted', 'Burned', 'Carbon', 'Thin', 'Film', 'Fun', 'Analytics', 'Comparative', 'Relative', 'Absolute', 'Observe'],
    purple: ['Male', 'Female', 'Others', 'Home', 'Alone', 'Downstairs', 'Upstairs', 'RoomAlone', 'NotAlone', 'Thirsty', 'Hungry', 'HungerPains', 'AlreadyHadSome', 'Weed', 'Tobacco', 'Spin', 'Mix', 'Edible', 'MusicUrge', 'MusicOn', 'MusicOff', 'NotEating', 'NotDrinking', 'Neglecting', 'AwareOfChoices', 'BadChoices', '2MMC', '3MMC','4MMC', 'Meth', 'Cocaine', 'Crack', 'MDPIHP', '2MEPIHP', 'Claimed', 'NoAlcohol', 'Alcohol', 'AlcoholAffected', 'Drunk', 'Stoned', 'BR1', 'BR2', 'BR3']
  }
});
// ===== End CONFIG =====



// === UI Column Visibility & Shading Config ===
const HIDE_IN_UI = CONFIG.ui.hideInUi;
const NO_SHADE = new Set(CONFIG.ui.noShadeCols);

// Shading caps (max value that maps to full opacity)
const SHADE_CAP = CONFIG.ui.shadeCap;

const GREEN_SET = new Set(CONFIG.ui.colorSets.green);
const GOLD_SET  = new Set(CONFIG.ui.colorSets.gold);
const RED_SET   = new Set(CONFIG.ui.colorSets.red);
const BLUE_SET  = new Set(CONFIG.ui.colorSets.blue || []);
const GREY_SET  = new Set(CONFIG.ui.colorSets.grey || []);

function applyUiColumnVisibility() {
  const id = 'uiHideCols';
  if (document.getElementById(id)) return;
  const style = document.createElement('style');
  style.id = id;
  style.textContent = HIDE_IN_UI
    .map(c => `th[data-col="${c}"], td[data-col="${c}"]{display:none !important;}`)
    .join('');
  document.head.appendChild(style);

  // Ensure no background on no-shade set
  const id2 = 'noShadeOverride';
  if (!document.getElementById(id2)) {
    const s = document.createElement('style');
    s.id = id2;
    s.textContent = `
      `;
    document.head.appendChild(s);
  }
}

// Map each cell to its column name using the header texts
function tagRowCells(tr) {
  const header = document.querySelectorAll('#logTable thead th');
  Array.from(tr.children).forEach((td, idx) => {
    const name = header[idx] ? header[idx].textContent.trim() : '';
    if (name) td.setAttribute('data-col', name);
  });
}

function cellBgFor(colName, value) {
  if (NO_SHADE.has(colName)) return '';
  const num = Number(value);
  if (!Number.isFinite(num)) return '';
  const cap = (SHADE_CAP[colName] !== undefined) ? SHADE_CAP[colName] : 6;
  const opacity = Math.min(Math.max(num, 0), cap) / cap;
  if (GREEN_SET.has(colName)) return `rgba(0,255,0,${opacity})`;
  if (GOLD_SET.has(colName))  return `rgba(255,215,0,${opacity})`;
  if (RED_SET.has(colName))   return `rgba(255,0,0,${opacity})`;
  if (BLUE_SET.has(colName))  return `rgba(0,0,255,${opacity})`;
  if (GREY_SET.has(colName))  return `rgba(128,128,128,${opacity})`;
  return '';
}

function applyRowShading(tr) {
  Array.from(tr.children).forEach(td => {
    const col = td.getAttribute('data-col') || '';
    // Prefer numeric machine value for shading so label columns match their paired sums
    const raw = td.getAttribute('data-value');
    const val = (raw != null && raw !== '') ? raw : td.textContent.trim();
    const bg = cellBgFor(col, val);
    if (bg) td.style.backgroundColor = bg;
    else td.style.background = '';
  });
}
// BOOKMARK LABELS
const labelMappings = CONFIG.labels.labelMappings;
const RAPID_LABELS = CONFIG.labels.rapidLabels;
['a'].forEach(metric=>{labelMappings[metric]={};for(let v=-3;v<=10;v++)labelMappings[metric][v]=v.toString();});


// === Metric-specific label overrides (scores 6,,2,1,0) ===
const BUTTON_LABELS_BY_METRIC = CONFIG.labels.buttonLabelsByMetric;
function getMetricLabel(metric, v){
  const num = Number(v);
  if (Number.isFinite(num) && num === -0.25) return '';
  if (Number.isFinite(num) && num === 0.25) return '+';
  if (Number.isFinite(num) && num === -0.50) return '-';
  if (Number.isFinite(num) && num === -1.00) return '-';
  if (Number.isFinite(num) && num === -44.75) return '';
//   5.99,3.99,2.66,1.66,0.33

  try{
    const num = Number(v);
    if (Number.isFinite(num)){
      const per = (typeof BUTTON_LABELS_BY_METRIC!=='undefined') ? BUTTON_LABELS_BY_METRIC[metric] : null;
      if (per && Object.prototype.hasOwnProperty.call(per, num)) return per[num];
    }
  }catch(e){}
  try{
    if (typeof labelMappings!=='undefined' && labelMappings[metric] && labelMappings[metric][String(v)] != null){
      return labelMappings[metric][String(v)];
    }
  }catch(e){}
  try{
    if (typeof RAPID_LABELS!=='undefined' && RAPID_LABELS[metric] && RAPID_LABELS[metric][String(v)] != null){
      return RAPID_LABELS[metric][String(v)];
    }
  }catch(e){}
  return '';
}

function getLabels(metric, values) {
    if (!Array.isArray(values)) values = [values];
    return Array.from(new Set(values))
      .sort((a, b) => b - a)
      .map(v => getMetricLabel(metric, v))
      .filter(Boolean);
}


    
function getSum(arr) {
        if (Array.isArray(arr) && arr.length) {
            let s = arr.reduce((a,b)=>a+b,0);
            if (Array.isArray(arr) && arr.length === 2 && CONFIG.dualSelectionAdjust && CONFIG.dualSelectionAdjust.enabled){
                s = s - (CONFIG.dualSelectionAdjust.delta || 0.5);
            }
            return s;
        }
        return 0;
    }


    function fmt2(x){ const n = Number.parseFloat(x); return Number.isFinite(n) ? n.toFixed(2) : (x ?? ""); }

    // ─────────────────────────────────────────────────────────────────────────────
    // Per-metric button ordering/sets (independent for each metric)
    // 12 buttons per metric by default; override any metric at runtime via localStorage.
//     const DEFAULT_BUTTONS_12 = [8,7,6,'----------,6,5,4,3.5,3,2.5,2,1.5,1,0.5,0.75,0.25,04,'----------,3.5,3,2.5,'----------,2,1.5,1,'----------,0.75,0.5,0.25,0];
 //   const DEFAULT_BUTTONS_12 = [0.5,6,5,4,3,2,1,0.25,0];
    const PER_METRIC_BUTTONS = CONFIG.buttons.perMetricButtons;
    function getMetricButtons(metric){
      try {
        const overrides = JSON.parse(localStorage.getItem('metricButtonOrder') || '{}');
        if (overrides && Array.isArray(overrides[metric])) return overrides[metric];
      } catch(e){}
      return PER_METRIC_BUTTONS[metric] || [5,4,3,2,1,0];
    }
    function saveMetricButtons(metric, arr){
      const data = (()=>{ try { return JSON.parse(localStorage.getItem('metricButtonOrder')||'{}'); } catch(e){ return {}; } })();
      data[metric] = Array.isArray(arr) ? arr.slice() : [];
      localStorage.setItem('metricButtonOrder', JSON.stringify(data));
    }
    // ─────────────────────────────────────────────────────────────────────────────

    const metrics = CONFIG.core.metrics;
    let selections = {},
        logData = [],
        timerInterval,
        startTime,
        doseTime,
        editIndex = null;

    function initSelections() {
        metrics.forEach(m => selections[m] = []);
    }

    function buildButtons() {
	        // Score buttons
        const sc = document.getElementById('scoreColumns');
        sc.innerHTML = '';
        metrics.forEach(f => {
            const col = document.createElement('div');
            col.className = 'score-column';
            const t = document.createElement('strong');
            t.innerText = f.charAt(0).toUpperCase() + f.slice(1);
            col.appendChild(t);

           getMetricButtons(f).forEach(v => {

                const b = document.createElement('button');
b.classList.add('metric-btn');
                let customLabel = '';
// if (v === 7.02) customLabel = 'Ultra Extreme';
// if (v === -111) customLabel = '-';
if (v === -0.25) customLabel = '-';
if (v === -0.75) customLabel = '-';
if (v === -0.50) customLabel = '-';
if (v === -1.00) customLabel = '-';
// if (v === 0.5) customLabel = '+';
if (v === 0.25) customLabel = '+';
if (v === 0.75) customLabel = '+';
if (v === 4.99) customLabel = 'Extreme';
//else if (v === 6) customLabel = 'Extra/Moderate';
else customLabel = getMetricLabel(f, v);
b.innerText = `${v}: ${customLabel}`;
                b.onclick = () => {
                    const i = selections[f].indexOf(v);
                    if (i < 0) {
                        selections[f].push(v);
                        b.classList.add('selected-score');
                    }
                    else {
                        selections[f].splice(i, 1);
                        b.classList.remove('selected-score');
                    }
                };
                col.appendChild(b);
            });
            sc.appendChild(col);

});

        // Original notes
        const noteCont = document.getElementById('noteButtons');
        noteCont.innerHTML = '';
        const palette = {
            CONTEXT: 'other',
            PRE: 'time',
            POST: 'time',
            ONSET: 'time',
            After: 'time',
            Before: 'time',
            Estimate: 'time',
            RUSH: 'effect',
            Good: 'positive',
            Bad: 'negative',
            Anxiety: 'emotional',
            Craving: 'emotional',
            Joy: 'positive',
            Physical: 'physical',
            Visual: 'effect',
            Audio: 'effect',
            Cognitive: 'mental',
            Social: 'effect',
            Paranoia: 'emotional',
            Peaceful: 'positive',
            Insight: 'mental',
            Sleep: 'other',
            Alert: 'effect',
            Fatigue: 'physical',
            Euphoria: 'positive',
            Pain: 'physical',
            Discomfort: 'physical',
            Calm: 'positive',
            Tension: 'emotional',
            Fun: 'positive',
            Confusion: 'mental'
        };
        (function(){const h=document.createElement("h4");h.textContent="Gold";document.getElementById("extraNoteButtons").appendChild(h);})();
// Extra notes (gold)
        const extraCont = document.getElementById('extraNoteButtons');
        extraCont.innerHTML = '';
        const extra = CONFIG.notes.extra;
        extra.forEach(lbl => {
            const b = document.createElement('button');
b.classList.add('metric-btn');
            b.className = 'note-btn';
            b.innerText = lbl;
            b.setAttribute('data-category', 'gold');
            b.onclick = () => {
                const ta = document.getElementById('notesInput');
                const toks = ta.value.split(/\s+/).filter(Boolean);
                const i = toks.indexOf(lbl);
                if (i >= 0) {
                    toks.splice(i, 1);
                    b.classList.remove('selected-score');
                }
                else {
                    toks.push(lbl);
                    b.classList.add('selected-score');
                }
                ta.value = toks.join(' ');
            };
            extraCont.appendChild(b);
        });

        (function(){const h=document.createElement("h4");h.textContent="Dose";document.getElementById("extraNoteButtons").appendChild(h);})();
// Dark grey dose buttons
        const darkLabels = CONFIG.notes.dark;
        darkLabels.forEach(lbl => {
            const b = document.createElement('button');
b.classList.add('metric-btn');
            b.className = 'note-btn';
            b.innerText = lbl;
            b.setAttribute('data-category', 'dose');
            b.onclick = () => {
                const ta = document.getElementById('notesInput');
                const toks = ta.value.split(/\s+/).filter(Boolean);
                const i = toks.indexOf(lbl);
                if (i >= 0) {
                    toks.splice(i, 1);
                    b.classList.remove('selected-score');
                }
                else {
                    toks.push(lbl);
                    b.classList.add('selected-score');
                }
                ta.value = toks.join(' ');
            };
            extraCont.appendChild(b);
        });

        (function(){const h=document.createElement("h4");h.textContent="Blue";document.getElementById("extraNoteButtons").appendChild(h);})();
// Bright blue custom buttons
        const blueLabels = CONFIG.notes.blue;
        blueLabels.forEach(lbl => {
            const b = document.createElement('button');
b.classList.add('metric-btn');
            b.className = 'note-btn';
            b.innerText = lbl;
            b.setAttribute('data-category', 'blue');
            b.onclick = () => {
                const ta = document.getElementById('notesInput');
                const toks = ta.value.split(/\s+/).filter(Boolean);
                const i = toks.indexOf(lbl);
                if (i >= 0) {
                    toks.splice(i, 1);
                    b.classList.remove('selected-score');
                } else {
                    toks.push(lbl);
                    b.classList.add('selected-score');
                }
                ta.value = toks.join(' ');
            };
            extraCont.appendChild(b);
        });

        (function(){const h=document.createElement("h4");h.textContent="Red";document.getElementById("extraNoteButtons").appendChild(h);})();
// Bright red custom buttons
        const redLabels = CONFIG.notes.red;
        redLabels.forEach(lbl => {
            const b = document.createElement('button');
b.classList.add('metric-btn');
            b.className = 'note-btn';
            b.innerText = lbl;
            b.setAttribute('data-category', 'red');
            b.onclick = () => {
                const ta = document.getElementById('notesInput');
                const toks = ta.value.split(/\s+/).filter(Boolean);
                const i = toks.indexOf(lbl);
                if (i >= 0) {
                    toks.splice(i, 1);
                    b.classList.remove('selected-score');
                } else {
                    toks.push(lbl);
                    b.classList.add('selected-score');
                }
                ta.value = toks.join(' ');
            };
            extraCont.appendChild(b);
        });
        (function(){const h=document.createElement("h4");h.textContent="Green";document.getElementById("extraNoteButtons").appendChild(h);})();
const greenLabels = CONFIG.notes.green;
        greenLabels.forEach(lbl => {
            const b = document.createElement('button');
b.classList.add('metric-btn');
            b.className = 'note-btn';
            b.innerText = lbl;
            b.setAttribute('data-category', 'green');
            b.onclick = () => {
                const ta = document.getElementById('notesInput');
                const toks = ta.value.split(/\s+/).filter(Boolean);
                const i = toks.indexOf(lbl);
                if (i >= 0) {
                    toks.splice(i, 1);
                    b.classList.remove('selected-score');
                } else {
                    toks.push(lbl);
                    b.classList.add('selected-score');
                }
                ta.value = toks.join(' ');
            };
            extraCont.appendChild(b);
        });
        (function(){const h=document.createElement("h4");h.textContent="Orange";document.getElementById("extraNoteButtons").appendChild(h);})();
const orangeLabels = CONFIG.notes.orange;
        orangeLabels.forEach(lbl => {
            const b = document.createElement('button');
b.classList.add('metric-btn');
            b.className = 'note-btn';
            b.innerText = lbl;
            b.setAttribute('data-category', 'orange');
            b.onclick = () => {
                const ta = document.getElementById('notesInput');
                const toks = ta.value.split(/\s+/).filter(Boolean);
                const i = toks.indexOf(lbl);
                if (i >= 0) {
                    toks.splice(i, 1);
                    b.classList.remove('selected-score');
                } else {
                    toks.push(lbl);
                    b.classList.add('selected-score');
                }
                ta.value = toks.join(' ');
            };
            extraCont.appendChild(b);
        });
        (function(){const h=document.createElement("h4");h.textContent="Yellow";document.getElementById("extraNoteButtons").appendChild(h);})();
const yellowLabels = CONFIG.notes.yellow;
// Purple category labels
yellowLabels.forEach(lbl => {
            const b = document.createElement('button');
b.classList.add('metric-btn');
            b.className = 'note-btn';
            b.textContent = lbl;
            b.setAttribute('data-category', 'yellow');
            b.onclick = () => {
                const ta = document.getElementById('notesInput');
                const toks = ta.value.split(/\s+/).filter(Boolean);
                const i = toks.indexOf(lbl);
                if (i >= 0) {
                    toks.splice(i, 1);
                    b.classList.remove('selected-score');
                } else {
                    toks.push(lbl);
                    b.classList.add('selected-score');
                }
                ta.value = toks.join(' ');
            };
            extraCont.appendChild(b);
        });



    // ─── APPEND PURPLE LABELS ───────────────────────────────────────────────
    (function(){const h=document.createElement("h4");h.textContent="Purple";document.getElementById("extraNoteButtons").appendChild(h);})();
const purpleLabels = CONFIG.notes.purple;
    const purpleContainer = document.querySelector('#extraNoteButtons');
    purpleLabels.forEach(label => {
      const btn = document.createElement('button');
btn.classList.add('metric-btn');
      btn.type = 'button';
      btn.textContent = label;
      btn.dataset.category = 'purple';
      btn.classList.add('note-btn');
      btn.addEventListener('click', () => {
        const notes = document.querySelector('#notesInput');
        const toks = notes.value.split(/\s+/).filter(Boolean);
        const i = toks.indexOf(label);
        if (i >= 0) { toks.splice(i, 1); } else { toks.push(label); }
        notes.value = toks.join(' ');
      });
      purpleContainer.appendChild(btn);
    });
    // ──────────────────────────────────────────────────────────────────────────
    }

    function resetTimer() {
        startTime = doseTime = new Date();
        clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            document.getElementById('timer').innerText = 'Trip Time: ' + getElapsed(startTime);
        }, 1000);
    }
    function pauseTimer() {
        clearInterval(timerInterval);
    }
    function newTrip() {
        logData = [];
        localStorage.removeItem('tripLog');
        renderTable();
        clearInterval(timerInterval);
        document.getElementById('timer').innerText = 'Time: 00:00:00';
        startTime = doseTime = null;
    }
    function getElapsed(start) {
        if (!start)
            return "00:00:00";
        let d = Math.floor((new Date() - start) / 1000),
            h = String(Math.floor(d / 3600)).padStart(2, '0'),
            m = String(Math.floor((d % 3600) / 60)).padStart(2, '0'),
            s = String(d % 60).padStart(2, '0');
        return `${h}:${m}:${s}`;
    }
    function addEntry(labelSource = 'main') {
if (!startTime)
            resetTimer();
        // [disabled duplicate summary timer]

        const now = new Date(),
            ts = now.toLocaleString('en-AU', {
                hour12: false
            });
        if (document.getElementById('redoseCheckbox').checked && document.getElementById('drugSelect').value)
            doseTime = new Date();
        const entry = {
   			 _ts: Date.now(),
   			 timestamp: ts,
            sincedose: getElapsed(doseTime),
            elapsed: getElapsed(startTime),
            info: document.getElementById('eventInput').value,
            scale: document.getElementById('scaleInput').value,
            drug: document.getElementById('drugSelect').value,
            qty: document.getElementById('qtyInput').value,
            roa: document.getElementById('roaInput').value,
            notes: document.getElementById('notesInput').value,
            customNotes: document.getElementById('customNotesInput').value
        };
        metrics.forEach(f => {
            entry[f] = selections[f].length
              ? Array.from(new Set(selections[f])).sort((a, b) => b - a)
              : [];
            const resolveLabel = (metric, v) => (
              labelSource === 'rapid'
                ? ((typeof RAPID_LABELS !== 'undefined' && RAPID_LABELS[metric] && RAPID_LABELS[metric][String(v)] != null)
                    ? RAPID_LABELS[metric][String(v)] : String(v))
                : ((typeof labelMappings !== 'undefined' && labelMappings[metric] && labelMappings[metric][String(v)] != null)
                    ? labelMappings[metric][String(v)] : String(v))
            );
            entry[f + 'Label'] = entry[f].map(v => resolveLabel(f, v)).join(', ');
            entry[f + 'Sum'] = (typeof ZERO_SCORE_METRICS !== 'undefined' && ZERO_SCORE_METRICS.has(f)) ? 0 : getSum(entry[f]);

        });
        entry.score = entry.rushSum + entry.moodSum + entry.socialSum + entry.energySum + entry.focusSum - entry.anxietySum - entry.impairSum;
        entry.max = ['rush', 'mood', 'social', 'energy', 'focus'].reduce((a, f) => a + (entry[f + 'Sum'] || 0), 0);
        entry.min = entry.anxietySum + entry.impairSum;
        entry.maxPercent = +(entry.max / 50 * 100).toFixed(1);
        entry.minPercent = +(entry.min / 20 * 100).toFixed(1);
        entry.min = entry.anxietySum + entry.impairSum;
        let val = 0;
        ['rush', 'mood', 'social', 'energy', 'focus'].forEach(m => entry[m].some(v => v >= 3) && val++);
        ['anxiety', 'impair'].forEach(m => entry[m].some(v => v >= 3) && val--);
        entry.valence = val;
        entry.scaleMood = entry.notes.split(/\s+/).includes('Good') ? 3 : 0;
        entry.scaleBad = entry.notes.split(/\s+/).includes('Bad') ? 3 : 0;
        entry.scaleFocus = window.computeScaleFocusFromNotes(entry && entry.notes);
        entry.scaleFocus = window.computeScaleFocusFromNotes(entry && entry.notes);
        entry.scaleFocus = window.computeScaleFocusFromNotes(entry && entry.notes);
        entry.scaleFocus = window.computeScaleFocusFromNotes(entry && entry.notes);
entry.weighted = computeWeighted({ rush: entry.rushSum, mood: entry.moodSum, social: entry.socialSum, energy: entry.energySum, focus: entry.focusSum, anxiety: entry.anxietySum, impair: entry.impairSum });
    entry.fiveMax = computeFiveMax({ rush: entry.rushSum, mood: entry.moodSum, social: entry.socialSum, energy: entry.energySum, focus: entry.focusSum, anxiety: entry.anxietySum, impair: entry.impairSum });
entry.fiveMax = computeFiveMax({rush: entry.rushSum, mood: entry.moodSum, social: entry.socialSum, energy: entry.energySum, focus: entry.focusSum, anxiety: entry.anxietySum, impair: entry.impairSum});
entry.goodSum = 0;
        logData.push(entry);
        setTripLogDebounced(logData);
        renderTable();
        ['eventInput', 'scaleInput', 'drugSelect', 'qtyInput', 'roaInput', 'notesInput', 'customNotesInput'].forEach(id => document.getElementById(id).value = '');
        initSelections();

// Custom metric button labels (final, no backups; replaces any prior label mappings)
(function(){
  // Replace mapping in-place
  window.BUTTON_LABELS_BY_METRIC = {
  }
  try { } catch(e) {}
})();
buildButtons();
        document.getElementById('addBtn').innerText = 'Add Entry';

}

function renderTable() {
        const tb = document.querySelector('#logTable tbody');
        tb.innerHTML = '';
        logData.forEach((r, i) => {
            const tr = document.createElement('tr');
            let h = `<td><input type="checkbox" name="rowSelect" data-index="${i}"></td>`;
            ['timestamp','sincedose','elapsed'].forEach(k => h += `<td>${r[k]||''}</td>`);
            ;['info','scale','drug','qty','roa'].forEach(k => h += `<td>${__esc(r[k]||'')}</td>`);
            metrics.forEach(f => {
                h += `<td data-field="${f}Sum" data-value="${r[f + 'Sum']}">${fmt2(r[f + 'Sum'])}</td>`;
                h += `<td data-label-for="${f}Sum" data-value="${r[f + 'Sum']}">${r[f + 'Label']}</td>`;
            });
        h += `<td data-col="Score" class="score-cell">${fmt2(r.score)}</td>` +
     `<td data-col="Max" class="max-cell">${fmt2(r.max || 0)}</td>` +
     `<td data-col="Min" class="min-cell">${fmt2(r.min || 0)}</td>` +
     `<td data-col="VL">${fmt2(r.valence)}</td>` +
     `<td data-col="sM">${fmt2(r.scaleMood || 0)}</td>` +
     `<td data-col="sB">${fmt2(r.scaleBad || 0)}</td>` +
     `<td data-col="sF">${fmt2(r.scaleFocus || 0)}</td>` +
     `<td data-col="Last">${__esc(r.customNotes || "")}</td>` +
     `<td data-col="Notes">${__esc(r.notes || "")}</td>` +
     `<td data-col="Weighted">${fmt2(r.weighted || 0)}</td>` +
     `<td data-col="5Max">${(r.fiveMax!=null? Number(r.fiveMax).toFixed(2): '')}</td>` +
     `<td data-col="GS">${fmt2(r.goodSum || 0)}</td>`;

            tr.innerHTML = h;
            tr.setAttribute('data-ts', String(r._ts || 0));
            tagRowCells(tr);
            // Set tooltip percentages for Max/Min without affecting shading text
            (function(){
              const maxCell = tr.querySelector('td[data-col="Max"]');
              if (maxCell && r.maxPercent != null) maxCell.title = String(r.maxPercent) + '%';
              const minCell = tr.querySelector('td[data-col="Min"]');
              if (minCell && r.minPercent != null) minCell.title = String(r.minPercent) + '%';
            })();
            applyRowShading(tr);
            applyUiColumnVisibility();
            tb.appendChild(tr);
        });
    }
    function deleteSelected() {
        const toDel = Array.from(document.querySelectorAll('input[name="rowSelect"]:checked')).map(cb => +cb.dataset.index);
        logData = logData.filter((_, i) => !toDel.includes(i));
        setTripLogDebounced(logData);
        renderTable();
    }
    function editSelected() {
        const sel = document.querySelector('input[name="rowSelect"]:checked');
        if (!sel)
            return alert('Select one row');
        editIndex = +sel.dataset.index;
        const r = logData[editIndex];
        document.getElementById('eventInput').value = r.info;
        document.getElementById('scaleInput').value = r.scale;
        document.getElementById('drugSelect').value = r.drug;
        document.getElementById('qtyInput').value = r.qty;
        document.getElementById('roaInput').value = r.roa;
        document.getElementById('notesInput').value = r.notes;
        document.getElementById('customNotesInput').value = r.customNotes;
        document.getElementById('addBtn').innerText = 'Save Changes';
        initSelections();
        buildButtons();
        metrics.forEach((f, idx) => r[f].forEach(v => {
            const btn = document.querySelectorAll('.score-column')[idx].querySelector(`button:nth-child(${8 - v})`);
            btn && btn.classList.add('selected-score');
        }));
    }
    function exportCSV() {
        const h = ["Timestamp","Since Dose","Elapsed","Info","Scale","Drug","Qty","ROA"];
        metrics.forEach(f => h.push(f.charAt(0).toUpperCase()+f.slice(1)+" Sum", f.charAt(0).toUpperCase()+f.slice(1)+" Label"));
        h.push("Score","Max","Min","Max %","Min %","Valence","scaleMood","scaleBad","scaleFocus","Custom Notes","Notes","Weighted","Score5","Good Sum");
        const rows = [h.join(",")];
        logData.forEach(r => {
            const L = [r.timestamp, r.sincedose, r.elapsed, r.info, r.scale, r.drug, r.qty, r.roa];
            metrics.forEach(f => L.push((+r[f + "Sum"]||0).toFixed(2), r[f + "Label"]));
            L.push((+r.score||0).toFixed(2), (+r.max||0).toFixed(2), (+r.min||0).toFixed(2), r.maxPercent || 0, r.minPercent || 0, (+r.valence||0).toFixed(2), (+r.scaleMood||0).toFixed(2), (+r.scaleBad||0).toFixed(2), (+r.scaleFocus||0).toFixed(2), r.customNotes || '', r.notes || '', (+r.weighted || 0).toFixed(2), (+r.fiveMax || 0).toFixed(2), (+r.goodSum||0).toFixed(2));
            rows.push(L.map(x => `"${(x + "").replace(/"/g, '""')}"`).join(","))
        });
        const blob = new Blob([rows.join("\n")], {
                type: "text/csv"
            }),
            url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "log.csv";
        a.click();
        URL.revokeObjectURL(url);
    }
    // Manual Score Entry Modal functions
    function openScoreModal() {
        document.getElementById('scoreModal').style.display = 'block';
    }
    function closeScoreModal() {
        document.getElementById('scoreModal').style.display = 'none';
        document.querySelectorAll('#scoreModal input').forEach(inp => inp.value = '');
    }
    function applyManualScores() {
        const fields = ['rush', 'mood', 'social', 'energy', 'focus', 'anxiety', 'impair'];
        fields.forEach(f => {
            const val = parseInt(document.getElementById('manual' + f.charAt(0).toUpperCase() + f.slice(1)).value, 10);
            if (!isNaN(val) && val >= 0 && val <= 10) {
                if (!selections[f])
                    selections[f] = [];
                if (!selections[f].includes(val))
                    selections[f].push(val);
            }
        });
        buildButtons();
        closeScoreModal();
    }
    window.onload = () => {
        initSelections();
        buildButtons();
        try {
            logData = JSON.parse(localStorage.getItem("tripLog")) || [];
        } catch {}
        renderTable();
    };

// === Open Existing Log (CSV) ===
// Paranoid-safe: local File API only. No network.

function openExistingLog(){
  // Confirm if table has data
  try{
    const hasRows = Array.isArray(logData) && logData.length > 0;
    if (hasRows && !confirm("Append imported file to the current log? (OK = append, Cancel = abort)")) return;
  }catch(e){}
  const inp = document.getElementById('openLogInput');
  if (!inp) return alert("File input missing.");
  inp.value = "";
  inp.onchange = handleFileSelected;
  inp.click();
}

function handleFileSelected(ev){
  const file = ev.target.files && ev.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const text = String(reader.result || "");
      const parsed = parseCSV(text);
      if (!parsed || !parsed.header || !parsed.rows || parsed.rows.length === 0){
        alert("CSV appears empty.");
        return;
      }
      const map = mapSchema(parsed.header);
      if (!map.valid){
        alert("Unsupported CSV: export from this app required.\nMissing: " + map.missing.join(", "));
        return;
      }
      const imported = rowsToLogData(parsed.rows, map);
      if (!imported.length){
        alert("No rows could be imported.");
        return;
      }
      // Append + Dedupe + Sort + Persist
logData = mergeAppendDedupeSort(logData, imported);
try { setTripLogDebounced(logData); } catch(e){}
renderTable();
// If auto summary is active, clear and emit an immediate row
      try {
        const tbody = document.querySelector('#autoSummaryTable tbody'); if (tbody) tbody.innerHTML='';
        if (window.autoSummaryActive){
          const endMs = Date.now();
          const M = computeRollingMeans(endMs, SUMMARY_WINDOW_MINUTES);
          const C = M ? computeCompositeFromMeans(M) : null;
          const d = new Date();
          if (M) appendSummaryRowToTable('autoSummaryTable', d, M, C, {labelSuffix: ' 5m Now'});
        }
      } catch(e){ console.warn(e); }
      // Status line
      showStatus(`Loaded ${imported.length} rows from ${file.name}`);
    } catch(err){
      console.error(err);
      alert("Failed to import CSV: " + err.message);
    }
  };
  reader.onerror = () => alert("Failed to read file.");
  reader.readAsText(file);
}

// Mminimal RFC4180 CSV parser (handles quotes and escaped quotes)
function parseCSV(text){
  const lines = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
  const rows = [];
  for (let i=0;i<lines.length;i++){
    const line = lines[i];
    if (line === "") continue;
    rows.push(parseCSVLine(line));
  }
  if (!rows.length) return {header:[], rows:[]};
  const header = rows.shift();
  return {header, rows};
}
function parseCSVLine(line){
  const out = [];
  let cur = "";
  let inQ = false;
  for (let i=0;i<line.length;i++){
    const ch = line[i];
    if (inQ){
      if (ch === '"'){
        if (i+1 < line.length && line[i+1] === '"'){ cur += '"'; i++; }
        else { inQ = false; }
      } else {
        cur += ch;
      }
    } else {
      if (ch === '"'){ inQ = true; }
      else if (ch === ','){ out.push(cur); cur = ""; }
      else { cur += ch; }
    }
  }
  out.push(cur);
  return out;
}

// Case-insensitive header lookup
function findHeader(header, names){
  const idx = header.findIndex(h => names.some(n => (h||"").trim().toLowerCase() === n.trim().toLowerCase()));
  return idx >= 0 ? idx : -1;
}

// Schema mapping for app-exported CSV
function mapSchema(header){
  const need = {
    ts: ["Timestamp"],
    since: ["Since Dose","Since"],
    elapsed: ["Elapsed"],
    info: ["Info"],
    scale: ["Scale"],
    drug: ["Drug"],
    qty: ["Qty","QTY"],
    roa: ["ROA","Detail"],
    score: ["Score"],
    max: ["Max"],
    min: ["Min"],
    maxp: ["Max %","Max%","Max Percent"],
    minp: ["Min %","Min%","Min Percent"],
    valence: ["Valence","VL"],
    sM: ["scaleMood","sM"],
    sB: ["scaleBad","sB"],
    sF: ["scaleFocus","sF"],
    last: ["Custom Notes","Last"],
    notes: ["Notes"],
    weighted: ["Weighted"],
    score5: ["Score5","5Max"],
    goodSum: ["Good Sum","GS"],
    rushSum: ["Rush Sum"],
    rushLabel: ["Rush Label"],
    moodSum: ["Mood Sum"],
    moodLabel: ["Mood Label"],
    socialSum: ["Social Sum"],
    socialLabel: ["Social Label"],
    energySum: ["Energy Sum"],
    energyLabel: ["Energy Label"],
    focusSum: ["Focus Sum"],
    focusLabel: ["Focus Label"],
    anxietySum: ["Anxiety Sum"],
    anxietyLabel: ["Anxiety Label"],
    impairSum: ["Impair Sum"],
    impairLabel: ["Impair Label"]
  };
  const map = {};
  const missing = [];
  Object.keys(need).forEach(k => {
    const idx = findHeader(header, need[k]);
    if (idx === -1) missing.push(need[k][0]);
    map[k] = idx;
  });
  // Only hard-require the columns that this app always exports
  const hard = ["ts","since","elapsed","info","scale","drug","qty","roa","score","max","min","last","notes","weighted","score5"];
  const valid = hard.every(k => map[k] !== -1);
  return {map, missing, valid, header};
}

// Parse AU datetime like "13/08/2025, 16:57:12" or "13/08/2025 16:57:12"
function parseAUDatetime(s){
  if (!s) return null;
  const m = String(s).match(/^\s*(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})[,\s]+(\d{1,2}):(\d{2}):(\d{2})\s*$/);
  if (!m) return null;
  const [_, d, mo, y, h, mi, se] = m.map(x => parseInt(x,10));
  const dt = new Date(y, mo-1, d, h, mi, se); // treated as local
  return dt.getTime();
}

// Build internal rows from CSV rows
function rowsToLogData(rows, mapped){
  const H = mapped.map;
  const out = [];
  for (const r of rows){
    const val = (idx) => (idx>=0 && idx<r.length) ? r[idx] : "";
    const entry = {
      _ts: parseAUDatetime(val(H.ts)) || Date.now(),
      timestamp: val(H.ts),
      sincedose: val(H.since),
      elapsed: val(H.elapsed),
      info: val(H.info),
      scale: val(H.scale),
      drug: val(H.drug),
      qty: val(H.qty),
      roa: val(H.roa),
      notes: val(H.notes),
      customNotes: val(H.last)
    };
    // metric sums + labels
    const metricPairs = [
      ["rush","rushSum","rushLabel"],
      ["mood","moodSum","moodLabel"],
      ["social","socialSum","socialLabel"],
      ["energy","energySum","energyLabel"],
      ["focus","focusSum","focusLabel"],
      ["anxiety","anxietySum","anxietyLabel"],
      ["impair","impairSum","impairLabel"],
    ];
    metricPairs.forEach(([name, sumKey, labelKey])=>{
      const sumIdx = H[sumKey], labIdx = H[labelKey];
      const sum = parseFloat(val(sumIdx)) || 0;
      entry[name] = []; // original discrete selections not preserved in CSV
      entry[name + "Sum"] = sum;
      entry[name + "Label"] = val(labIdx) || "";
    });
    // Derived / composites (recompute)
    entry.score = (+entry.rushSum + +entry.moodSum + +entry.socialSum + +entry.energySum + +entry.focusSum) - (+entry.anxietySum + +entry.impairSum);
    entry.max = (+entry.rushSum + +entry.moodSum + +entry.socialSum + +entry.energySum + +entry.focusSum);
    entry.min = (+entry.anxietySum + +entry.impairSum);
    entry.maxPercent = Math.round((entry.max / 50) * 1000)/10;
    entry.minPercent = Math.round((entry.min / 20) * 1000)/10;
    entry.valence = 0; // cannot safely reconstruct; leave 0
    entry.scaleMood = 0;
    entry.scaleBad = 0;
    entry.scaleFocus = window.computeScaleFocusFromNotes(entry && entry.notes);
    entry.weighted = computeWeighted({ rush: entry.rushSum, mood: entry.moodSum, social: entry.socialSum, energy: entry.energySum, focus: entry.focusSum, anxiety: entry.anxietySum, impair: entry.impairSum });
    entry.fiveMax = ((+entry.rushSum + +entry.moodSum + +entry.socialSum + +entry.energySum + +entry.focusSum - (+entry.anxietySum) - (+entry.impairSum)) / 5) + 5;
    entry.goodSum = 0;
    out.push(entry);
  }
  return out;
}


// Merge + Dedupe + Sort helper (append-only import)
function mergeAppendDedupeSort(existing, incoming){
  const left  = Array.isArray(existing) ? existing : [];
  const right = Array.isArray(incoming) ? incoming : [];

  // Drop blank/empty rows from the right side before merging
  const filteredRight = right.filter(isNonEmptyLogRow);
  const all = left.concat(filteredRight);

  const seen = new Set();
  const out = [];
  for (const r of all){
    const key = JSON.stringify([
      r.timestamp, r.sincedose, r.elapsed, r.info, r.scale, r.drug, r.qty, r.roa,
      r.notes, r.customNotes,
      r.rushSum, r.moodSum, r.socialSum, r.energySum, r.focusSum, r.anxietySum, r.impairSum,
      r.score, r.max, r.min, r.weighted, r.maxPercent, r.minPercent
    ]);
    if (!seen.has(key)){ seen.add(key); out.push(r); }
  }
  out.sort((a,b)=> (a && a._ts ? a._ts : 0) - (b && b._ts ? b._ts : 0));
  return out;
}

// Helper: determine if a row (log entry) is effectively empty/blank (all key numbers 0/NaN/absent)
function isNonEmptyLogRow(r){
  if (!r) return false;

  // Keep explicit dose markers even if metrics are zero
  const doseToken = (s) => !!(s && /(hit|redose|dose|finished|md-?pihp|2me-?pihp|a-?pihp|3f-?pihp|a-?php|a-?pvp|cathinone|meth|mdma|2-?mmc|3-?mmc|4-?mmc|mephedrone|dust|speed|cocaine|crack|thc|weed|alcohol|benzodiazepine|diazepam|alprazolam|bromazolam|lsd)/i.test(String(s)));
  if ((r.drug && String(r.drug).trim() !== '') || doseToken(r.notes) || doseToken(r.info)) {
    return true;
  }

  const numericVals = [
    r.rushSum, r.moodSum, r.socialSum, r.energySum, r.focusSum,
    r.anxietySum, r.impairSum, r.score, r.max, r.min, r.weighted,
    r.maxPercent, r.minPercent
  ].map(v => Number(v));

  return numericVals.some(v => Number.isFinite(v) && v !== 0);
}

// Helper: determine if a summary payload (means + composites) has any non-zero signal
function isNonEmptySummary(M, C){
  if (!M || typeof M!=="object") return false;
  const mv = [M.rush, M.mood, M.social, M.energy, M.focus, M.anxiety, M.impair]
            .map(v=>Number(v));
  const hasMeans = mv.some(v => Number.isFinite(v) && v !== 0);
  const cv = C && typeof C==="object"
    ? [C.score, C.max, C.min, C.weighted, C.fiveMax].map(v=>Number(v))
    : [];
  const hasComp = cv.some(v => Number.isFinite(v) && v !== 0);
  return hasMeans || hasComp;
}

// Status line / toast
function showStatus(msg){
  let el = document.getElementById("statusLine");
  if (!el){
    el = document.createElement("div");
    el.id = "statusLine";
    Object.assign(el.style, {position:"fixed", top:"46px", right:"20px", background:"#007aff", color:"#fff", padding:"6px 10px", borderRadius:"6px", zIndex:"9999"});
    document.body.appendChild(el);
  }
  el.textContent = msg;
  clearTimeout(el._t);
  el._t = setTimeout(()=>{ el.remove(); }, 5000);
}

// BOOKMARK
// const RAPID_VALUES = CONFIG.buttons.rapidValues;
// const RAPID_VALUES = CONFIG.buttons.rapidValues;
const RAPID_VALUES = CONFIG.buttons.rapidValues;
// const RAPID_METRICS = CONFIG.buttons.rapidMetrics;
const RAPID_METRICS = CONFIG.buttons.rapidMetrics;
const ZERO_SCORE_METRICS = new Set(((CONFIG && CONFIG.buttons && CONFIG.buttons.zeroScoreMetrics) || []));


function buildRapidScoresButtons(){
  try {
    const container = document.getElementById('rapidScoresButtons');
    if (!container) return;
    container.innerHTML = '';
    RAPID_METRICS.forEach(metric => {
      const col = document.createElement('div');
      col.className = 'score-column';
      const t = document.createElement('strong');
      t.innerText = metric.charAt(0).toUpperCase() + metric.slice(1);
      col.appendChild(t);
      RAPID_VALUES.forEach(v => {
        const b = document.createElement('button');
b.classList.add('metric-btn');
        const label = (RAPID_LABELS[metric] && RAPID_LABELS[metric][v] != null) ? RAPID_LABELS[metric][v] : ((labelMappings[metric] && labelMappings[metric][v] != null) ? labelMappings[metric][v] : "");
        b.innerText = `${v}: ${label}`;
        b.onclick = () => {
          if (!Array.isArray(selections[metric])) selections[metric] = [];
          const idx = selections[metric].indexOf(v);
          if (idx < 0) {
            selections[metric].push(v);
            b.classList.add('selected-score');
          } else {
            selections[metric].splice(idx, 1);
            b.classList.remove('selected-score');
          }
        };
        // Preselect if already chosen
        try{
          if (Array.isArray(selections[metric]) && selections[metric].includes(v)) {
            b.classList.add('selected-score');
          }
        }catch(e){}
        col.appendChild(b);
      });
      container.appendChild(col);
    });
  } catch(e) { console.warn(e); }
}

function openRapidScores(){
  try {
    const m = document.getElementById('rapidScoresModal');
    if (!m) return;
    buildRapidScoresButtons();
    m.style.display = 'block';
  } catch(e){ console.warn(e); }
}
function closeRapidScores(){
  try {
    const m = document.getElementById('rapidScoresModal');
    if (!m) return;
    m.style.display = 'none';
  } catch(e){ console.warn(e); }
}

function applyRapidScores(){
  try {
    RAPID_METRICS.forEach(f => {
      if (!Array.isArray(selections[f])) selections[f] = [];
      selections[f] = Array.from(new Set(selections[f])).sort((a,b)=>b-a);
    });
    closeRapidScores();
    // Reflect in main button grid
    try { buildButtons(); } catch(e){}
  } catch(e){ console.warn(e); }
}


function applyRapidScoresAndAddStay(){
  try {
    // Ensure clean, deduped selections for rapid metrics
    RAPID_METRICS.forEach(f => {
      if (!Array.isArray(selections[f])) selections[f] = [];
      selections[f] = Array.from(new Set(selections[f])).sort((a,b)=>b-a);
    });
    // Add a single entry using 'rapid' labels and keep modal open
    addEntry('rapid');
    // Rebuild rapid popup buttons so UI reflects cleared selections
    try { buildRapidScoresButtons(); } catch(e){}
    // Ensure modal remains visible
    try {
      const m = document.getElementById('rapidScoresModal');
      if (m) m.style.display = 'block';
    } catch(e){}
  } catch(e) { console.warn(e); }
}

function __esc(s){
  try {
    return String(s)
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#39;");
  } catch(e){ return s; }
}

</script>
<!-- Manual Score Entry Modal -->
<div id="scoreModal">
<h3>Manual Score Entry</h3>
<label>
            Rush:
            <input id="manualRush" max="10" min="-10" type="number"/>
</label>
<br/>
<label>
            Mood:
            <input id="manualMood" max="10" min="-10" type="number"/>
</label>
<br/>
<label>
            Social:
            <input id="manualSocial" max="10" min="-10" type="number"/>
</label>
<br/>
<label>
            Energy:
            <input id="manualEnergy" max="10" min="-10" type="number"/>
</label>
<br/>
<label>
            Focus:
            <input id="manualFocus" max="10" min="-10" type="number"/>
</label>
<br/>
<label>
            Anxiety:
            <input id="manualAnxiety" max="10" min="-10" type="number"/>
</label>
<br/>
<label>
            Impair:
            <input id="manualImpair" max="10" min="-10" type="number"/>
</label>
<br/>
<br/>
<button onclick="applyManualScores()">Apply</button>
<button onclick="closeScoreModal()">Cancel</button>
<div style="margin-top:8px; display:flex; gap:8px; justify-content:flex-end;"><button id="manualAddEntryBtn" onclick="applyManualScores(); addEntry();">Add Entry</button></div></div>
<!-- Emotion Wheel Modal -->
<div id="emotionModal" style="display:none; position:fixed; top:10%; left:50%; transform:translateX(-50%);
     background:#fff; padding:20px; border:2px solid #007aff; border-radius:8px; box-shadow:0 4px 8px rgba(0,0,0,0.2); z-index:1000; max-height:80%; overflow:auto;">
<h3>Select Emotions</h3>
<img alt="Emotion Wheel" src="emotion_wheel.jpg" style="width:100%; max-width:500px; margin-bottom:10px; border:1px solid #ccc;"/>
<div id="emotionButtons" style="display:flex; flex-wrap:wrap; gap:6px; margin-top:10px; justify-content:center;"></div>
<br/>
<button onclick="closeEmotionModal()">Close</button>
</div>
<script>
document.addEventListener("DOMContentLoaded", () => {
    document.querySelectorAll('.score-column button').forEach(btn => {
        const val = btn.textContent.trim().split(':')[0];
        if (["0", "1", "2", "3", "4", "5"].includes(val)) {
            btn.style.height = '40px';
        }
  });

});
</script>
<!-- removed fixed-position block for summary buttons (replaced by .summary-controls) -->
<script>
// === Summary Core (revised to read ONLY from main table) ===

let SUMMARY_WINDOW_MINUTES = (window.CONFIG && CONFIG.popups && CONFIG.popups.summary && CONFIG.popups.summary.windowMinutes) || 5;
function setSummaryWindowAndOpen(mins){ SUMMARY_WINDOW_MINUTES = mins; createSummaryPopupTable(); }


// Columns for popup + CSV
const SUMMARY_COLUMNS = ["Time","Rush","Mood","Social","Energy","Focus","Anxiety","Impair","Score","Max","Min","Weighted","5Max"];

// Timers/state
let auto1mIntervalId = null;
let lastAuto1mKey = null;
let auto5mIntervalId = null;
let lastAuto5mKey = null;
let autoSummaryActive = false;

// Utility: minute key & label
function minuteKey(d){
  return d.getFullYear()
    + String(d.getMonth()+1).padStart(2,"0")
    + String(d.getDate()).padStart(2,"0")
    + String(d.getHours()).padStart(2,"0")
    + String(d.getMinutes()).padStart(2,"0");
}
function formatMinuteLabel(d){
  const hh = String(d.getHours()).padStart(2,"0");
  const mm = String(d.getMinutes()).padStart(2,"0");
  return `${hh}:${mm} Average`;
}

// === Snapshot strictly from the MAIN TABLE DOM ===
// Never read from popup or auto-dock.
function snapshotFromMainTable() {
  const table = document.querySelector(CFG.mainTableSelector);
  if (!table) return [];

  const thead = table.tHead || table.querySelector('thead');
  const tbody = table.tBodies?.[0] || table.querySelector('tbody');

  let headers = [];
  if (thead) {
    headers = Array.from(thead.querySelectorAll('th')).map(th => th.textContent.trim());
  } else {
    const firstRow = table.querySelector('tr');
    if (firstRow) headers = Array.from(firstRow.cells).map(td => td.textContent.trim());
  }
  if (!headers.length) return [];

  const tsIdx = (() => {
    const wanted = (window.CONFIG?.backfill?.timestampHeaderNames) || CFG.tsHeaderNames;
    const idxExact = headers.findIndex(h => wanted.some(n => h.toLowerCase() === n.toLowerCase()));
    if (idxExact >= 0) return idxExact;
    const idxContains = headers.findIndex(h => /time|timestamp/i.test(h));
    return idxContains;
  })();
  if (tsIdx < 0) return [];

  const rowEls = tbody ? Array.from(tbody.rows)
                       : Array.from(table.querySelectorAll('tr')).slice(1);
  const rows = [];
  for (const tr of rowEls) {
    if (tr.classList?.contains('backfill-summary-row')) continue;
    const tds = Array.from(tr.cells);
    if (tds.length <= tsIdx) continue;
    const cells = tds.map(td => td.textContent.trim());
    const ts = parseLocalAU(cells[tsIdx], tds[tsIdx]);
    if (ts) rows.push({_ts: ts.getTime(), tr, cells});
  }
  rows.sort((a,b)=>a._ts-b._ts);

  if (!rows.length) {
    console.warn('[Backfill] Snapshot empty. Headers=', headers, 'tsIdx=', tsIdx, 'rowCount=', rowEls.length);
  }
  return rows;
}
// Means over window [startMs, endMs)
function computeMeansForWindow(startMs, endMs){
  const snap = snapshotFromMainTable();
  const sel = snap.filter(e => e._ts >= startMs && e._ts < endMs);
  if (!sel.length) return null;
  const flds = ['rush','mood','social','energy','focus','anxiety','impair'];
  const sums = {rush:0,mood:0,social:0,energy:0,focus:0,anxiety:0,impair:0};
  sel.forEach(e => flds.forEach(f => sums[f] += (e[f]||0)));
  const means = {}; flds.forEach(f => means[f] = +(sums[f]/sel.length));
  return means;
}

// Rolling means of last N minutes ending at endMs
function computeRollingMeans(endMs, minutes){
  return computeMeansForWindow(endMs - minutes*60*1000, endMs);
}

// Composite scores from means
function computeCompositeFromMeans(M){
  const score = (M.rush+M.mood+M.social+M.energy+M.focus) - (M.anxiety+M.impair);
  const max   = Math.max(M.rush,M.mood,M.social,M.energy,M.focus);
  const min   = Math.min(M.rush,M.mood,M.social,M.energy,M.focus);
  const weighted = computeWeighted(M);
  const fiveMax  = ((M.rush + M.mood + M.social + M.energy + M.focus - M.anxiety - M.impair) / 5) + 5;
  return {score, max, min, weighted, fiveMax};
}

// === Backfill controls (manual; also mirrors to any popups) ==================
(function(){
  function getEarliestSnapshotMs(){
    if (typeof snapshotFromMainTable !== 'function') return null;
    const snap = snapshotFromMainTable();
    if (!snap || !snap.length) return null;
    let minTs = snap[0]._ts || 0;
    for (let i=1;i<snap.length;i++){ const t = snap[i]._ts||0; if (t && t < minTs) minTs = t; }
    return minTs || null;
  }
  function hasRowWithLabel(tableId, label){
    const table = document.getElementById(tableId); if (!table) return false;
    const tbody = table.querySelector('tbody'); if (!tbody) return false;
    const firstCol = Array.from(tbody.querySelectorAll('tr > td:first-child')).map(td => (td.textContent||'').trim());
    return firstCol.some(t => t.startsWith(label));
  }
  function alignToBoundary(ms, stepMin){
    const d = new Date(ms);
    d.setSeconds(0,0);
    if (stepMin===60){ d.setMinutes(0,0,0); }
    else if (stepMin===15 || stepMin===5){
      const m = d.getMinutes();
      d.setMinutes(m - (m % stepMin), 0, 0);
    }
    return d.getTime();
  }
  function getPopupTables(){
    const arr = [];
    // Known id
    const t = document.getElementById('summaryPopupTable'); if (t) arr.push(t);
    // Generic selector (any future popups)
    document.querySelectorAll('table[data-role="summary-popup"]').forEach(x=>arr.push(x));
    return arr;
  }
  function appendToAllPopups(boundary, M, C, stepMin){
    const tables = getPopupTables();
    if (!tables.length) return;
    try { if (typeof ensureSummaryPopup === 'function') ensureSummaryPopup(); } catch(e){}
    tables.forEach(tbl => {
      // Force id reference for appendSummaryRowToTable by temporarily giving an id if missing
      let id = tbl.id;
      if (!id){
        id = 'summaryPopupTable_' + stepMin + '_' + (boundary.getTime());
        tbl.id = id;
        tbl.setAttribute('data-role','summary-popup');
      }
      appendSummaryRowToTable(id, boundary, M, C, {bold:false, labelSuffix: ` ${stepMin}m Avg`});
    });
    // Re-apply any popup filter if present
    try { if (typeof applyPopupFilter === 'function') applyPopupFilter(); } catch(e){}
  }
  document.addEventListener('DOMContentLoaded', function(){
  const btn = document.getElementById('backfillBtn');
  if (btn){
    btn.addEventListener('click', function(ev){
      if (typeof window.backfillAll === 'function') window.backfillAll(ev);
    });
  }
});
})();
// ============================================================================


// === Backfill controls (manual only) =========================================
(function(){
  // Helper: earliest timestamp from main table snapshot
  function getEarliestSnapshotMs(){
    const snap = snapshotFromMainTable();
    if (!snap || !snap.length) return null;
    let minTs = snap[0]._ts;
    for (let i=1;i<snap.length;i++){ if (snap[i]._ts < minTs) minTs = snap[i]._ts; }
    return minTs;
  }
  function hasRowWithLabel(tableId, label){
    const table = document.getElementById(tableId); if (!table) return false;
    const tbody = table.querySelector('tbody'); if (!tbody) return false;
    const rows = Array.from(tbody.querySelectorAll('tr'));
    return rows.some(tr => (tr.children && tr.children[0] && (tr.children[0].textContent||"").trim().startsWith(label)));
  }
  function alignToBoundary(ms, stepMin){
    const d = new Date(ms);
    d.setSeconds(0,0);
    if (stepMin===5 || stepMin===15 || stepMin===60){
      if (stepMin===60){
        d.setMinutes(0,0,0);
      } else {
        const m = d.getMinutes();
        const aligned = m - (m % stepMin);
        d.setMinutes(aligned,0,0);
      }
    }
    return d.getTime();
  }
  function backfillWindow(stepMin, tableId){
    const startMs0 = getEarliestSnapshotMs();
    if (startMs0==null) return 0;
    const nowMs = Date.now();
    const stepMs = stepMin*60*1000;
    let t = alignToBoundary(startMs0, stepMin);
    let added = 0;
    while (t <= nowMs){
      const boundary = new Date(t);
      const endMs   = boundary.getTime() + 60*1000; // window ends at the end of that minute label
      const M = computeRollingMeans(endMs, stepMin);
      const C = M ? computeCompositeFromMeans(M) : null;
      const label = formatMinuteLabel(boundary);
      if (M && !hasRowWithLabel(tableId, label)){
        appendSummaryRowToTable(tableId, boundary, M, C, {bold:false, labelSuffix:''});
        added++;
      }
      t += stepMs;
    }
    return added;
  }
  function backfillAll(){
    const added5  = backfillWindow(5,  'summary5Table');
    const added15 = backfillWindow(15, 'summary15Table');
    const added60 = backfillWindow(60, 'summary60Table');
    console.log(`[Backfill] added rows — 5m:${added5}  15m:${added15}  60m:${added60}`);
    // Optional: toast could be added; for now console-only per user's request
  }
  document.addEventListener('DOMContentLoaded', function(){
  const btn = document.getElementById('backfillBtn');
  if (btn){
    btn.addEventListener('click', function(ev){
      if (typeof /* legacy backfill implementation superseded on 2025/10/31 START */
window.backfillAll === 'function') window.backfillAll(ev);
/* legacy backfill implementation superseded on 2025/10/31 END */
    });
  }
});
})();
// ============================================================================


// Append a row to a table by id ('summaryPopupTable' or 'autoSummaryTable')
function appendSummaryRowToTable(tableId, d, M, C, opts){

  // Skip if summary is empty/blank
  if (!isNonEmptySummary(M, C)) { return; }
const table = document.getElementById(tableId);
  if (!table) return;
  const tbody = table.querySelector('tbody'); if (!tbody) return;
  const suffix = (opts && opts.labelSuffix) ? opts.labelSuffix : "";
  const row = [
    formatMinuteLabel(d) + suffix,
    M?.rush, M?.mood, M?.social, M?.energy, M?.focus, M?.anxiety, M?.impair,
    C?.score, C?.max, C?.min, C?.weighted, C?.fiveMax
  ];
  const tr = document.createElement("tr");
  tr.innerHTML = row.map((v,i)=>{
    const name = SUMMARY_COLUMNS[i];
    if (i===0) return `<td>${v??''}</td>`;
    const num = Number(v);
    const isNum = Number.isFinite(num);
    const bg = isNum && typeof cellBgFor==='function' ? cellBgFor(name, num) : '';
    const val = isNum ? num.toFixed(2) : (v ?? '');
    return `<td${bg?` style="background-color:${bg};"`:''}>${val}</td>`;
  }).join("");
  // Tooltips for Max/Min (percent of 10)
  const cells = tr.children;
  const idxMax = SUMMARY_COLUMNS.indexOf('Max');
  const idxMin = SUMMARY_COLUMNS.indexOf('Min');
  if (idxMax>-1 && cells[idxMax]) {
    const v = parseFloat(cells[idxMax].textContent); if (!Number.isNaN(v)) cells[idxMax].title = `${Math.round((v/10)*100)}%`;
  }
  if (idxMin>-1 && cells[idxMin]) {
    const v = parseFloat(cells[idxMin].textContent); if (!Number.isNaN(v)) cells[idxMin].title = `${Math.round((v/10)*100)}%`;
  }
  tbody.appendChild(tr);
}

// Emit 1-minute rolling average (used by Auto)
function emitAuto1m(){
  const now = new Date();
  const prev = new Date(now.getTime() - 60*1000); prev.setSeconds(0,0);
  const key = minuteKey(prev);
  if (lastAuto1mKey === key) return;
  lastAuto1mKey = key;
  const endMs = prev.getTime() + 60*1000;
  const M = computeRollingMeans(endMs, SUMMARY_WINDOW_MINUTES);
  const C = M ? computeCompositeFromMeans(M) : null;
  if (M) {
    appendSummaryRowToTable('autoSummaryTable', prev, M, C, {bold:false, labelSuffix:' 5m Avg'});
    // If popup exists, mirror there as well (still isolated from its own data)
    if (document.getElementById('summaryPopupTable')) {
    }
  } else { /* skip empty immediate emit */ }
}

// Emit 5-minute rolling average at each 5-minute boundary (popup)
function emitAuto5m(){ /* [number1-only] no-op */ }
// Toggle Auto (1-minute rolling stream) — sync both buttons and emit immediately
function toggleAutoSummary(){
  autoSummaryActive = !autoSummaryActive;
  const btn1 = document.getElementById('autoSummaryBtn');       // popup button
  const btn2 = document.getElementById('autoSummaryToggleBtn'); // fixed header button
  if (autoSummaryActive){
    try { if (typeof window.autoSliderAStart === 'function') window.autoSliderAStart(); } catch (e) {}
    if (btn1) btn1.textContent = 'Auto (On)';
    if (btn2) btn2.textContent = 'Auto (On)';
    // emit immediate row
    (function immediateEmit(){
      const endMs = Date.now();
      const M = computeRollingMeans(endMs, SUMMARY_WINDOW_MINUTES);
      const C = M ? computeCompositeFromMeans(M) : null;
      const d = new Date();
      if (M) {
        appendSummaryRowToTable('autoSummaryTable', d, M, C, {bold:false, labelSuffix:' 5m Now'});
      } else { /* skip empty auto-summary row */ }
    })();
    // schedule boundary-aligned loop
    if (auto1mIntervalId) clearInterval(auto1mIntervalId);
    const now = new Date();
    const msToNext = (60 - now.getSeconds())*1000 - now.getMilliseconds();
    setTimeout(()=>{
      emitAuto1m();
      auto1mIntervalId = setInterval(function(){ try{ if (typeof emitAuto1m==='function') emitAuto1m(); }catch(e){} }, 60000);
    }, Math.max(0, msToNext));
  } else {
    try { if (typeof window.autoSliderAStop === 'function') window.autoSliderAStop(); } catch (e) {}
    if (btn1) btn1.textContent = 'Auto (Off)';
    if (btn2) btn2.textContent = 'Auto';
    if (auto1mIntervalId){ clearInterval(auto1mIntervalId); auto1mIntervalId=null; }
  }
}

// Popup builder (id=summaryPopup, #summaryPopupTable) — unchanged shell
function ensureSummaryPopup(){
  let popup = document.getElementById("summaryPopup");
  if (popup) return popup;
  popup = document.createElement("div");
  popup.id = "summaryPopup";
  Object.assign(popup.style, {
    position:"fixed", top:"70px", right:"20px", background:"#fff", border:"1px solid #ccc",
    borderRadius:"8px", boxShadow:"0 4px 16px rgba(0,0,0,0.2)", maxHeight:"70vh", overflow:"auto",
    zIndex:"9999", padding:"10px"
  });

  const head = document.createElement("div");
  Object.assign(head.style, {display:"flex", justifyContent:"space-between", alignItems:"center", marginBottom:"6px"});
  head.innerHTML = `<strong>Summary</strong>`;
  const controls = document.createElement("div");

  const exportBtn = document.createElement("button");
exportBtn
  exportBtn.textContent = "Export CSV";
  exportBtn.onclick = exportPopupCSV;

  const autoBtn = document.createElement("button");
autoBtn
  autoBtn.id = "autoSummaryBtn";
  autoBtn.textContent = autoSummaryActive ? "Auto (On)" : "Auto (Off)";
  autoBtn.onclick = toggleAutoSummary;

  const closeBtn = document.createElement("button");
closeBtn
  closeBtn.textContent = "×";
  closeBtn.style.marginLeft = "8px";
  closeBtn.onclick = ()=>popup.remove();

  controls.appendChild(exportBtn);

  const instant5Btn = document.createElement("button");
instant5Btn
  instant5Btn.textContent = "5m Now";
  instant5Btn.onclick = ()=>appendInstantSummaryToPopup(5);
  controls.appendChild(instant5Btn);

  const instant15Btn = document.createElement("button");
instant15Btn
  instant15Btn.textContent = "15m Now";
  instant15Btn.onclick = ()=>appendInstantSummaryToPopup(15);
  controls.appendChild(instant15Btn);

  controls.appendChild(autoBtn);
  controls.appendChild(closeBtn);
  head.appendChild(controls);
  popup.appendChild(head);

  const table = document.createElement("table");
  table.id = "summaryPopupTable";
  table.style.borderCollapse="collapse";
  table.style.width="100%";
  const thead = document.createElement("thead");
  thead.innerHTML = `<tr>${SUMMARY_COLUMNS.map(c=>`<th>${c}</th>`).join("")}</tr>`;
  table.appendChild(thead);
  table.appendChild(document.createElement("tbody"));
  popup.appendChild(table);
  document.body.appendChild(popup);
  return popup;
}

// Create/open popup, dense backfill based on MAIN TABLE data, then start 5m cadence
function createSummaryPopupTable(){
  ensureSummaryPopup();
  // Backfill: find min and max _ts from main table
  const snap = snapshotFromMainTable();
  if (snap.length){
    const minTs = Math.min(...snap.map(x=>x._ts));
    const now = Date.now();
    // Build completed 5-min boundaries between minTs and now
    const start = new Date(minTs); start.setSeconds(0,0);
    start.setMinutes(start.getMinutes() - (start.getMinutes()%5), 0, 0);
    for (let t = start.getTime(); t <= now; t += 5*60000){
      const endMs = t + 60000; // 1 minute after boundary for window end
      const d = new Date(t);
      const M = computeRollingMeans(endMs, SUMMARY_WINDOW_MINUTES);
      if (M){
      } else {
      }
    }
    // Also append a "now" row
    const Mnow = computeRollingMeans(Date.now(), SUMMARY_WINDOW_MINUTES);
    const dnow = new Date();
    if (Mnow){
    } else {
    }
  }
  // Start cadence
  emitAuto5m();
// [removed:number1-only] startAuto5mTimer() call removed
}

// Start 5-minute timer (popup flow)
// [removed:number1-only] startAuto5mTimer() definition removed
// Append one immediate summary row for a given window into the popup
function appendInstantSummaryToPopup(minutes){
  ensureSummaryPopup();
  const now = Date.now();
  const M = computeRollingMeans(now, minutes);
  const d = new Date();
  if (M){
  } else {
  }
}

// CSV export (popup)
function exportPopupCSV(){
  const table = document.getElementById("summaryPopupTable"); if (!table) return;
  const rows = [SUMMARY_COLUMNS.join(",")];
  table.querySelectorAll("tbody tr").forEach(tr=>{
    const vals = Array.from(tr.children).slice(0, SUMMARY_COLUMNS.length).map(td=>{
      const t = td.textContent.trim();
      return /[",\n]/.test(t) ? `"${t.replace(/"/g,'""')}"` : t;
    });
    rows.push(vals.join(","));
  });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([rows.join("\n")], {type:"text/csv;charset=utf-8"}));
  a.download = "summary.csv"; document.body.appendChild(a); a.click(); URL.revokeObjectURL(a.href); a.remove();
}
window.createSummaryPopupTable = createSummaryPopupTable;
window.toggleAutoSummary = toggleAutoSummary;
</script>
<button class="ctrl-btn" id="backfillBtnGlobal">Backfill</button>
<script>
// Group note buttons by colour into separate rows (no colour/style changes)
(function(){
  function detectColour(btn){
    // Prefer data-category if present
    const dcat = btn.getAttribute('data-category');
    if (dcat) return dcat.trim().toLowerCase();
    // Try class pattern note-btn--{colour}
    const cls = btn.className||'';
    const m = cls.match(/note-btn--([a-z]+)/);
    if (m) return m[1].toLowerCase();
    // Fallback: look at inline style background-color to cluster; hash the value
    const bg = btn.style && btn.style.backgroundColor ? btn.style.backgroundColor.trim() : '';
    return bg || 'default';
  }

  function ensureRow(container, key, label){
    let row = container.querySelector(`[data-row="${key}"]`);
    if (!row){
      row = document.createElement('div');
      row.setAttribute('data-row', key);
      row.style.display = 'flex';
      row.style.flexWrap = 'wrap';
      row.style.gap = '6px';
      row.style.alignItems = 'center';
      row.style.padding = '2px 0';

      // Heading (keep neutral styling per user request)
      const h = document.createElement('div');
      h.textContent = label;
      h.style.minWidth = '90px';
      h.style.fontWeight = '600';
      h.style.marginRight = '8px';
      row.appendChild(h);

      container.appendChild(row);
    }
    return row;
  }

  function titleCase(s){ return s.charAt(0).toUpperCase()+s.slice(1); }

  document.addEventListener('DOMContentLoaded', function(){
    const container = document.getElementById('noteButtonRows');
    if (!container) return;

    // Collect existing note buttons wherever they currently are
    const btns = Array.from(document.querySelectorAll('.note-btn'));
    if (!btns.length) return;

    // Preferred order if present amongst buttons
    const orderPref = ['red','orange','yellow','gold','green','blue','purple','pink','grey','gray','black','white','default'];

    // Build a map colour -> buttons
    const buckets = new Map();
    btns.forEach(btn=>{
      const key = detectColour(btn);
      if (!buckets.has(key)) buckets.set(key, []);
      buckets.get(key).push(btn);
    });

    // Sort keys by preferred order, then by name
    const keys = Array.from(buckets.keys());
    keys.sort((a,b)=>{
      const ia = orderPref.indexOf(a), ib = orderPref.indexOf(b);
      if (ia!==-1 || ib!==-1){
        return (ia===-1?999:ia) - (ib===-1?999:ib);
      }
      return a.localeCompare(b);
    });

    // Move buttons into their colour rows (preserve existing button styles/handlers)
    keys.forEach(k=>{
      const row = ensureRow(container, k, titleCase(k));
      buckets.get(k).forEach(btn=>{
        // Ensure width/spacing remains tidy but do not alter colours
        btn.style.margin = '0';
        row.appendChild(btn);
  });
  });
})();
</script>
<script>
// === Statistical Analysis (5m) — popup + table, cloned from 5m Summary with extra columns ===
// Columns: base SUMMARY_COLUMNS + Notes, Drug, QtySum (new; only for this summary)
(function(){
  // Fallbacks if base helpers are not in scope
  const BASE_COLS = (typeof SUMMARY_COLUMNS !== 'undefined' && Array.isArray(SUMMARY_COLUMNS))
    ? SUMMARY_COLUMNS.slice()
    : ["Time","Rush","Mood","Social","Energy","Focus","Anxiety","Impair","Score","Max","Min","Weighted","5Max"];
  const STAT_COLUMNS = BASE_COLS.concat(["Notes","Drug","QtySum"]);

  function ensureStatAnalysisPopup(){
    let popup = document.getElementById("statAnalysisPopup");
    if (popup) return popup;
    popup = document.createElement("div");
    popup.id = "statAnalysisPopup";
    Object.assign(popup.style, {
      position:"fixed", top:"70px", right:"20px", background:"#fff", border:"1px solid #ccc",
      borderRadius:"8px", boxShadow:"0 4px 16px rgba(0,0,0,0.2)", maxHeight:"70vh", overflow:"auto",
      zIndex:"10000", padding:"10px"
    });
    const head = document.createElement("div");
    Object.assign(head.style, {display:"flex", justifyContent:"space-between", alignItems:"center", marginBottom:"6px"});
    head.innerHTML = `<strong>Statistical Analysis (5m)</strong>`;
    const controls = document.createElement("div");
    const exportBtn = document.createElement("button");
exportBtn.classList.add('metric-btn');
    exportBtn.textContent = "Export CSV";
    exportBtn.onclick = exportStatCSV;
    const closeBtn = document.createElement("button");
closeBtn.classList.add('metric-btn');
    closeBtn.textContent = "×";
    closeBtn.style.marginLeft = "8px";
    closeBtn.onclick = ()=>popup.remove();
    controls.appendChild(exportBtn);
    controls.appendChild(closeBtn);
    head.appendChild(controls);
    popup.appendChild(head);

    const table = document.createElement("table");
    table.id = "statAnalysisTable";
    table.style.borderCollapse="collapse";
    table.style.width="100%";
    const thead = document.createElement("thead");
    thead.innerHTML = `<tr>${STAT_COLUMNS.map(c=>`<th>${c}</th>`).join("")}</tr>`;
    table.appendChild(thead);
    table.appendChild(document.createElement("tbody"));
    popup.appendChild(table);

    document.body.appendChild(popup);
    return popup;
  }

  function openStatAnalysis(){
    ensureStatAnalysisPopup();
    createStatAnalysisPopupTable();
  }
  window.openStatAnalysis = openStatAnalysis;

  // Helpers copied/compatible with existing utilities
  function minuteKey(d){
    return d.getFullYear()
      + String(d.getMonth()+1).padStart(2,"0")
      + String(d.getDate()).padStart(2,"0")
      + String(d.getHours()).padStart(2,"0")
      + String(d.getMinutes()).padStart(2,"0");
  }
  function formatMinuteLabel(d){
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    return `${hh}:${mm} Average`;
  }
  // Read-only snapshot of main table rows with extra fields (Notes/Drug/Qty)

function snapshotWithExtras(){
    const rows = Array.from(document.querySelectorAll('#logTable tbody tr'));
    return rows.map(tr => {
      const ts = +(tr.getAttribute('data-ts')||0);

      // Case-insensitive value getter by data-col name(s)
      const getValCI = (names) => {
        const want = Array.isArray(names) ? names.map(n=>String(n).toLowerCase()) : [String(names).toLowerCase()];
        const tds = tr.querySelectorAll('td[data-col]');
        for (const td of tds){
          const col = (td.getAttribute('data-col')||'').trim().toLowerCase();
          if (want.includes(col)) return td.textContent.trim();
        }

  try { window.snapshotWithExtras = snapshotWithExtras; } catch(e){}
      };

      // Numeric extractor from a cell (handles "10 mg", "-2.5", etc.)
      const numFrom = (names) => {
        const raw = getValCI(names);
        const m = (raw||"").match(/-?\d+(\.\d+)?/);
        return m ? parseFloat(m[0]) : NaN;
      };

      const getSum = (field) => {
        const td = tr.querySelector(`td[data-field="${field}Sum"]`);
        if (!td) return 0;
        const v = parseFloat(td.getAttribute('data-value')||td.textContent||'0');
        return Number.isFinite(v) ? v : 0;
      };

      return {
        _ts: ts,
        rush: getSum('rush'), mood: getSum('mood'), social: getSum('social'),
        energy: getSum('energy'), focus: getSum('focus'), anxiety: getSum('anxiety'), impair: getSum('impair'),
        // extras (case-insensitive header matching)
        Notes: getValCI(["Notes","Note"]),
        Drug: getValCI(["Drug"]),
        Qty: numFrom(["Qty","QTY","Quantity"])
      };
    }).filter(o => o._ts>0);
  }


  function computeMeansForWindow(startMs, endMs){
    const snap = snapshotWithExtras();
    const sel = snap.filter(e => e._ts >= startMs && e._ts < endMs);
    if (!sel.length) return null;
    const flds = ['rush','mood','social','energy','focus','anxiety','impair'];
    const sums = {rush:0,mood:0,social:0,energy:0,focus:0,anxiety:0,impair:0};
    sel.forEach(e => flds.forEach(f => sums[f] += (e[f]||0)));
    const means = {}; flds.forEach(f => means[f] = +(sums[f]/sel.length));
    return {means, sel};
  }
  function computeCompositeFromMeans(M){
    if (!M) return null;
    const m = M.means || M;
    const score = (+m.rush + +m.mood + +m.social + +m.energy + +m.focus) - (+m.anxiety + +m.impair);
    const max = Math.max(m.rush, m.mood, m.social, m.energy, m.focus, m.anxiety, m.impair);
    const min = Math.min(m.rush, m.mood, m.social, m.energy, m.focus, m.anxiety, m.impair);
    const weighted = computeWeighted(M);
    const fiveMax = [m.rush,m.mood,m.social,m.energy,m.focus].sort((a,b)=>b-a).slice(0,5).reduce((a,b)=>a+b,0);
    return {score, max, min, weighted, fiveMax};
  }

  function aggregateExtras(sel){
    // Notes: tokenise and include all tokens (including duplicates)
    const tokenize = (s) => {
      if (!s) return [];
      // If a custom tokeniser exists, prefer it
      if (typeof window.tokenizeNotes === 'function') {
        try { return window.tokenizeNotes(s) || []; } catch(e){}
      }
      return (s.match(/[A-Za-z0-9_]+/g) || []).map(x=>x);
    };
    const notesTokens = [];
    const drugs = [];
    let qtySum = 0;
    sel.forEach(e => {
      tokenize(e.Notes).forEach(tok => notesTokens.push(tok));
      if (e.Drug) drugs.push(e.Drug);
      if (Number.isFinite(e.Qty)) qtySum += e.Qty;
    });
    return {
      Notes: notesTokens.join(", "),
      Drug: drugs.join(", "),
      QtySum: Number.isFinite(qtySum) ? +qtySum : 0
    };
  }

  function appendStatRowToTable(tableId, d, M, C, extras){
    if (!M || !C) return;
    const table = document.getElementById(tableId); if (!table) return;
    const tbody = table.querySelector('tbody'); if (!tbody) return;
    const row = [
      formatMinuteLabel(d) + " 5m Avg",
      M.means.rush, M.means.mood, M.means.social, M.means.energy, M.means.focus, M.means.anxiety, M.means.impair,
      C.score, C.max, C.min, C.weighted, C.fiveMax,
      extras.Notes, extras.Drug, extras.QtySum
    ];
    const tr = document.createElement("tr");
    tr.innerHTML = row.map((v,i)=>{
      const name = STAT_COLUMNS[i];
      if (i===0) return `<td>${v??''}</td>`;
      const num = Number(v);
      const isNum = Number.isFinite(num);
      const bg = isNum && typeof cellBgFor==='function' ? cellBgFor(name, num) : '';
      const val = isNum ? num.toFixed(2) : (v ?? '');
      return `<td${bg?` style="background-color:${bg};"`:''}>${val}</td>`;
    }).join("");
    tbody.appendChild(tr);
  }

  function backfillStatAnalysis(){
    const snap = snapshotWithExtras();
    if (!snap.length) return 0;
    const minTs = Math.min(...snap.map(x=>x._ts));
    const now = Date.now();
    const start = new Date(minTs); start.setSeconds(0,0);
    start.setMinutes(start.getMinutes() - (start.getMinutes()%5), 0, 0);
    let added = 0;
    for (let t = start.getTime(); t <= now; t += 5*60000){
      const endMs = t + 5*60000;
      const d = new Date(t);
      const M = computeMeansForWindow(t, endMs);
      if (!M) continue;
      const C = computeCompositeFromMeans(M);
      const extras = aggregateExtras(M.sel);
      appendStatRowToTable('statAnalysisTable', d, M, C, extras);
      added++;
    }
    return added;
  }

  function createStatAnalysisPopupTable(){
    ensureStatAnalysisPopup();
    const tbody = document.querySelector('#statAnalysisTable tbody'); if (tbody) tbody.innerHTML='';
    backfillStatAnalysis();
    // Start cadence on 5m boundaries
    if (window._stat5mTimer) { clearInterval(window._stat5mTimer); window._stat5mTimer = null; }
    const schedule = ()=>{
      const now = new Date();
      const msToNext = (5 - (now.getMinutes()%5))*60000 - now.getSeconds()*1000 - now.getMilliseconds();
      setTimeout(()=>{
        appendLatestStatRow();
        window._stat5mTimer = setInterval(appendLatestStatRow, 5*60000);
      }, Math.max(0, msToNext));
    };
    function appendLatestStatRow(){
      const end = new Date(); end.setSeconds(0,0);
      const startMs = end.getTime() - 5*60000;
      const M = computeMeansForWindow(startMs, end.getTime());
      if (!M) return;
      const C = computeCompositeFromMeans(M);
      const extras = aggregateExtras(M.sel);
      appendStatRowToTable('statAnalysisTable', end, M, C, extras);
    }
    schedule();
  }

  function exportStatCSV(){
    const table = document.getElementById("statAnalysisTable"); if (!table) return;
    const rows = [STAT_COLUMNS.join(",")];
    table.querySelectorAll("tbody tr").forEach(tr=>{
      const vals = Array.from(tr.children).slice(0, STAT_COLUMNS.length).map(td=>{
        const t = td.textContent.trim();
        return /[",\n]/.test(t) ? `"${t.replace(/"/g,'""')}"` : t;
      });
      rows.push(vals.join(","));
    });
    const csv = rows.join("\\n");
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8;"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = "statistical_analysis_5m.csv";
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  }
})();
</script>
<script>
// === Statistical Analysis (60m) — popup + table, cloned from 5m Statistical Analysis with hourly bins ===
(function(){
  const BASE_COLS = (typeof SUMMARY_COLUMNS !== 'undefined' && Array.isArray(SUMMARY_COLUMNS))
    ? SUMMARY_COLUMNS.slice()
    : ["Time","Rush","Mood","Social","Energy","Focus","Anxiety","Impair","Score","Max","Min","Weighted","5Max"];
  const STAT_COLUMNS = BASE_COLS.concat(["Notes","Drug","QtySum"]);

  function ensureStatAnalysisHourPopup(){
    let popup = document.getElementById("statAnalysisHourPopup");
    if (popup) return popup;
    popup = document.createElement("div");
    popup.id = "statAnalysisHourPopup";
    Object.assign(popup.style, {
      position:"fixed", top:"70px", left:"20px", background:"#fff", border:"1px solid #ccc",
      borderRadius:"8px", boxShadow:"0 4px 16px rgba(0,0,0,0.2)", maxHeight:"70vh", overflow:"auto",
      zIndex:"10000", padding:"10px"
    });
    const head = document.createElement("div");
    Object.assign(head.style, {display:"flex", justifyContent:"space-between", alignItems:"center", marginBottom:"6px"});
    head.innerHTML = `<strong>Statistical Analysis (60m)</strong>`;
    const controls = document.createElement("div");
    const exportBtn = document.createElement("button");
exportBtn
    exportBtn.textContent = "Export CSV";
    exportBtn.onclick = exportStatHourCSV;
    const closeBtn = document.createElement("button");
closeBtn
    closeBtn.textContent = "×";
    closeBtn.style.marginLeft = "8px";
    closeBtn.onclick = ()=>popup.remove();
    controls.appendChild(exportBtn);
    controls.appendChild(closeBtn);
    head.appendChild(controls);
    popup.appendChild(head);

    const table = document.createElement("table");
    table.id = "statAnalysisHourTable";
    table.style.borderCollapse="collapse";
    table.style.width="100%";
    const thead = document.createElement("thead");
    thead.innerHTML = `<tr>${STAT_COLUMNS.map(c=>`<th>${c}</th>`).join("")}</tr>`;
    table.appendChild(thead);
    table.appendChild(document.createElement("tbody"));
    popup.appendChild(table);

    document.body.appendChild(popup);
    return popup;
  }

  function openStatAnalysisHourly(){
    ensureStatAnalysisHourPopup();
    createStatAnalysisHourPopupTable();
  }
  window.openStatAnalysisHourly = openStatAnalysisHourly;
  // Local snapshot for hourly analysis (no external dependency)
  function snapshotWithExtrasHour(){
    const rows = Array.from(document.querySelectorAll('#logTable tbody tr'));
    return rows.map(tr => {
      const ts = +(tr.getAttribute('data-ts')||0);
      // Case-insensitive value getter by data-col name(s)
      const getValCI = (names) => {
        const want = Array.isArray(names) ? names.map(n=>String(n).toLowerCase()) : [String(names).toLowerCase()];
        const tds = tr.querySelectorAll('td[data-col]');
        for (const td of tds){
          const col = (td.getAttribute('data-col')||'').trim().toLowerCase();
          if (want.includes(col)) return td.textContent.trim();
        }
      };
      const numFrom = (names) => {
        const raw = getValCI(names);
        const m = (raw||"").match(/-?\d+(\.\d+)?/);
        return m ? parseFloat(m[0]) : NaN;
      };
      const getSum = (field) => {
        const td = tr.querySelector(`td[data-field="${field}Sum"]`);
        if (!td) return 0;
        const v = parseFloat(td.getAttribute('data-value')||td.textContent||'0');
        return Number.isFinite(v) ? v : 0;
      };
      return {
        _ts: ts,
        rush: getSum('rush'), mood: getSum('mood'), social: getSum('social'),
        energy: getSum('energy'), focus: getSum('focus'), anxiety: getSum('anxiety'), impair: getSum('impair'),
        Notes: getValCI(["Notes","Note"]),
        Drug: getValCI(["Drug"]),
        Qty: numFrom(["Qty","QTY","Quantity"])
      };
    }).filter(o => o._ts>0);
  }


  function formatHourLabel(d){
    const hh = String(d.getHours()).padStart(2,"0");
    return `${hh}:00 Average`;
  }

  function minuteKey(d){
    return d.getFullYear()
      + String(d.getMonth()+1).padStart(2,"0")
      + String(d.getDate()).padStart(2,"0")
      + String(d.getHours()).padStart(2,"0")
      + String(d.getMinutes()).padStart(2,"0");
  }

  // We reuse snapshotWithExtras() from v2 patch; it is already global in this file.

  function computeMeansForWindowHour(startMs, endMs){
    const snap = snapshotWithExtrasHour();
    const sel = snap.filter(e => e._ts >= startMs && e._ts < endMs);
    if (!sel.length) return null;
    const flds = ['rush','mood','social','energy','focus','anxiety','impair'];
    const sums = {rush:0,mood:0,social:0,energy:0,focus:0,anxiety:0,impair:0};
    sel.forEach(e => flds.forEach(f => sums[f] += (e[f]||0)));
    const means = {}; flds.forEach(f => means[f] = +(sums[f]/sel.length));
    return {means, sel};
  }
  function computeCompositeFromMeansHour(M){
    if (!M) return null;
    const m = M.means || M;
    const score = (+m.rush + +m.mood + +m.social + +m.energy + +m.focus) - (+m.anxiety + +m.impair);
    const max = Math.max(m.rush, m.mood, m.social, m.energy, m.focus, m.anxiety, m.impair);
    const min = Math.min(m.rush, m.mood, m.social, m.energy, m.focus, m.anxiety, m.impair);
    const weighted = computeWeighted(M);
    const fiveMax = [m.rush,m.mood,m.social,m.energy,m.focus].sort((a,b)=>b-a).slice(0,5).reduce((a,b)=>a+b,0);
    return {score, max, min, weighted, fiveMax};
  }

  function aggregateExtrasHour(sel){
    const tokenize = (s) => {
      if (!s) return [];
      if (typeof window.tokenizeNotes === 'function') {
        try { return window.tokenizeNotes(s) || []; } catch(e){}
      }
      return (s.match(/[A-Za-z0-9_]+/g) || []).map(x=>x);
    };
    const notesTokens = [];
    const drugs = [];
    let qtySum = 0;
    sel.forEach(e => {
      tokenize(e.Notes).forEach(tok => notesTokens.push(tok));
      if (e.Drug) drugs.push(e.Drug);
      if (Number.isFinite(e.Qty)) qtySum += e.Qty;
    });
    return {
      Notes: notesTokens.join(", "),
      Drug: drugs.join(", "),
      QtySum: Number.isFinite(qtySum) ? +qtySum : 0
    };
  }

  function appendStatHourRowToTable(tableId, d, M, C, extras){
    if (!M || !C) return;
    const table = document.getElementById(tableId); if (!table) return;
    const tbody = table.querySelector('tbody'); if (!tbody) return;
    const row = [
      formatHourLabel(d) + " 60m Avg",
      M.means.rush, M.means.mood, M.means.social, M.means.energy, M.means.focus, M.means.anxiety, M.means.impair,
      C.score, C.max, C.min, C.weighted, C.fiveMax,
      extras.Notes, extras.Drug, extras.QtySum
    ];
    const tr = document.createElement("tr");
    tr.innerHTML = row.map((v,i)=>{
      const name = STAT_COLUMNS[i];
      if (i===0) return `<td>${v??''}</td>`;
      const num = Number(v);
      const isNum = Number.isFinite(num);
      const bg = isNum && typeof cellBgFor==='function' ? cellBgFor(name, num) : '';
      const val = isNum ? num.toFixed(2) : (v ?? '');
      return `<td${bg?` style="background-color:${bg};"`:''}>${val}</td>`;
    }).join("");
    tbody.appendChild(tr);
  }

  function backfillStatAnalysisHour(){
    const snap = snapshotWithExtrasHour();
    if (!snap.length) return 0;
    const minTs = Math.min(...snap.map(x=>x._ts));
    const now = Date.now();
    // Align start to top of the hour
    const start = new Date(minTs); start.setSeconds(0,0); start.setMinutes(0,0);
    let added = 0;
    for (let t = start.getTime(); t <= now; t += 60*60000){
      const endMs = t + 60*60000;
      const d = new Date(t);
      const M = computeMeansForWindowHour(t, endMs);
      if (!M) continue;
      const C = computeCompositeFromMeansHour(M);
      const extras = aggregateExtrasHour(M.sel);
      appendStatHourRowToTable('statAnalysisHourTable', d, M, C, extras);
      added++;
    }
    return added;
  }

  function createStatAnalysisHourPopupTable(){
    ensureStatAnalysisHourPopup();
    const tbody = document.querySelector('#statAnalysisHourTable tbody'); if (tbody) tbody.innerHTML='';
    backfillStatAnalysisHour();
    // Start cadence at top-of-hour
    if (window._stat60mTimer) { clearInterval(window._stat60mTimer); window._stat60mTimer = null; }
    const schedule = ()=>{
      const now = new Date();
      const msToNext = (60 - now.getMinutes())*60000 - now.getSeconds()*1000 - now.getMilliseconds();
      setTimeout(()=>{
        appendLatestHourRow();
        window._stat60mTimer = setInterval(appendLatestHourRow, 60*60000);
      }, Math.max(0, msToNext));
    };
    function appendLatestHourRow(){
      const end = new Date(); end.setSeconds(0,0); end.setMinutes(0,0); // top of hour
      const startMs = end.getTime() - 60*60000;
      const M = computeMeansForWindowHour(startMs, end.getTime());
      if (!M) return;
      const C = computeCompositeFromMeansHour(M);
      const extras = aggregateExtrasHour(M.sel);
      appendStatHourRowToTable('statAnalysisHourTable', end, M, C, extras);
    }
    schedule();
  }

  function exportStatHourCSV(){
    const table = document.getElementById("statAnalysisHourTable"); if (!table) return;
    const rows = [STAT_COLUMNS.join(",")];
    table.querySelectorAll("tbody tr").forEach(tr=>{
      const vals = Array.from(tr.children).slice(0, STAT_COLUMNS.length).map(td=>{
        const t = td.textContent.trim();
        return /[\",\n]/.test(t) ? `"${t.replace(/"/g,'""')}"` : t;
      });
      rows.push(vals.join(","));
    });
    const csv = rows.join("\\n");
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8;"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = "statistical_analysis_60m.csv";
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  }
})();
</script>
<script>
// === Summary Significant 5m — 5-minute bins; numeric = MAX, labels = MEDIAN ===
(function(){
  const NUM_METRICS = ['rush','mood','social','energy','focus','anxiety','impair'];
  const LABEL_MAP = {
    rush:   ['Rush Label','RushLabel','rush label','rushlabel'],
    mood:   ['Mood Label','MoodLabel','mood label','moodlabel'],
    social: ['Social Label','SocialLabel','social label','sociallabel'],
    energy: ['Energy Label','EnergyLabel','energy label','energylabel'],
    focus:  ['Focus Label','FocusLabel','focus label','focuslabel'],
    anxiety:['Anxiety Label','AnxietyLabel','anxiety label','anxietylabel'],
    impair: ['Impair Label','ImpairLabel','impair label','impairlabel'],
  };

  const COLS = [
    'Time',
    'Rush','Rush Label',
    'Mood','Mood Label',
    'Social','Social Label',
    'Energy','Energy Label',
    'Focus','Focus Label',
    'Anxiety','Anxiety Label',
    'Impair','Impair Label'
  ];

  function ensureSignificant5mPopup(){
    let popup = document.getElementById("significant5mPopup");
    if (popup) return popup;
    popup = document.createElement("div");
    popup.id = "significant5mPopup";
    Object.assign(popup.style, {
      position:"fixed", top:"70px", right:"20px", background:"#fff", border:"1px solid #ccc",
      borderRadius:"8px", boxShadow:"0 4px 16px rgba(0,0,0,0.2)", maxHeight:"70vh", overflow:"auto",
      zIndex:"10000", padding:"10px"
    });
    const head = document.createElement("div");
    Object.assign(head.style, {display:"flex", justifyContent:"space-between", alignItems:"center", marginBottom:"6px"});
    head.innerHTML = `<strong>Summary Significant 5m</strong>`;
    const controls = document.createElement("div");
    const exportBtn = document.createElement("button");
exportBtn
    exportBtn.textContent = "Export CSV";
    exportBtn.onclick = exportSignificant5mCSV;
    const closeBtn = document.createElement("button");
closeBtn
    closeBtn.textContent = "×";
    closeBtn.style.marginLeft = "8px";
    closeBtn.onclick = ()=>popup.remove();
    controls.appendChild(exportBtn);
    controls.appendChild(closeBtn);
    head.appendChild(controls);
    popup.appendChild(head);

    const table = document.createElement("table");
    table.id = "significant5mTable";
    table.style.borderCollapse="collapse";
    table.style.width="100%";
    const thead = document.createElement("thead");
    thead.innerHTML = `<tr>${COLS.map(c=>`<th>${c}</th>`).join("")}</tr>`;
    table.appendChild(thead);
    table.appendChild(document.createElement("tbody"));
    popup.appendChild(table);

    document.body.appendChild(popup);
    return popup;
  }

  function openSignificant5m(){
    ensureSignificant5mPopup();
    createSignificant5mPopupTable();
  }
  window.openSignificant5m = openSignificant5m;

  // Utilities (local; independent)
  function minuteKey(d){
    return d.getFullYear()
      + String(d.getMonth()+1).padStart(2,"0")
      + String(d.getDate()).padStart(2,"0")
      + String(d.getHours()).padStart(2,"0")
      + String(d.getMinutes()).padStart(2,"0");
  }
  function formatMinuteLabel(d){
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    return `${hh}:${mm} Significant`;
  }
  function snapshotForSignificant(){
    const rows = Array.from(document.querySelectorAll('#logTable tbody tr'));
    return rows.map(tr => {
      const ts = +(tr.getAttribute('data-ts')||0);
      // Helpers
      const getSum = (field) => {
        const td = tr.querySelector(`td[data-field="${field}Sum"]`);
        if (!td) return 0;
        const v = parseFloat(td.getAttribute('data-value')||td.textContent||'0');
        return Number.isFinite(v) ? v : 0;
      };
      const getValCI = (names) => {
        const want = (Array.isArray(names)?names:[names]).map(s=>String(s).toLowerCase());
        const tds = tr.querySelectorAll('td[data-col]');
        for (const td of tds){
          const col = (td.getAttribute('data-col')||'').trim().toLowerCase();
          if (want.includes(col)) return td.textContent.trim();
        }
      };
      const pack = { _ts: ts };
      // numeric
      NUM_METRICS.forEach(f => pack[f] = getSum(f));
      // labels
      NUM_METRICS.forEach(f => pack[f+'Label'] = getValCI(LABEL_MAP[f]));
      return pack;
    }).filter(o => o._ts>0);
  }

  function computeMaxAndMedianLabels(startMs, endMs){
    const snap = snapshotForSignificant();
    const sel = snap.filter(e => e._ts >= startMs && e._ts < endMs);
    if (!sel.length) return null;
    const out = { max:{}, medianLabel:{} };
    NUM_METRICS.forEach(f => {
      // Max numeric
      let mx = -Infinity;
      sel.forEach(e => { const v = +e[f] || 0; if (v > mx) mx = v; });
      out.max[f] = (mx === -Infinity ? 0 : mx);
      // Median label by numeric rank
      const pairs = sel.map(e => ({v: +e[f]||0, label: e[f+'Label']||''})).sort((a,b)=>a.v-b.v);
      const mid = Math.floor((pairs.length-1)/2);
      out.medianLabel[f] = (pairs[mid] && pairs[mid].label) ? pairs[mid].label : '';
    });
    return out;
  }

  function appendSignificantRow(tableId, d, R){
    if (!R) return;
    const table = document.getElementById(tableId); if (!table) return;
    const tbody = table.querySelector('tbody'); if (!tbody) return;
    const row = [
      formatMinuteLabel(d),
      R.max.rush,   R.medianLabel.rush,
      R.max.mood,   R.medianLabel.mood,
      R.max.social, R.medianLabel.social,
      R.max.energy, R.medianLabel.energy,
      R.max.focus,  R.medianLabel.focus,
      R.max.anxiety,R.medianLabel.anxiety,
      R.max.impair, R.medianLabel.impair
    ];
    const tr = document.createElement("tr");
    tr.innerHTML = row.map((v,i)=>{
      const name = COLS[i];
      if (i===0) return `<td>${v??''}</td>`;
      const num = Number(v);
      const isNum = Number.isFinite(num);
      const bg = isNum && typeof cellBgFor==='function' ? cellBgFor(name.replace(' Label',''), num) : '';
      const val = isNum ? num.toFixed(2) : (v ?? '');
      return `<td${bg?` style="background-color:${bg};"`:''}>${val}</td>`;
    }).join("");
    tbody.appendChild(tr);
  }

  function backfillSignificant5m(){
    const snap = snapshotForSignificant();
    if (!snap.length) return 0;
    const minTs = Math.min(...snap.map(x=>x._ts));
    const now = Date.now();
    const start = new Date(minTs); start.setSeconds(0,0);
    start.setMinutes(start.getMinutes() - (start.getMinutes()%5), 0, 0);
    let added = 0;
    for (let t = start.getTime(); t <= now; t += 5*60000){
      const endMs = t + 5*60000;
      const d = new Date(t);
      const R = computeMaxAndMedianLabels(t, endMs);
      if (!R) continue;
      appendSignificantRow('significant5mTable', d, R);
      added++;
    }
    return added;
  }

  function createSignificant5mPopupTable(){
    ensureSignificant5mPopup();
    const tbody = document.querySelector('#significant5mTable tbody'); if (tbody) tbody.innerHTML='';
    backfillSignificant5m();
    // Cadence every 5 minutes aligned to boundary
    if (window._significant5mTimer) { clearInterval(window._significant5mTimer); window._significant5mTimer = null; }
    const schedule = ()=>{
      const now = new Date();
      const msToNext = (5 - (now.getMinutes()%5))*60000 - now.getSeconds()*1000 - now.getMilliseconds();
      setTimeout(()=>{
        appendLatest();
        window._significant5mTimer = setInterval(appendLatest, (window.CONFIG && CONFIG.popups && CONFIG.popups.significant5m && CONFIG.popups.significant5m.intervalMs) || 5*60000);
      }, Math.max(0, msToNext));
    };
    function appendLatest(){
      const end = new Date(); end.setSeconds(0,0);
      const startMs = end.getTime() - 5*60000;
      const R = computeMaxAndMedianLabels(startMs, end.getTime());
      if (!R) return;
      appendSignificantRow('significant5mTable', end, R);
    }
    schedule();
  }

  function exportSignificant5mCSV(){
    const table = document.getElementById("significant5mTable"); if (!table) return;
    const rows = [COLS.join(",")];
    table.querySelectorAll("tbody tr").forEach(tr=>{
      const vals = Array.from(tr.children).slice(0, COLS.length).map(td=>{
        const t = td.textContent.trim();
        return /[",\n]/.test(t) ? `"${t.replace(/"/g,'""')}"` : t;
      });
      rows.push(vals.join(","));
    });
    const csv = rows.join("\\n");
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8;"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = "summary_significant_5m.csv";
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  }
})();
</script>
<!-- Sliding Average Popup (3-row moving average) -->

<div id="slidingAvgModal">
<button id="slidingAvgClose" onclick="document.getElementById('slidingAvgModal').style.display='none'">Close</button>
<h3 style="margin:0 0 8px 0;">Sliding Average (3-row moving window)</h3>
<table id="slidingAvgTable">
<thead>
<tr>
<th>Time</th><th>Rush</th><th>Mood</th><th>Social</th><th>Energy</th><th>Focus</th><th>Anxiety</th><th>Impair</th><th>Score</th><th>Max</th><th>Min</th><th>Weighted</th><th>5Max</th>
</tr>
</thead>
<tbody></tbody>
</table>
</div>
<script>
(function(){
  function pad(n){ return String(n).padStart(2,'0'); }
  function timeLabel(ms){
    var d = new Date(ms||0);
    return pad(d.getHours())+":"+pad(d.getMinutes())+":"+pad(d.getSeconds());
  }
  // Pulls metric sums + timestamps from MAIN table only (never from summaries)
  function snapshotFromMainTableForSliding(){
    var rows = Array.from(document.querySelectorAll('#logTable tbody tr'));
    return rows.map(function(tr){
      var ts = +(tr.getAttribute('data-ts')||0);
      function get(field){
        var td = tr.querySelector('td[data-field="'+field+'Sum"]');
        if(!td) return 0;
        var v = parseFloat(td.getAttribute('data-value')||td.textContent||'0');
        return Number.isFinite(v) ? v : 0;
      }
      return {
        _ts: ts,
        rush: get('rush'),
        mood: get('mood'),
        social: get('social'),
        energy: get('energy'),
        focus: get('focus'),
        anxiety: get('anxiety'),
        impair: get('impair')
      };
    }).filter(function(o){ return o._ts>0; });
  }
  // Compute composites
  function composites(M){
    var score = (M.rush+M.mood+M.social+M.energy+M.focus) - (M.anxiety+M.impair);
    var max   = (M.rush+M.mood+M.social+M.energy+M.focus);
    var min   = (M.anxiety+M.impair);
    var weighted = computeWeighted(M);
    return {
      score: +score,
      max: +max,
      min: +min,
      weighted: +weighted,
      fiveMax: computeFiveMax(M)};
  }
  function fmt2(x){
    var n = Number(x);
    return Number.isFinite(n) ? n.toFixed(2) : "";
  }
  // Build sliding average rows
  function buildSlidingAverages(){
    var snap = snapshotFromMainTableForSliding();
    var out = [];
    for(var i=0;i<snap.length;i++){
      var start = Math.max(0, i-2);
      var cnt = i - start + 1;
      var sums = {rush:0,mood:0,social:0,energy:0,focus:0,anxiety:0,impair:0};
      for(var j=start;j<=i;j++){
        var r = snap[j];
        sums.rush+=r.rush; sums.mood+=r.mood; sums.social+=r.social; sums.energy+=r.energy;
        sums.focus+=r.focus; sums.anxiety+=r.anxiety; sums.impair+=r.impair;
      }
      var means = {
        rush: sums.rush/cnt, mood: sums.mood/cnt, social: sums.social/cnt,
        energy: sums.energy/cnt, focus: sums.focus/cnt, anxiety: sums.anxiety/cnt, impair: sums.impair/cnt
      };
      var comp = composites(means);
      out.push({ ms: snap[i]._ts, means: means, comp: comp, n: cnt });
    }
    return out;
  }
  // Render table
  window.openSlidingAverage = function(){
    try {
      var modal = document.getElementById('slidingAvgModal');
      var tbody = document.querySelector('#slidingAvgTable tbody');
      if(!tbody){ alert('Sliding Average table missing'); return; }
      tbody.innerHTML = '';
      var rows = buildSlidingAverages();
      rows.forEach(function(row){
        var tr = document.createElement('tr');
        function td(col, val){
          var cell = document.createElement('td');
          cell.textContent = val;
          cell.setAttribute('data-col', col);
          return cell;
        }
        tr.appendChild(td('Time', timeLabel(row.ms) + ' avg(' + row.n + ')'));
        tr.appendChild(td('Rush', fmt2(row.means.rush)));
        tr.appendChild(td('Mood', fmt2(row.means.mood)));
        tr.appendChild(td('Social', fmt2(row.means.social)));
        tr.appendChild(td('Energy', fmt2(row.means.energy)));
        tr.appendChild(td('Focus', fmt2(row.means.focus)));
        tr.appendChild(td('Anxiety', fmt2(row.means.anxiety)));
        tr.appendChild(td('Impair', fmt2(row.means.impair)));
        tr.appendChild(td('Score', fmt2(row.comp.score)));
        tr.appendChild(td('Max', fmt2(row.comp.max)));
        tr.appendChild(td('Min', fmt2(row.comp.min)));
        tr.appendChild(td('Weighted', fmt2(row.comp.weighted)));
        tr.appendChild(td('5Max', fmt2(row.comp.fiveMax)));
        // Apply same colour rules as main table
        try { if (typeof applyRowShading === 'function') applyRowShading(tr); } catch(e){}
        // Respect hidden columns if any
        try { if (typeof applyUiColumnVisibility === 'function') applyUiColumnVisibility(); } catch(e){}
        tbody.appendChild(tr);
      });
      modal.style.display = 'block';
    } catch(e){
      alert('Sliding Average failed: ' + e.message);
    }
  };
})();
</script>
<!-- Auto Slider A & B (auto-appending sliding averages) -->


<script>
(function(){
  function postfillTotalsInTable(tblId){
    try{
      var tbl = document.getElementById(tblId);
      if(!tbl) return;
      var ths = Array.from(tbl.querySelectorAll('thead th')).map(th=>th.textContent.trim());
      // Ensure headers include TotalScore/TotalWeighted (already patched in thead)
      var tbody = tbl.querySelector('tbody');
      if(!tbody) return;
      Array.from(tbody.querySelectorAll('tr')).forEach(function(tr){
        var data = {};
        Array.from(tr.children).forEach(function(td){
          var col = td.getAttribute('data-col') || td.textContent.trim();
          var val = parseFloat(td.getAttribute('data-value')||td.textContent)||NaN;
          data[col] = val;
  });
    }catch(e){}
  }
  // Run after openAutoSlider* calls by hooking them lightly (no-op safe)
  ['autoSliderATable','autoSliderBTable','autoSliderCTable','autoSliderDTable'].forEach(function(id){
    try{ postfillTotalsInTable(id); }catch(e){}
  });
})();
</script>

<div id="autoSliderAModal">
<div class="as-toolbar">
<button onclick="exportAutoSliderCSV('A')">Export CSV</button>
<button onclick="clearAutoSlider('A')">Clear</button>
<button onclick="document.getElementById('autoSliderAModal').style.display='none'">Close</button>
</div>
<h3 style="margin:6px 0;">Auto Slider A (per-minute while Auto is ON)</h3>
<table id="autoSliderATable">
<thead><tr>
<th>Time</th><th>Rush</th><th>Mood</th><th>Social</th><th>Energy</th><th>Focus</th><th>Anxiety</th><th>Impair</th>
<th>Score</th><th>Max</th><th>Min</th><th>Weighted</th><th>5Max</th>
</tr></thead>
<tbody></tbody>
</table>
</div>
<div id="autoSliderBModal">
<div class="as-toolbar">
<button onclick="exportAutoSliderCSV('B')">Export CSV</button>
<button onclick="clearAutoSlider('B')">Clear</button>
<button onclick="document.getElementById('autoSliderBModal').style.display='none'">Close</button>
</div>
<h3 style="margin:6px 0;">Auto Slider B (on addEntry while Auto is ON)</h3>
<table id="autoSliderBTable">
<thead><tr>
<th>Time</th><th>Rush</th><th>Mood</th><th>Social</th><th>Energy</th><th>Focus</th><th>Anxiety</th><th>Impair</th>
<th>Score</th><th>Max</th><th>Min</th><th>Weighted</th><th>5Max</th>
</tr></thead>
<tbody></tbody>
</table>
</div>
<script>
(function(){
  function pad(n){ return String(n).padStart(2,'0'); }
  function timeLabel(ms){ var d=new Date(ms||0); return d.getFullYear()
      +'-'+pad(d.getMonth()+1)+'-'+pad(d.getDate())+' '+pad(d.getHours())+':'+pad(d.getMinutes())+':'+pad(d.getSeconds()); }
  function fmt2(x){ var n=Number(x); return Number.isFinite(n)? n.toFixed(2):""; }

  function snapshotFromMainTableForSliding(){
    var rows = Array.from(document.querySelectorAll('#logTable tbody tr'));
    return rows.map(function(tr){
      var ts = +(tr.getAttribute('data-ts')||0);
      function get(field){
        var td = tr.querySelector('td[data-field="'+field+'Sum"]');
        if(!td) return 0;
        var v = parseFloat(td.getAttribute('data-value')||td.textContent||'0');
        return Number.isFinite(v) ? v : 0;
      }
      return {_ts:ts,
        rush:get('rush'), mood:get('mood'), social:get('social'), energy:get('energy'),
        focus:get('focus'), anxiety:get('anxiety'), impair:get('impair')};
    }).filter(function(o){ return o._ts>0; });
  }
  function composites(M){
    var score=(M.rush+M.mood+M.social+M.energy+M.focus)-(M.anxiety+M.impair);
    var max=(M.rush+M.mood+M.social+M.energy+M.focus);
    var min=(M.anxiety+M.impair);
    var weighted=computeWeighted(M);
    return {score:+score, max:+max, min:+min, weighted:+weighted, fiveMax: computeFiveMax(M)};
  }
  function slidingMeanAtIndex(snap, i){
    var start=Math.max(0,i-2), cnt=i-start+1;
    var sums={rush:0,mood:0,social:0,energy:0,focus:0,anxiety:0,impair:0};
    for(var j=start;j<=i;j++){ var r=snap[j];
      sums.rush+=r.rush; sums.mood+=r.mood; sums.social+=r.social; sums.energy+=r.energy;
      sums.focus+=r.focus; sums.anxiety+=r.anxiety; sums.impair+=r.impair; }
    var means={rush:sums.rush/cnt, mood:sums.mood/cnt, social:sums.social/cnt, energy:sums.energy/cnt,
               focus:sums.focus/cnt, anxiety:sums.anxiety/cnt, impair:sums.impair/cnt};
    return {ms:snap[i]._ts, means:means, comp:composites(means), n:cnt};
  }

  var LS_KEY_A='autoSliderA_rows', LS_KEY_B='autoSliderB_rows';
  function loadRows(w){ var k=w==='A'?LS_KEY_A:LS_KEY_B; try{ return JSON.parse(localStorage.getItem(k)||'[]'); }catch(e){ return []; } }
  function saveRows(w,rows){ var k=w==='A'?LS_KEY_A:LS_KEY_B; try{ localStorage.setItem(k, JSON.stringify(rows)); }catch(e){} }

  function appendRowToModalTable(which, row){
    var tableId = which==='A' ? '#autoSliderATable tbody' : '#autoSliderBTable tbody';
    var tbody = document.querySelector(tableId); if(!tbody) return;
    var tr=document.createElement('tr');
    function td(col,val){ var c=document.createElement('td'); c.textContent=val; c.setAttribute('data-col', col); return c; }
    tr.appendChild(td('Time', timeLabel(row.ms)+' avg('+row.n+')'));
    tr.appendChild(td('Rush', fmt2(row.means.rush)));
    tr.appendChild(td('Mood', fmt2(row.means.mood)));
    tr.appendChild(td('Social', fmt2(row.means.social)));
    tr.appendChild(td('Energy', fmt2(row.means.energy)));
    tr.appendChild(td('Focus', fmt2(row.means.focus)));
    tr.appendChild(td('Anxiety', fmt2(row.means.anxiety)));
    tr.appendChild(td('Impair', fmt2(row.means.impair)));
    tr.appendChild(td('Score', fmt2(row.comp.score)));
    tr.appendChild(td('Max', fmt2(row.comp.max)));
    tr.appendChild(td('Min', fmt2(row.comp.min)));
    tr.appendChild(td('Weighted', fmt2(row.comp.weighted)));
    tr.appendChild(td('5Max', fmt2(row.comp.fiveMax)));
    try{ if(typeof applyRowShading==='function') applyRowShading(tr); }catch(e){}
    try{ if(typeof applyUiColumnVisibility==='function') applyUiColumnVisibility(); }catch(e){}
    tbody.appendChild(tr);
  }

  window.exportAutoSliderCSV = function(which){
    var rows = loadRows(which);
    var header = ["Time","Rush","Mood","Social","Energy","Focus","Anxiety","Impair","Score","Max","Min","Weighted","5Max","N"];
    var lines = [header.join(",")];
    rows.forEach(function(r){
      var tt = timeLabel(r.ms);
      lines.push([tt, r.means.rush, r.means.mood, r.means.social, r.means.energy, r.means.focus, r.means.anxiety, r.means.impair,
                  r.comp.score, r.comp.max, r.comp.min, r.comp.weighted, r.comp.fiveMax, r.n]
                 .map(function(x){ var s=String(Number.isFinite(+x)?(+x).toFixed(2):x); return '"'+s.replace(/"/g,'""')+'"'; }).join(","));
    });
    var blob = new Blob([lines.join("\n")], {type:"text/csv"});
    var url = URL.createObjectURL(blob), a=document.createElement('a');
    a.href=url; a.download = (which==='A'?'auto_slider_A':'auto_slider_B') + ".csv"; a.click(); URL.revokeObjectURL(url);
  };
  window.clearAutoSlider = function(which){
    saveRows(which, []);
    var sel = which==='A' ? '#autoSliderATable tbody' : '#autoSliderBTable tbody';
    var tb = document.querySelector(sel); if (tb) tb.innerHTML='';
  };

  window.openAutoSliderA = function(){
    var rows = loadRows('A') || [];
    var tb = document.querySelector('#autoSliderATable tbody');
    if (!tb) return;
    tb.innerHTML = '';

    if (!rows.length) {
      try {
        var snap = snapshotFromMainTableForSliding();
        if (snap && snap.length) {
          var row = slidingMeanAtIndex(snap, snap.length - 1);
          rows.push(row);
          saveRows('A', rows);
        }
      } catch (e) {
        console.warn('openAutoSliderA compute error', e);
      }
    }

    rows.forEach(function(r){
      appendRowToModalTable('A', r);
    });

    var modal = document.getElementById('autoSliderAModal');
    if (modal) modal.style.display = 'block';
  };
  
window.openAutoSliderB = function(){
    var rows = loadRows('B');
    var tb = document.querySelector('#autoSliderBTable tbody'); if(tb){ tb.innerHTML=''; rows.forEach(function(r){ appendRowToModalTable('B', r); }); }
    document.getElementById('autoSliderBModal').style.display='block';
  };

  var autoSliderATimer=null;
  function emitAutoSliderA(){
    var snap=snapshotFromMainTableForSliding(); if(!snap.length) return;
    var row=slidingMeanAtIndex(snap, snap.length-1);
    var rows=loadRows('A'); rows.push(row); saveRows('A', rows);
    appendRowToModalTable('A', row);
  }
  function startAutoSliderA(){
    if (autoSliderATimer) return;
    var now=Date.now(), delay=60000-(now%60000);
    autoSliderATimer=setTimeout(function kick(){ emitAutoSliderA(); autoSliderATimer=setInterval(emitAutoSliderA,60000); }, delay);
  }
  function stopAutoSliderA(){
    if (autoSliderATimer && typeof autoSliderATimer==='number'){ clearTimeout(autoSliderATimer); }
    if (autoSliderATimer && typeof autoSliderATimer==='object'){ clearInterval(autoSliderATimer); }
    autoSliderATimer=null;

  window.autoSliderAStart = startAutoSliderA;
  window.autoSliderAStop = stopAutoSliderA;

  }

  var _origAddEntry = window.addEntry;
  window.addEntry = function(){
    if (typeof _origAddEntry === 'function'){ _origAddEntry.apply(this, arguments); }
    try {
      if (window.autoSummaryActive){
        var snap = snapshotFromMainTableForSliding();
        if(snap.length){
          var row = slidingMeanAtIndex(snap, snap.length-1);
          var rows = loadRows('B'); rows.push(row); saveRows('B', rows);
          appendRowToModalTable('B', row);
        }
      }
    } catch(e){ console.warn('Auto Slider B hook failed:', e); }
  };

  var lastAuto=!!window.autoSummaryActive;
  function pollAuto(){
    var cur=!!window.autoSummaryActive;
    if (cur!==lastAuto){
      if (cur){ startAutoSliderA(); } else { stopAutoSliderA(); }
      lastAuto=cur;
    }
  }
  setInterval(function(){ try{ if (typeof emitAuto1m==='function') emitAuto1m(); }catch(e){} }, 60000);
  try{ if (window.autoSummaryActive) startAutoSliderA(); }catch(e){}
  try{ ['A','B'].forEach(function(k){ var rows=loadRows(k); rows.forEach(function(r){ appendRowToModalTable(k, r); }); }); }catch(e){}
})();
</script>
<!-- ===== Label Settings & CSV Import/Export (Option C + Option 4) ===== -->

<button id="labelGearBtn" title="Label Settings">⚙️</button>
<div aria-hidden="true" id="labelSettingsModal">
<div aria-labelledby="ls-title" aria-modal="true" id="labelSettingsCard" role="dialog">
<h2 id="ls-title">Label Settings</h2>
<div id="ls-tabs">
<button class="active" data-tab="labels">Labels</button>
<button data-tab="buttons">Button Sets</button>
<button data-tab="importExport">Import / Export</button>
</div>
<div class="ls-panel active" id="ls-panel-labels">
<div class="ls-row">
<label>Metric</label>
<select id="ls-metric"></select>
</div>
<div class="ls-row">
<label>Value</label>
<select id="ls-value"></select>
</div>
<div class="ls-row">
<label>Label text</label>
<input id="ls-label" placeholder="e.g., High, +, −" type="text"/>
</div>
<div class="ls-controls">
<button id="ls-save">Save</button>
<button id="ls-resetMetric">Reset Metric</button>
<button id="ls-resetAll">Reset All</button>
</div>
</div>
<div class="ls-panel" id="ls-panel-buttons">
<div class="ls-row">
<label>Metric</label>
<select id="bs-metric"></select>
</div>
<div class="ls-row">
<label>Values (comma-separated)</label>
<input id="bs-values" placeholder="e.g., 6,,2.5,2,1,0.5,0,-0.5" type="text"/>
</div>
<div class="ls-controls">
<button id="bs-save">Save Button Set</button>
<button id="bs-reset">Reset Metric Buttons</button>
</div>
</div>
<div class="ls-panel" id="ls-panel-importExport">
<div class="ls-controls">
<button id="ls-export">Export labels CSV</button>
<input accept=".csv,text/csv" id="ls-importFile" style="display:none" type="file"/>
<button id="ls-import">Import labels CSV</button>
<button disabled="" id="ls-applyImport">Apply Import</button>
</div>
<div id="ls-preview"></div>
</div>
<div class="ls-controls" style="justify-content:flex-end; margin-top: 11px;">
<button id="ls-close">Close</button>
</div>
</div>
</div>
<script>
(() => {
  // ====== Storage helpers ======
  const OV_KEY = 'labelOverrides_';
  const BS_KEY = 'metricButtonOrder';
  function loadOverrides() {
    try { return JSON.parse(localStorage.getItem(OV_KEY) || '{}'); } catch(e) { return {}; }
  }
  function saveOverrides(obj) {
    localStorage.setItem(OV_KEY, JSON.stringify(obj || {}));
  }
  function loadButtonSets() {
    try { return JSON.parse(localStorage.getItem(BS_KEY) || '{}'); } catch(e) { return {}; }
  }
  function saveButtonSets(obj) {
    localStorage.setItem(BS_KEY, JSON.stringify(obj || {}));
  }

  // ====== Label resolution ======
  function getLabel(metric, valueStr) {
    try{
      const m = String(metric||'').toLowerCase();
      const v = String(valueStr);
      const ov = loadOverrides();
      if (ov[m] && ov[m].hasOwnProperty(v)) return ov[m][v];
      if (typeof LABEL_OVERRIDES === 'object' && LABEL_OVERRIDES && LABEL_OVERRIDES[m] && LABEL_OVERRIDES[m].hasOwnProperty(v)) return LABEL_OVERRIDES[m][v];
      if (typeof labelMappings === 'object' && labelMappings && labelMappings[m] && labelMappings[m].hasOwnProperty(v)) return labelMappings[m][v];
      return '';
    }catch(e){ return ''; }
  }

  // Post-process buttons to ensure labels follow overrides (keeps numeric visible)
  function applyButtonLabels() {
    const cols = document.querySelectorAll('.score-column');
    cols.forEach(col => {
      const metricTitleEl = col.querySelector('strong');
      if (!metricTitleEl) return;
      const metric = metricTitleEl.textContent.trim().toLowerCase();
      col.querySelectorAll('button').forEach(btn => {
        // Expect formats like "3: High" or "3 High" or just "3"
        const raw = btn.textContent.trim();
        // Try to extract leading numeric
        let m = raw.match(/^(-?\d+(?:\.\d+)?)/);
        let valueStr = m ? m[1] : (btn.dataset && btn.dataset.value ? String(btn.dataset.value) : '');
        if (!valueStr) return;
        const lbl = getLabel(metric, valueStr);
        // Keep numeric + label per user's instruction (do NOT hide numbers)
        if (lbl) {
          btn.textContent = `${valueStr}: ${lbl}`;
        } else {
          btn.textContent = `${valueStr}`;
        }
        btn.dataset.value = valueStr; // ensure stored
  });
  }

  // Wrap original buildButtons so we can re-label after render without touching core logic
  try {
    if (typeof window.buildButtons === 'function' && !window._origBuildButtons) {
      window._origBuildButtons = window.buildButtons;
      window.buildButtons = function() {
        const r = window._origBuildButtons.apply(this, arguments);
        try { applyButtonLabels(); } catch(e) {}
        return r;
      };
    } else {
      // If buildButtons not yet defined, try later
      document.addEventListener('DOMContentLoaded', () => setTimeout(applyButtonLabels, 0));
    }
  } catch(e){}

  // ====== Defaults object for optional project-level overrides (empty by default) ======
  window.LABEL_OVERRIDES = window.LABEL_OVERRIDES || {};

  // ====== UI wiring ======
  const gear = document.getElementById('labelGearBtn');
  const modal = document.getElementById('labelSettingsModal');
  const closeBtn = document.getElementById('ls-close');
  const metricSel = document.getElementById('ls-metric');
  const valueSel = document.getElementById('ls-value');
  const labelInp = document.getElementById('ls-label');
  const saveBtn = document.getElementById('ls-save');
  const resetMetricBtn = document.getElementById('ls-resetMetric');
  const resetAllBtn = document.getElementById('ls-resetAll');

  const bsMetric = document.getElementById('bs-metric');
  const bsValues = document.getElementById('bs-values');
  const bsSave = document.getElementById('bs-save');
  const bsReset = document.getElementById('bs-reset');

  const exportBtn = document.getElementById('ls-export');
  const importBtn = document.getElementById('ls-import');
  const importFile = document.getElementById('ls-importFile');
  const applyImportBtn = document.getElementById('ls-applyImport');
  const previewBox = document.getElementById('ls-preview');

  // Tabs
  const tabs = document.querySelectorAll('#ls-tabs button');
  const panels = {
    labels: document.getElementById('ls-panel-labels'),
    buttons: document.getElementById('ls-panel-buttons'),
    importExport: document.getElementById('ls-panel-importExport')
  };
  tabs.forEach(b=>b.addEventListener('click', () => {
    tabs.forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    Object.values(panels).forEach(p=>p.classList.remove('active'));
    panels[b.dataset.tab].classList.add('active');
  }));

  function openModal(){ modal.style.display = 'flex'; refreshSelectors(); }
  function closeModal(){ modal.style.display = 'none'; }

  gear.addEventListener('click', openModal);
  closeBtn.addEventListener('click', closeModal);
  modal.addEventListener('click', (e)=>{ if (e.target === modal) closeModal(); });

  function listMetrics(){
    // Prefer the global 'metrics' array if available; else derive from labelMappings keys
    let arr = Array.isArray(window.metrics) ? window.metrics.slice() : [];
    if (!arr.length && window.labelMappings) arr = Object.keys(window.labelMappings);
    return arr.map(s=>String(s).toLowerCase());
  }
  function valuesForMetric(m){
    // Use configured button set when available; fallback to labelMappings keys
    try{
      if (typeof getMetricButtons === 'function') {
        const vals = getMetricButtons(m) || [];
        return vals.map(v => String(v));
      }
    }catch(e){}
    if (window.labelMappings && window.labelMappings[m]) {
      return Object.keys(window.labelMappings[m]);
    }
    return [];
  }
  function refreshSelectors(){
    const mets = listMetrics();
    metricSel.innerHTML = mets.map(x=>`<option value="${x}">${x}</option>`).join('');
    bsMetric.innerHTML = metricSel.innerHTML;
    const m = mets[0] || '';
    refreshValues(m);
    refreshButtonSet(m);
  }
  function refreshValues(metric){
    const vals = valuesForMetric(metric);
    valueSel.innerHTML = vals.map(v=>`<option value="${v}">${v}</option>`).join('');
    // preload label
    const v = vals[0] || '';
    labelInp.value = getLabel(metric, v);
  }
  function refreshButtonSet(metric){
    try{
      const current = (typeof getMetricButtons === 'function') ? getMetricButtons(metric) : [];
      bsValues.value = Array.isArray(current) ? current.join(',') : '';
    }catch(e){ bsValues.value = ''; }
  }

  metricSel.addEventListener('change', ()=>{
    refreshValues(metricSel.value);
  });
  valueSel.addEventListener('change', ()=>{
    labelInp.value = getLabel(metricSel.value, valueSel.value);
  });

  saveBtn.addEventListener('click', ()=>{
    const m = metricSel.value;
    const v = valueSel.value;
    const t = labelInp.value;
    const ov = loadOverrides();
    if (!ov[m]) ov[m] = {};
    ov[m][v] = t;
    saveOverrides(ov);
    applyButtonLabels();
    alert('Saved.');
  });
  resetMetricBtn.addEventListener('click', ()=>{
    const m = metricSel.value;
    const ov = loadOverrides();
    if (ov[m]) delete ov[m];
    saveOverrides(ov);
    applyButtonLabels();
    alert('Metric overrides cleared.');
  });
  resetAllBtn.addEventListener('click', ()=>{
    saveOverrides({});
    applyButtonLabels();
    alert('All overrides cleared.');
  });

  // Button sets (per metric)
  bsMetric.addEventListener('change', ()=> refreshButtonSet(bsMetric.value));
  bsSave.addEventListener('click', ()=>{
    const m = bsMetric.value;
    const raw = bsValues.value.trim();
    const arr = raw ? raw.split(',').map(s=>Number(s.trim())).filter(x=>!Number.isNaN(x)) : [];
    const bs = loadButtonSets();
    bs[m] = arr;
    saveButtonSets(bs);
    if (typeof buildButtons === 'function') buildButtons();
    else applyButtonLabels();
    alert('Button set saved.');
  });
  bsReset.addEventListener('click', ()=>{
    const m = bsMetric.value;
    const bs = loadButtonSets();
    if (bs[m]) delete bs[m];
    saveButtonSets(bs);
    if (typeof buildButtons === 'function') buildButtons();
    else applyButtonLabels();
    alert('Metric button set reset.');
  });

  // Export CSV
  exportBtn.addEventListener('click', ()=>{
    const mets = listMetrics();
    let rows = [['metric','value','label','source']];
    const ov = loadOverrides();
    mets.forEach(metric=>{
      const vals = valuesForMetric(metric);
      vals.forEach(v=>{
        const label = getLabel(metric, v);
        let source = 'fallthrough';
        if (ov[metric] && ov[metric].hasOwnProperty(v)) source = 'localStorage';
        else if (typeof LABEL_OVERRIDES === 'object' && LABEL_OVERRIDES[metric] && LABEL_OVERRIDES[metric].hasOwnProperty(v)) source = 'defaultOverride';
        else if (labelMappings && labelMappings[metric] && labelMappings[metric].hasOwnProperty(v)) source = 'defaultMap';
        rows.push([metric, v, label, source]);
  });
    const csv = rows.map(r=>r.map(x=>`"${String(x).replace(/"/g,'""')}"`).join(',')).join('\n');
    const blob = new Blob([`version=1\n` + csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'label_overrides.csv';
    a.click();
    URL.revokeObjectURL(a.href);
  });

  // Import CSV with preview
  let pendingImport = null;
  importBtn.addEventListener('click', ()=> importFile.click());
  importFile.addEventListener('change', async ()=>{
    const f = importFile.files && importFile.files[0];
    if (!f) return;
    const txt = await f.text();
    const lines = txt.split(/\r?\n/).filter(Boolean);
    // optional header line like "version=1"
    if (lines[0] && /^version=/.test(lines[0])) lines.shift();
    const header = lines.shift();
    if (!header) { alert('Invalid CSV: missing header'); return; }
    const cols = header.split(',').map(s=>s.replace(/^"+|"+$/g,'').trim().toLowerCase());
    const idxMetric = cols.indexOf('metric');
    const idxValue  = cols.indexOf('value');
    const idxLabel  = cols.indexOf('label');
    if (idxMetric<0 || idxValue<0 || idxLabel<0) { alert('Invalid header. Need metric,value,label'); return; }
    const items = [];
    lines.forEach(line=>{
      const parts = line.split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/).map(s=>s.replace(/^"+|"+$/g,'').replace(/""/g,'"'));
      const metric = (parts[idxMetric]||'').toLowerCase();
      const value = (parts[idxValue]||'');
      const label = (parts[idxLabel]||'');
      if (!metric || value==='') return;
      items.push({metric, value, label});
    });
    pendingImport = items;
    applyImportBtn.disabled = !pendingImport.length;
    // Preview
    previewBox.innerHTML = '<strong>Preview ('+pendingImport.length+' rows):</strong><br/>' +
      '<div style="display:grid;grid-template-columns:120px 100px 1fr;gap:6px;font-family:monospace;">' +
      '<div><em>metric</em></div><div><em>value</em></div><div><em>label</em></div>' +
      pendingImport.slice(0,200).map(it=>`<div>${it.metric}</div><div>${it.value}</div><div>${it.label}</div>`).join('') +
      (pendingImport.length>200 ? `<div style="grid-column:1/-1;color:#888;">... ${pendingImport.length-200} more</div>`:'' ) +
      '</div>';
  });

  applyImportBtn.addEventListener('click', ()=>{
    if (!pendingImport || !pendingImport.length) return;
    const ov = loadOverrides();
    pendingImport.forEach(({metric, value, label})=>{
      if (!ov[metric]) ov[metric] = {};
      ov[metric][String(value)] = String(label);
    });
    saveOverrides(ov);
    pendingImport = null;
    applyImportBtn.disabled = true;
    previewBox.innerHTML = '<em>Applied.</em>';
    if (typeof buildButtons === 'function') buildButtons();
    else applyButtonLabels();
  });

  // init
  document.addEventListener('DOMContentLoaded', ()=>{
    // Populate selectors lazily when opening
  });

})();</script>
<!-- ===== End Label Settings ===== -->
<script>
// === CSV + Rapid provenance patch ===

// Helper: map a numeric value to Rapid label for a metric
function getRapidLabel(metric, value){
  try{
    const key = String(value);
    if (typeof RAPID_LABEL_OVERRIDES !== 'undefined' &&
        RAPID_LABEL_OVERRIDES &&
        RAPID_LABEL_OVERRIDES[metric] &&
        RAPID_LABEL_OVERRIDES[metric][key] != null){
      return RAPID_LABEL_OVERRIDES[metric][key];
    }
    // Fallback to main labelMappings if no rapid override
    if (typeof labelMappings !== 'undefined' && labelMappings[metric]){
      return labelMappings[metric][value] || '';
    }
  }catch(e){}
  return '';
}

// After addEntry() (when called from Rapid), force the latest row to use Rapid labels
function finalizeRapidEntryAsRapid(){
  try{
    if (!Array.isArray(logData) || logData.length === 0) return;
    const entry = logData[logData.length - 1];
    if (!entry) return;
    // mark provenance
    entry.inputSource = 'Rapid';
    // ensure label fields reflect Rapid labels based on stored (mapped) values
    const ms = ['rush','mood','social','energy','focus','anxiety','impair'];
    ms.forEach(m => {
      try{
        const arr = Array.isArray(entry[m]) ? entry[m] : [];
        const labs = [];
        // build unique, sorted desc, similar to getLabels()
        const vals = Array.from(new Set(arr.slice().sort((a,b)=>b-a)));
        vals.forEach(v => {
          const L = getRapidLabel(m, v);
          if (L) labs.push(L);
        });
        entry[m + 'Label'] = labs.join(', ');
      }catch(e){}
    });
    // persist + refresh
    try { setTripLogDebounced(logData); } catch(e){}
    try { renderTable(); } catch(e){}
  }catch(e){ console.warn(e); }
}

// Wrapper: Apply selections, add entry, set Rapid provenance, close popup
function applyRapidScoresAndAdd(){
  try {
    if (typeof applyRapidScores === 'function') applyRapidScores(); // dedupe + (may) close modal
    // Set provenance flags (for any code reading them)
    window._rapidLabelMode = true;
    window._rapidInputSource = 'Rapid';
    // Add the entry
    if (typeof addEntry === 'function') addEntry('rapid');
    // Post-fix labels to Rapid set
    finalizeRapidEntryAsRapid();
    // clear flags
    window._rapidLabelMode = false;
    window._rapidInputSource = 'Main';
    // ensure modal is closed
    try { closeRapidScores(); } catch(e){}
  } catch(e){ console.warn(e); }
}

// Wrapper: Apply selections, add entry, set Rapid provenance, keep popup open
function applyRapidScoresAndAddStay(){
  try {
    // don't close the modal; just build buttons
    if (typeof RAPID_METRICS !== 'undefined'){
      // standardize and dedupe selections
      RAPID_METRICS.forEach(f => {
        if (!Array.isArray(selections[f])) selections[f] = [];
        selections[f] = Array.from(new Set(selections[f])).sort((a,b)=>b-a);
      });
    }
    window._rapidLabelMode = true;
    window._rapidInputSource = 'Rapid';
    if (typeof addEntry === 'function') addEntry();
    finalizeRapidEntryAsRapid();
    window._rapidLabelMode = false;
    window._rapidInputSource = 'Main';
    // rebuild rapid UI & keep open
    try { if (typeof buildRapidScoresButtons === 'function') buildRapidScoresButtons(); } catch(e){}
    try { const m = document.getElementById('rapidScoresModal'); if (m) m.style.display = 'block'; } catch(e){}
  } catch(e){ console.warn(e); }
}

// Override exportCSV to include "Input Source" as final column and ensure robustness
(function(){
  try{
    const _oldExportCSV = typeof exportCSV === 'function' ? exportCSV : null;
  }catch(e){}
  window.exportCSV = function(){
    try {
      const metrics = CONFIG.core.metrics;
      const header = ["Timestamp","Since Dose","Elapsed","Info","Scale","Drug","Qty","ROA"];
      metrics.forEach(f => header.push(f.charAt(0).toUpperCase()+f.slice(1)+" Sum", f.charAt(0).toUpperCase()+f.slice(1)+" Label"));
      header.push("Score","Max","Min","Max %","Min %","Valence","scaleMood","scaleBad","scaleFocus","Custom Notes","Notes","Weighted","Score5","Good Sum","Input Source");
      const rows = [header.join(",")];
      if (!Array.isArray(logData)) return;
      logData.forEach(r => {
        const L = [r.timestamp||"", r.sincedose||"", r.elapsed||"", r.info||"", r.scale||"", r.drug||"", r.qty||"", r.roa||""];
        metrics.forEach(f => {
          const sum = +r[f+"Sum"] || 0;
          const lab = r[f+"Label"] || "";
          L.push(sum.toFixed(2), lab);
        });
        L.push(
          (+r.score||0).toFixed(2), (+r.max||0).toFixed(2), (+r.min||0).toFixed(2),
          (r.maxPercent!=null ? r.maxPercent : 0),
          (r.minPercent!=null ? r.minPercent : 0),
          (+r.valence||0).toFixed(2),
          (+r.scaleMood||0).toFixed(2),
          (+r.scaleBad||0).toFixed(2),
          (+r.scaleFocus||0).toFixed(2),
          r.customNotes || '', r.notes || '',
          (+r.weighted||0).toFixed(2),
          ((+r.score||0)/10).toFixed(2),
          (+r.goodSum||0).toFixed(2),
          (r.inputSource || 'Main')
        );
        rows.push(L.map(x => '\"' + String(x).replace(/\"/g,'\"\"') + '\"').join(","));
      });
      const blob = new Blob([rows.join("\n")], {type:"text/csv"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "log.csv";
      a.click();
      URL.revokeObjectURL(url);
    } catch(err){
      alert("Export failed: " + (err && err.message ? err.message : err));
      console.error(err);
    }
  };
})();
</script>

<!-- Quick openers for new Auto Sliders -->
<div style="position:fixed; right: 16px; bottom: 16px; z-index: 9999;">
  <button onclick="openModal('#autoSliderCModal')" title="Open Auto Slider C">Auto C</button>
  <button onclick="openModal('#autoSliderDModal')" title="Open Auto Slider D">Auto D</button>
</div>

<!-- ============================== -->
<!-- Auto Slider C Popup (Most recent 5 non-auto rows) -->
<div id="autoSliderCModal" class="modal" style="display:none;">
  <div class="modal-content" style="max-width: 95vw;">
    <span class="close" data-close="#autoSliderCModal">&times;</span>
    <h2>Auto Slider C — Last 5 Non‑Auto Rows</h2>
    <div style="margin: 8px 0;">
      <button id="autoCRefreshBtn">Refresh now</button>
      <span id="autoCStatus" style="margin-left:11px; font-size:0.9em; opacity:0.8;"></span>
    </div>
    <table id="autoCTable" class="table compact">
      <thead>
        <tr id="autoCHead"><th>Timestamp</th><th>Drug</th><th>Qty</th><th>ROA</th><th>Rush Sum</th><th>Mood Sum</th><th>Social Sum</th><th>Energy Sum</th><th>Focus Sum</th><th>Anxiety Sum</th><th>Impair Sum</th><th>Change Label</th><th>Degree Label</th><th>Other Label</th><th>Weighted</th><th>Score5</th><th>Input Source</th></tr>
      </thead>
      <tbody id="autoCBody"></tbody>
      <tfoot>
        <tr id="autoCSummary"><td colspan="17">Summary will appear here.</td></tr>
      </tfoot>
    </table>
  </div>
</div>

<!-- Auto Slider D Popup (Rolling average of last 2 rows, append every 30s) -->
<div id="autoSliderDModal" class="modal" style="display:none;">
  <div class="modal-content" style="max-width: 95vw;">
    <span class="close" data-close="#autoSliderDModal">&times;</span>
    <h2>\1 3\2 (auto every 30s)</h2>
    <div style="margin: 8px 0;">
      <button id="autoDForceAppend">Append now</button>
      <span id="autoDStatus" style="margin-left:11px; font-size:0.9em; opacity:0.8;"></span>
    </div>
    <table id="autoDTable" class="table compact">
      <thead>
        <tr><th>Appended At</th><th>Avg Rush</th><th>Avg Mood</th><th>Avg Social</th><th>Avg Energy</th><th>Avg Focus</th><th>Avg Anxiety</th><th>Avg Impair</th><th>Weighted</th><th>Score5</th><th>Good Sum</th></tr>
      </thead>
      <tbody id="autoDBody"></tbody>
    </table>
  </div>
</div>



<script>
// ===== Utility: open/close modals
(function(){
  document.addEventListener('click', function(e){
    var tgt = e.target;
    if (tgt.matches('[data-close]')) {
      var sel = tgt.getAttribute('data-close');
      var m = document.querySelector(sel);
      if (m) m.style.display = 'none';
    }
  });
  window.openModal = function(sel){
    var m = document.querySelector(sel);
    if (m) m.style.display = 'block';
  };
})();

// ===== Utility: find column indexes by header text in #logTable
function getLogTableColumnMap(){
  var map = {};
  var ths = document.querySelectorAll('#logTable thead th');
  ths.forEach(function(th, idx){
    var name = (th.textContent || '').trim();
    if (name) map[name] = idx;
  });
  return map;
}
// Robust metric column resolver
function resolveMetricIndex(colMap, headerCells, rowEl, baseName){
  if (colMap[baseName + ' Sum'] != null) return colMap[baseName + ' Sum'];
  var idxs = []; headerCells.forEach(function(h,i){ if (h === baseName) idxs.push(i); });
  if (!idxs.length) return colMap[baseName];
  var tr = rowEl;
  if (!tr){
    var tb = document.querySelector('#logTable tbody');
    tr = tb && tb.querySelector('tr') ? tb.querySelector('tr') : null;
  }
  function isNum(t){ var s=String(t||'').trim(); var x=parseFloat(s); return s && !isNaN(x); }
  for (var k=0;k<idxs.length;k++){
    var i=idxs[k]; var cell=tr&&tr.children&&tr.children[i]? tr.children[i].textContent:null;
    if (isNum(cell)) return i;
  }
  return idxs[idxs.length-1];
}


// ===== Utility: get all visible data rows from #logTable
function getLogRows(){
  var rows = Array.from(document.querySelectorAll('#logTable tbody tr')).filter(function(tr){
    return tr.offsetParent !== null; // visible
  });
  return rows;
}

// ===== Utility: extract row object from a table row using column map
function rowToObj(tr, col){
  var c = tr.children;
  function cell(name){
    var idx = col[name];
    return (idx != null && c[idx]) ? (c[idx].textContent || '').trim() : '';
  }
  function num(name){
    var v = cell(name);
    var x = parseFloat(v);
    return isNaN(x) ? 0 : x;
  }
  return {
    Timestamp: cell('Timestamp'),
    Drug: cell('Drug'),
    Qty: parseFloat(cell('Qty')) || 0,
    ROA: cell('ROA'),
    Rush:(function(){var hs=Array.from(document.querySelectorAll('#logTable thead th')).map(t=>t.textContent.trim());var i=resolveMetricIndex(col,hs,tr,'Rush');return i!=null?(parseFloat(c[i].textContent)||0):0;})(),
    Mood:(function(){var hs=Array.from(document.querySelectorAll('#logTable thead th')).map(t=>t.textContent.trim());var i=resolveMetricIndex(col,hs,tr,'Mood');return i!=null?(parseFloat(c[i].textContent)||0):0;})(),
    Social:(function(){var hs=Array.from(document.querySelectorAll('#logTable thead th')).map(t=>t.textContent.trim());var i=resolveMetricIndex(col,hs,tr,'Social');return i!=null?(parseFloat(c[i].textContent)||0):0;})(),
    Energy:(function(){var hs=Array.from(document.querySelectorAll('#logTable thead th')).map(t=>t.textContent.trim());var i=resolveMetricIndex(col,hs,tr,'Energy');return i!=null?(parseFloat(c[i].textContent)||0):0;})(),
    Focus:(function(){var hs=Array.from(document.querySelectorAll('#logTable thead th')).map(t=>t.textContent.trim());var i=resolveMetricIndex(col,hs,tr,'Focus');return i!=null?(parseFloat(c[i].textContent)||0):0;})(),
    Anxiety:(function(){var hs=Array.from(document.querySelectorAll('#logTable thead th')).map(t=>t.textContent.trim());var i=resolveMetricIndex(col,hs,tr,'Anxiety');return i!=null?(parseFloat(c[i].textContent)||0):0;})(),
    Impair:(function(){var hs=Array.from(document.querySelectorAll('#logTable thead th')).map(t=>t.textContent.trim());var i=resolveMetricIndex(col,hs,tr,'Impair');return i!=null?(parseFloat(c[i].textContent)||0):0;})(),
    ChangeLabel: cell('Change Label'),
    DegreeLabel: cell('Degree Label'),
    OtherLabel: cell('Other Label'),
    Weighted: parseFloat(cell('Weighted')) || 0,
    Score5: parseFloat(cell('Score5')) || 0,
    GoodSum: num('Good Sum'),
    InputSource: cell('Input Source')
  };
}

// ===== Auto Slider C: last 5 non-auto rows (exclude Input Source that starts with "Auto")
function refreshAutoSliderC(){
  var status = document.getElementById('autoCStatus');
  var body = document.getElementById('autoCBody');
  var summary = document.getElementById('autoCSummary');
  if (!body || !summary){ return; }

  var col = getLogTableColumnMap();
  var rows = getLogRows().map(function(tr){ return rowToObj(tr, col); });
  var nonAuto = rows.filter(function(r){
    return !(r.InputSource || '').toLowerCase().startsWith('auto');
  });
  var last5 = nonAuto.slice(-5);
  body.innerHTML = '';
  last5.forEach(function(r){
    var tr = document.createElement('tr');
    tr.innerHTML = [
      r.Timestamp, r.Drug, r.Qty, r.ROA,
      r.Rush.toFixed(1), r.Mood.toFixed(1), r.Social.toFixed(1), r.Energy.toFixed(1),
      r.Focus.toFixed(1), r.Anxiety.toFixed(1), r.Impair.toFixed(1),
      r.ChangeLabel, r.DegreeLabel, r.OtherLabel,
      r.Weighted.toFixed(1), r.Score5.toFixed(1), r.InputSource
    ].map(function(v){ return '<td>'+v+'</td>'; }).join('');
    body.appendChild(tr);
  });

  // Summary (means and span)
  function mean(arr){ if (!arr.length) return 0; return arr.reduce((a,b)=>a+b,0)/arr.length; }
  var mRush = mean(last5.map(r=>r.Rush));
  var mMood = mean(last5.map(r=>r.Mood));
  var mSoc  = mean(last5.map(r=>r.Social));
  var mEn   = mean(last5.map(r=>r.Energy));
  var mFoc  = mean(last5.map(r=>r.Focus));
  var mAnx  = mean(last5.map(r=>r.Anxiety));
  var mImp  = mean(last5.map(r=>r.Impair));
  var mW    = mean(last5.map(r=>r.Weighted));
  var mS5   = mean(last5.map(r=>r.Score5));
  summary.innerHTML = '<td colspan="17">Averages over last 5 non-auto rows — Rush '
    + mRush.toFixed(2)+', Mood '+mMood.toFixed(2)+', Social '+mSoc.toFixed(2)
    +', Energy '+mEn.toFixed(2)+', Focus '+mFoc.toFixed(2)+', Anxiety '+mAnx.toFixed(2)
    +', Impair '+mImp.toFixed(2)+', Weighted '+mW.toFixed(2)+', Score5 '+mS5.toFixed(2)+'</td>';

  if (status){
    var ts = new Date();
    status.textContent = 'Updated at ' + ts.toLocaleTimeString();
  }
}

// ===== Auto Slider D: append rolling average of last 2 rows every 30 seconds
var autoDTimer = null;
function computeAndAppendAutoD(){
  var body = document.getElementById('autoDBody');
  var status = document.getElementById('autoDStatus');
  if (!body){ return; }
  var col = getLogTableColumnMap();
  var rows = getLogRows().map(function(tr){ return rowToObj(tr, col); });
  if (rows.length < 2){ return; }
  var dRows = (window.CONFIG && CONFIG.popups && CONFIG.popups.autoSliderD && CONFIG.popups.autoSliderD.windowRows) || 2;
  var last2 = rows.slice(-dRows);
  function mean(arr){ if (!arr.length) return 0; return arr.reduce((a,b)=>a+b,0)/arr.length; }
  var mRush = mean(last2.map(r=>r.Rush));
  var mMood = mean(last2.map(r=>r.Mood));
  var mSoc  = mean(last2.map(r=>r.Social));
  var mEn   = mean(last2.map(r=>r.Energy));
  var mFoc  = mean(last2.map(r=>r.Focus));
  var mAnx  = mean(last2.map(r=>r.Anxiety));
  var mImp  = mean(last2.map(r=>r.Impair));
  var mW    = mean(last2.map(r=>r.Weighted));
  var mS5   = mean(last2.map(r=>r.Score5));
  var gSum  = mean(last2.map(r=>r.GoodSum));

  var tr = document.createElement('tr');
  tr.innerHTML = [
    new Date().toLocaleTimeString(), mRush.toFixed(2), mMood.toFixed(2), mSoc.toFixed(2),
    mEn.toFixed(2), mFoc.toFixed(2), mAnx.toFixed(2), mImp.toFixed(2),
    mW.toFixed(2), mS5.toFixed(2), gSum.toFixed(2)
  ].map(function(v){ return '<td>'+v+'</td>'; }).join('');
  body.appendChild(tr);

  if (status){
    var ts = new Date();
    status.textContent = 'Appended at ' + ts.toLocaleTimeString();
  }
}

function startAutoD(){
  if (autoDTimer) clearInterval(autoDTimer);
  autoDTimer = setInterval(computeAndAppendAutoD, (window.CONFIG && CONFIG.popups && CONFIG.popups.autoSliderD && CONFIG.popups.autoSliderD.intervalMs) || 30000); // every 30s
}

// Hook up buttons and auto-refreshes
window.addEventListener('load', function(){
  var btnC = document.getElementById('autoCRefreshBtn');
  if (btnC) btnC.addEventListener('click', refreshAutoSliderC);
  // also refresh C every 15s
  setInterval(refreshAutoSliderC, (window.CONFIG && CONFIG.popups && CONFIG.popups.autoSliderC && CONFIG.popups.autoSliderC.refreshMs) || 15000);

  var btnD = document.getElementById('autoDForceAppend');
  if (btnD) btnD.addEventListener('click', computeAndAppendAutoD);
  startAutoD();
});
</script>


<!-- ===== Added: Auto Slider C/D modals (tables only) & Review modal ===== -->
<div id="autoSliderCModal" style="display:none;">
  <h3 style="margin:6px 0;">Auto Slider C (snapshot mean of last 5 rows)</h3>
  <table id="autoSliderCTable">
    <thead><tr>
      <th>Time</th><th>Rush</th><th>Mood</th><th>Social</th><th>Energy</th><th>Focus</th><th>Anxiety</th><th>Impair</th>
      <th>Score</th><th>Max</th><th>Min</th><th>Weighted</th><th>5Max</th>
    </tr></thead>
    <tbody></tbody>
  </table>
</div>

<div id="autoSliderDModal" style="display:none;">
  <h3 style="margin:6px 0;">Auto Slider D (rolling mean of last 2 rows, every 30s)</h3>
  <table id="autoSliderDTable">
    <thead><tr>
      <th>Time</th><th>Rush</th><th>Mood</th><th>Social</th><th>Energy</th><th>Focus</th><th>Anxiety</th><th>Impair</th>
      <th>Score</th><th>Max</th><th>Min</th><th>Weighted</th><th>5Max</th>
    </tr></thead>
    <tbody></tbody>
  </table>
</div>

<div id="reviewModal" style="display:none; position:fixed; inset:0; z-index:9999;">
  <div style="position:absolute; inset:0; background:rgba(0,0,0,0.45);" onclick="document.getElementById('reviewModal').style.display='none'"></div>
  <div style="position:relative; margin:4vh auto; width:min(1200px,94vw); max-height:92vh; overflow:auto; background:#fff; border-radius:14px; box-shadow:0 10px 40px rgba(0,0,0,0.25); padding:16px;">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px;">
      <div style="font-weight:700; font-size:20px;">Review</div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button onclick="exportReviewCSV()">Export CSV</button>
        <button onclick="document.getElementById('reviewModal').style.display='none'">Close</button>
      </div>
    </div>
    <div id="reviewContent"></div>
  </div>
</div>
<!-- ===== End added modals ===== -->

<script>
(function(){
  var autoSliderA2Timer = null, LS_KEY_A2 = 'autoSliderA2_rows';
  var LS_KEY_C='autoSliderC_rows', LS_KEY_D='autoSliderD_rows', autoSliderDTimer=null;

  function td(col,val){ var c=document.createElement('td'); var n=(typeof val==='number' && isFinite(val)); c.textContent = n? val.toFixed(2) : String(val); c.setAttribute('data-col', col); if(n) c.setAttribute('data-value', String(val)); return c; }
  function timeNow(){ var d=new Date(); var p=function(n){return String(n).padStart(2,'0')}; return p(d.getHours())+':'+p(d.getMinutes())+':'+p(d.getSeconds()); }
  function appendRow(sel,row){
    var tb=document.querySelector(sel); if(!tb) return;
    var tr=document.createElement('tr');
    if (row.means && row.comp){
      tr.appendChild(td('Time', (typeof timeLabel==='function'? timeLabel(row.ms)+' avg('+row.n+')' : timeNow())));
      tr.appendChild(td('Rush', row.means.rush)); tr.appendChild(td('Mood', row.means.mood)); tr.appendChild(td('Social', row.means.social));
      tr.appendChild(td('Energy', row.means.energy)); tr.appendChild(td('Focus', row.means.focus)); tr.appendChild(td('Anxiety', row.means.anxiety)); tr.appendChild(td('Impair', row.means.impair));
      tr.appendChild(td('Score', row.comp.score)); tr.appendChild(td('Max', row.comp.max)); tr.appendChild(td('Min', row.comp.min)); tr.appendChild(td('Weighted', row.comp.weighted)); tr.appendChild(td('5Max', row.comp.fiveMax));
    } else if (row.M && row.C){
      tr.appendChild(td('Time', row.timeLabel || timeNow()));
      tr.appendChild(td('Rush', row.M.rush)); tr.appendChild(td('Mood', row.M.mood)); tr.appendChild(td('Social', row.M.social));
      tr.appendChild(td('Energy', row.M.energy)); tr.appendChild(td('Focus', row.M.focus)); tr.appendChild(td('Anxiety', row.M.anxiety)); tr.appendChild(td('Impair', row.M.impair));
      tr.appendChild(td('Score', row.C.score)); tr.appendChild(td('Max', row.C.max)); tr.appendChild(td('Min', row.C.min)); tr.appendChild(td('Weighted', row.C.weighted)); tr.appendChild(td('5Max', row.C.fiveMax));
    }
    try{ applyRowShading(tr); }catch(e){} tb.appendChild(tr);
  }
  function snapshot(){ if(typeof snapshotFromMainTableForSliding!=='function'||typeof slidingMeanAtIndex!=='function') return null; var s=snapshotFromMainTableForSliding(); if(!s||!s.length) return null; return slidingMeanAtIndex(s,s.length-1); }

  // ---- Auto Slider A2 ----
  function loadA2(){ try{return JSON.parse(localStorage.getItem(LS_KEY_A2)||'[]');}catch(e){return [];} }
  function saveA2(r){ try{localStorage.setItem(LS_KEY_A2, JSON.stringify(r||[]));}catch(e){} }
  window.openAutoSliderA2=function(){
    if(!document.getElementById('autoSliderA2Modal')){
      var a=document.getElementById('autoSliderAModal');
      if(a){ var c=a.cloneNode(true); c.id='autoSliderA2Modal'; var t=c.querySelector('#autoSliderATable'); if(t) t.id='autoSliderA2Table'; a.parentNode.insertBefore(c,a.nextSibling); }
    }
    try{ var rows=loadA2(); var tb=document.querySelector('#autoSliderA2Table tbody'); if(tb) tb.innerHTML=''; rows.forEach(function(r){appendRow('#autoSliderA2Table tbody', r);}); }catch(e){}
    var m=document.getElementById('autoSliderA2Modal'); if(m) m.style.display='block';
  };
  window.toggleAutoSliderA2=function(){
    if(autoSliderA2Timer){ clearInterval(autoSliderA2Timer); autoSliderA2Timer=null; return; }
    function emit(){ var r=snapshot(); if(!r) return; try{ var rows=loadA2(); rows.push(r); saveA2(rows); appendRow('#autoSliderA2Table tbody', r);}catch(e){} }
    emit(); autoSliderA2Timer=setInterval(emit,15000);
  };
  window.clearAutoSliderA2=function(){ saveA2([]); var tb=document.querySelector('#autoSliderA2Table tbody'); if(tb) tb.innerHTML=''; };
  window.exportAutoSliderA2CSV=function(){
    var rows=loadA2(); if(!rows||!rows.length){alert('No rows to export.'); return;}
    var head=['Time','Rush','Mood','Social','Energy','Focus','Anxiety','Impair','Score','Max','Min','Weighted','5Max']; var out=[head.join(',')];
    rows.forEach(function(r){
      var L=[(typeof timeLabel==='function'? timeLabel(r.ms)+' avg('+r.n+')' : timeNow()), r.means.rush,r.means.mood,r.means.social,r.means.energy,r.means.focus,r.means.anxiety,r.means.impair,r.comp.score,r.comp.max,r.comp.min,r.comp.weighted,r.comp.fiveMax];
      out.push(L.map(function(x){ return '\"'+String(isFinite(+x)?(+x).toFixed(2):x).replace(/\"/g,'\"\"')+'\"'; }).join(','));
    });
    var blob=new Blob([out.join('\\n')],{type:'text/csv'}); var a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='auto_slider_A2.csv'; a.click(); URL.revokeObjectURL(a.href);
  };

  // ---- Auto Slider C & D ----
  function loadCD(k){ try{return JSON.parse(localStorage.getItem(k)||'[]');}catch(e){return [];} }
  function saveCD(k,r){ try{localStorage.setItem(k, JSON.stringify(r||[]));}catch(e){} }
  window.openAutoSliderC=function(){
    try{
      var rows=loadCD(LS_KEY_C);
      var tb=document.querySelector('#autoSliderCTable tbody'); if(tb) tb.innerHTML='';
      rows.forEach(function(r){ appendRow('#autoSliderCTable tbody', r); });
      var ro=snapshot(); if(ro){
        var M={rush:ro.means.rush,mood:ro.means.mood,social:ro.means.social,energy:ro.means.energy,focus:ro.means.focus,anxiety:ro.means.anxiety,impair:ro.means.impair};
        var C={score:ro.comp.score,max:ro.comp.max,min:ro.comp.min,weighted:ro.comp.weighted,fiveMax: computeFiveMax(M)};
        var r2={timeLabel:(typeof timeLabel==='function'? timeLabel(ro.ms)+' avg('+ro.n+')' : timeNow()), M:M, C:C};
        rows.push(r2); saveCD(LS_KEY_C, rows); appendRow('#autoSliderCTable tbody', r2);
      }
    }catch(e){}
    var m=document.getElementById('autoSliderCModal'); if(m) m.style.display='block';
  };
  window.openAutoSliderD=function(){
    try{ var rows=loadCD(LS_KEY_D); var tb=document.querySelector('#autoSliderDTable tbody'); if(tb) tb.innerHTML=''; rows.forEach(function(r){ appendRow('#autoSliderDTable tbody', r); }); }catch(e){}
    var m=document.getElementById('autoSliderDModal'); if(m) m.style.display='block';
  };
  window.toggleAutoSliderD=function(){
    if(autoSliderDTimer){ clearInterval(autoSliderDTimer); autoSliderDTimer=null; return; }
    function emit(){ var ro=snapshot(); if(!ro) return;
      try{
        var rows=loadCD(LS_KEY_D);
        var M={rush:ro.means.rush,mood:ro.means.mood,social:ro.means.social,energy:ro.means.energy,focus:ro.means.focus,anxiety:ro.means.anxiety,impair:ro.means.impair};
        var C={score:ro.comp.score,max:ro.comp.max,min:ro.comp.min,weighted:ro.comp.weighted,fiveMax: computeFiveMax(M)};
        var r2={timeLabel:(typeof timeLabel==='function'? timeLabel(ro.ms)+' avg('+ro.n+')' : timeNow()), M:M, C:C};
        rows.push(r2); saveCD(LS_KEY_D, rows); appendRow('#autoSliderDTable tbody', r2);
      }catch(e){}
    }
    emit(); autoSliderDTimer=setInterval(emit,30000);
  };

  // ---- Review ----
  function rowsFromMain(){ var trs=Array.from(document.querySelectorAll('#logTable tbody tr')); return trs.map(function(tr){ function num(f){ var td=tr.querySelector('td[data-field=\"'+f+'Sum\"]'); if(!td) return 0; var v=parseFloat(td.getAttribute('data-value')||td.textContent||'0'); return Number.isFinite(v)?v:0; } var ts=+(tr.getAttribute('data-ts')||0); return { ts:ts, rush:num('rush'), mood:num('mood'), social:num('social'), energy:num('energy'), focus:num('focus'), anxiety:num('anxiety'), impair:num('impair') }; }).filter(function(r){return r.ts>0;}).sort(function(a,b){return a.ts-b.ts;}); }
  function basicStats(vals){ var a=vals.filter(function(v){return Number.isFinite(v);}); var n=a.length; if(!n) return {count:0,sum:0,mean:0,median:0,mode:null,stdev:0}; var sum=a.reduce(function(s,x){return s+x;},0), mean=sum/n; var sorted=a.slice().sort(function(x,y){return x-y;}); var median=(n%2? sorted[(n-1)/2] : (sorted[n/2-1]+sorted[n/2])/2); var freq={}; a.forEach(function(x){freq[x]=(freq[x]||0)+1;}); var mode=null, mf=0; Object.keys(freq).forEach(function(k){ var f=freq[k]; if(f>mf){ mf=f; mode=+k; } }); var stdev=Math.sqrt(a.reduce(function(s,x){return s+(x-mean)*(x-mean);},0)/n); return {count:n,sum:sum,mean:mean,median:median,mode:mode,stdev:stdev}; }
  function renderStats(rows){ var html='<h4 style=\"margin:10px 0 6px 0;\">Per-Metric Statistics</h4>'; html+='<table class=\"striped\" style=\"width:100%; border-collapse:collapse;\"><thead><tr><th>Metric</th><th>COUNT</th><th>SUM</th><th>MEAN</th><th>MODE</th><th>MEDIAN</th><th>STDEV</th></tr></thead><tbody>'; var metrics=['rush','mood','social','energy','focus','anxiety','impair']; metrics.forEach(function(m){ var s=basicStats(rows.map(function(r){return r[m];})); html+='<tr><td>'+m+'</td><td>'+s.count+'</td><td>'+s.sum.toFixed(2)+'</td><td>'+s.mean.toFixed(2)+'</td><td>'+(s.mode??'')+'</td><td>'+s.median.toFixed(2)+'</td><td>'+s.stdev.toFixed(2)+'</td></tr>'; }); html+='</tbody></table>'; return html; }
  function findDoseEvents(rows){
  const ev = [];
  const readSD = (r) => {
    if (r && Object.prototype.hasOwnProperty.call(r, 'sincedose')) return Number(r.sincedose);
    if (r && Object.prototype.hasOwnProperty.call(r, 'Since Dose')) return Number(r['Since Dose']);
    return NaN;
  };
  for (let i = 1; i < rows.length; i++){
    const prev = readSD(rows[i-1]);
    const curr = readSD(rows[i]);
    if (!Number.isFinite(prev) || !Number.isFinite(curr)) continue;
    if (curr < prev) ev.push(i);
  }
  return ev;
}
  function windowAfter(rows, idx, ms){ var start=rows[idx].ts, end=start+ms; var out=[]; for(var i=idx;i<rows.length;i++){ if(rows[i].ts<=end) out.push(rows[i]); else break; } return out; }
  function renderDoseWindows(rows, idxs){ var html='<h4 style=\"margin:10px 0 6px 0;\">5-minute Summaries after Each Dose Event</h4>'; html+='<table class=\"striped\" style=\"width:100%; border-collapse:collapse;\"><thead><tr><th>#</th><th>Start Time</th><th>Rows</th><th>Duration (s)</th><th>Rush μ</th><th>Mood μ</th><th>Social μ</th><th>Energy μ</th><th>Focus μ</th><th>Anxiety μ</th><th>Impair μ</th></tr></thead><tbody>'; idxs.forEach(function(i,k){ var win=windowAfter(rows,i,5*60*1000); var dur=win.length?(win[win.length-1].ts-win[0].ts)/1000:0; function meanOf(f){ var a=win.map(f).filter(function(v){return Number.isFinite(v);}); return a.length? a.reduce(function(s,x){return s+x;},0)/a.length : 0; } html+='<tr><td>'+(k+1)+'</td><td>'+new Date(rows[i].ts).toLocaleTimeString('en-AU',{hour12:false})+'</td><td>'+win.length+'</td><td>'+dur.toFixed(0)+'</td><td>'+meanOf(function(r){return r.rush;}).toFixed(2)+'</td><td>'+meanOf(function(r){return r.mood;}).toFixed(2)+'</td><td>'+meanOf(function(r){return r.social;}).toFixed(2)+'</td><td>'+meanOf(function(r){return r.energy;}).toFixed(2)+'</td><td>'+meanOf(function(r){return r.focus;}).toFixed(2)+'</td><td>'+meanOf(function(r){return r.anxiety;}).toFixed(2)+'</td><td>'+meanOf(function(r){return r.impair;}).toFixed(2)+'</td></tr>'; }); html+='</tbody></table>'; return html; }
  function stretches(rows){ var out=[], start=0; for(var i=1;i<rows.length;i++){ if(rows[i].ts<=rows[i-1].ts){ out.push({i0:start,i1:i-1}); start=i; } } out.push({i0:start,i1:rows.length-1}); return out; }
  function renderStretches(rows, segs){ var html='<h4 style=\"margin:10px 0 6px 0;\">Stretch Summaries (before each timer reset)</h4>'; html+='<table class=\"striped\" style=\"width:100%; border-collapse:collapse;\"><thead><tr><th>#</th><th>Start</th><th>End</th><th>Rows</th><th>Duration (min)</th><th>Rush μ</th><th>Mood μ</th><th>Energy μ</th><th>Focus μ</th><th>Social μ</th><th>Anxiety μ</th><th>Impair μ</th></tr></thead><tbody>'; segs.forEach(function(seg,k){ var sub=rows.slice(seg.i0, seg.i1+1); var dur=sub.length?(sub[sub.length-1].ts-sub[0].ts)/(60*1000):0; function meanOf(f){ var a=sub.map(f).filter(function(v){return Number.isFinite(v);}); return a.length? a.reduce(function(s,x){return s+x;},0)/a.length : 0; } html+='<tr><td>'+(k+1)+'</td><td>'+new Date(sub[0].ts).toLocaleTimeString('en-AU',{hour12:false})+'</td><td>'+new Date(sub[sub.length-1].ts).toLocaleTimeString('en-AU',{hour12:false})+'</td><td>'+sub.length+'</td><td>'+dur.toFixed(2)+'</td><td>'+meanOf(function(r){return r.rush;}).toFixed(2)+'</td><td>'+meanOf(function(r){return r.mood;}).toFixed(2)+'</td><td>'+meanOf(function(r){return r.energy;}).toFixed(2)+'</td><td>'+meanOf(function(r){return r.focus;}).toFixed(2)+'</td><td>'+meanOf(function(r){return r.social;}).toFixed(2)+'</td><td>'+meanOf(function(r){return r.anxiety;}).toFixed(2)+'</td><td>'+meanOf(function(r){return r.impair;}).toFixed(2)+'</td></tr>'; }); html+='</tbody></table>'; return html; }
  window.openReview=function(){ var rows=rowsFromMain(); var html=''; html+=renderStats(rows); var idxs=findDoseEvents(rows); html+=renderDoseWindows(rows, idxs); var segs=stretches(rows); html+=renderStretches(rows, segs); var cont=document.getElementById('reviewContent'); if(cont) cont.innerHTML=html; var modal=document.getElementById('reviewModal'); if(modal) modal.style.display='block'; };
  window.exportReviewCSV=function(){ var rows=rowsFromMain(); var metrics=['rush','mood','social','energy','focus','anxiety','impair']; var head=['metric','count','sum','mean','mode','median','stdev']; var out=[head.join(',')]; metrics.forEach(function(m){ var s=basicStats(rows.map(function(r){return r[m];})); out.push([m,s.count,s.sum.toFixed(2),s.mean.toFixed(2),s.mode??'',s.median.toFixed(2),s.stdev.toFixed(2)].join(',')); }); var blob=new Blob([out.join('\\n')],{type:'text/csv'}); var a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='review_stats.csv'; a.click(); URL.revokeObjectURL(a.href); };
})();
</script>


<!-- ===== Auto Entries & Rolling Average (modal-based) ===== -->


<!-- Auto Entries Modal (uses shared .modal/.modal-content pattern) -->
<div id="autoEntriesModal" style="display:none;">
  <div class="modal-content" style="max-width: 95vw;">
    <span class="close" data-close="#autoEntriesModal">&times;</span>
    <h2>Auto Entries (current selections every 15s)</h2>
    <div class="as-toolbar" style="margin: 8px 0;">
      <button onclick="exportAutoEntriesCSV()">Export CSV</button>
      <button onclick="clearAutoEntries()">Clear</button>
    </div>
    <table id="autoEntriesTable" class="table compact">
      <thead>
        <tr>
          <th>Time</th><th>Rush</th><th>Mood</th><th>Social</th><th>Energy</th><th>Focus</th>
          <th>Anxiety</th><th>Impair</th><th>Weighted</th><th>Score5</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <div id="autoEntriesStatus" style="margin-top:6px; font-size:11px; opacity:0.75;"></div>
  </div>
</div>

<!-- Rolling Average Modal (uses shared .modal/.modal-content pattern) -->
<div id="rollingAverageModal" class="modal" style="display:none;">
  <div class="modal-content" style="max-width: 95vw;">
    <span class="close" data-close="#rollingAverageModal">&times;</span>
    <h2>Rolling Average (last <span id="raWinRows"></span> rows, every <span id="raInterval"></span>)</h2>
<script>
(function(){
  try{
    var w = (window.CONFIG && CONFIG.popups && CONFIG.popups.rollingAverage && CONFIG.popups.rollingAverage.windowRows) || 5;
    var ms = (window.CONFIG && CONFIG.popups && CONFIG.popups.rollingAverage && CONFIG.popups.rollingAverage.intervalMs) || 15000;
    var s = Math.round(ms/1000);
    var winEl = document.getElementById('raWinRows');
    var intEl = document.getElementById('raInterval');
    if (winEl) winEl.textContent = String(w);
    if (intEl) intEl.textContent = s + 's';
  }catch(e){}
})();
</script>
    <div class="as-toolbar" style="margin: 8px 0;">
      <button onclick="exportRollingAverageCSV()">Export CSV</button>
      <button onclick="clearRollingAverage()">Clear</button>
    </div>
    <table id="rollingAverageTable" class="table compact">
      <thead>
        <tr>
          <th>Time</th><th>Avg Rush</th><th>Avg Mood</th><th>Avg Social</th><th>Avg Energy</th>
          <th>Avg Focus</th><th>Avg Anxiety</th><th>Avg Impair</th><th>Weighted</th><th>Score5</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <div id="rollingAverageStatus" style="margin-top:6px; font-size:11px; opacity:0.75;"></div>
  </div>
</div>

<script>
(function(){
  function pad(n){ return String(n).padStart(2,'0'); }
  function timeLabel(ms){
    try {
      var d = new Date(ms||Date.now());
      return d.getFullYear()+'-'+pad(d.getMonth()+1)+'-'+pad(d.getDate())+' '+pad(d.getHours())+':'+pad(d.getMinutes())+':'+pad(d.getSeconds());
    } catch(e){ return new Date().toLocaleString(); }
  }
  function fmt2(x){ var n=Number(x); return Number.isFinite(n)? n.toFixed(2) : ""; }

  function postDecorateRow(tr){
    try { if (typeof applyRowShading === 'function') applyRowShading(tr); } catch(e){}
    try { if (typeof applyUiColumnVisibility === 'function') applyUiColumnVisibility(); } catch(e){}
  }

  function getLogTableColumnMap(){
    var map = {};
    var ths = document.querySelectorAll('#logTable thead th');
    ths.forEach(function(th, idx){
      var name = (th.textContent || '').trim();
      if (name) map[name] = idx;
    });
    return map;
  }
  function getLogRows(){
    return Array.from(document.querySelectorAll('#logTable tbody tr')).filter(function(tr){
      return tr.offsetParent !== null;
    });
  }
  function rowToObj(tr, col){
    var c = tr.children;
    function cell(name){
      var idx = col[name];
      return (idx != null && c[idx]) ? (c[idx].textContent || '').trim() : '';
    }
    function num(name){
      var v = cell(name), x = parseFloat(v);
      return isNaN(x) ? 0 : x;
    }
    return {
      Rush: num('Rush Sum') || num('Rush') || 0,
      Mood: num('Mood Sum') || num('Mood') || 0,
      Social: num('Social Sum') || num('Social') || 0,
      Energy: num('Energy Sum') || num('Energy') || 0,
      Focus: num('Focus Sum') || num('Focus') || 0,
      Anxiety: num('Anxiety Sum') || num('Anxiety') || 0,
      Impair: num('Impair Sum') || num('Impair') || 0,
      Weighted: num('Weighted') || 0,
      Score5: num('Score5') || 0
    };
  }

  // ===== 1) Auto Entries =====
  var LS_KEY_ENTRIES = 'auto_entries_rows';
  var autoEntriesTimer = null;

  function loadEntries(){ try{ return JSON.parse(localStorage.getItem(LS_KEY_ENTRIES) || '[]'); }catch(e){ return []; } }
  function saveEntries(rows){ try{ localStorage.setItem(LS_KEY_ENTRIES, JSON.stringify(rows||[])); }catch(e){} }


function readCurrentSelections(){
  function readById(id){
    var el = document.getElementById(id);
    if (!el) return null;
    var v = parseFloat(el.value || el.getAttribute('data-value') || el.textContent);
    return isFinite(v) ? v : null;
  }
  var legacy = {
    Rush:   readById('rushValue'),
    Mood:   readById('moodValue'),
    Social: readById('socialValue'),
    Energy: readById('energyValue'),
    Focus:  readById('focusValue'),
    Anxiety:readById('anxietyValue'),
    Impair: readById('impairValue'),
    Weighted: readById('weightedValue'),
    Score5:   readById('score5Value')
  };
  var haveLegacy = Object.values(legacy).some(function(v){ return v != null && !isNaN(v); });
  if (haveLegacy){
    Object.keys(legacy).forEach(function(k){ legacy[k] = (legacy[k]==null || isNaN(legacy[k])) ? 0 : legacy[k]; });
    return legacy;
  }
  try{
    var col = getLogTableColumnMap();
    var rows = getLogRows();
    if (!rows || !rows.length) return {Rush:0,Mood:0,Social:0,Energy:0,Focus:0,Anxiety:0,Impair:0,Weighted:0,Score5:0};
    var tr = rows[rows.length-1];
    var obj = rowToObj(tr, col);
    return {
      Rush: +obj.Rush || 0,
      Mood: +obj.Mood || 0,
      Social: +obj.Social || 0,
      Energy: +obj.Energy || 0,
      Focus: +obj.Focus || 0,
      Anxiety: +obj.Anxiety || 0,
      Impair: +obj.Impair || 0,
      Weighted: +obj.Weighted || 0,
      Score5: +obj.Score5 || 0
    };
  }catch(e){
    return {Rush:0,Mood:0,Social:0,Energy:0,Focus:0,Anxiety:0,Impair:0,Weighted:0,Score5:0};
  }


</script>
<script>
function(){
  function setDToLast3(){
    var d = document.getElementById('autoSliderDModal');
    if (!d) return;
    try{
      if (typeof window.setAutoSliderRollingCountByModal === 'function'){ window.setAutoSliderRollingCountByModal(d, 3); }
      if (typeof window.setAutoSliderRollingCount === 'function'){ window.setAutoSliderRollingCount('D', 3); }
    }catch(_){}
    d.setAttribute('data-rolling-count','3');
    var titles = d.querySelectorAll('.modal-title, [data-role="title"], h1, h2, h3');
    titles.forEach(function(t){
      var txt = t.textContent || '';
      t.textContent = txt.replace(/Last\s*2\s*Rows/i, 'Last 3 Rows');
    });
    d.setAttribute('data-patched-last3','1');
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', setDToLast3);
  } else {
    setDToLast3();
  }
}();
</script>


<!-- STS: Buttons (auto-injected) -->
<div id="sts-roaming-buttons" style="padding:8px; display:flex; gap:8px; flex-wrap:wrap;">
  <button id="roamingEntriesBtn" type="button" onclick="openRoamingEntries && openRoamingEntries()">Roaming Entries</button>
  <button id="roamingAverageBtn" type="button" onclick="openRoamingAverage && openRoamingAverage()">Roaming Average</button>
</div>

<!-- STS: Roaming Entries (auto-injected) -->


<div id="roamingEntriesModal" class="sts-modal" role="dialog" aria-labelledby="roamingEntriesTitle" aria-modal="true">
  <div class="sts-box" role="document">
    <div class="sts-hdr">
      <h2 id="roamingEntriesTitle">Roaming Entries</h2>
      <div class="sts-status" id="roamingStatus">stopped</div>
      <button id="roamingCloseBtn" title="Close" style="border:none;background:transparent;font-size:22px;line-height:1;cursor:pointer;">&times;</button>
    </div>
    <div class="sts-ctl">
      <button id="roamingStartBtn" title="Start 15 s capture">Start</button>
      <button id="roamingStopBtn" title="Stop capture">Stop</button>
      <button id="roamingExportBtn" title="Export captured rows as CSV">Export CSV</button>
      <button id="roamingClearBtn" title="Clear captured rows">Clear</button>
      <div style="font-size:11px; opacity:0.8;">Every 15 s: selected scores, else last main-row values (with Score/Min/Max)</div>
    </div>
    <div class="sts-bdy">
      <table id="roamingEntriesTable">
        <thead><tr id="roamingHeadRow"></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
</div>

<script>
(function(){
  const METRICS = ["Rush","Mood","Social","Energy","Focus","Anxiety","Impair"];
  const EXTRA_COLS = ["Score","Min","Max"];
  const LS_KEY = "STS_ROAMING_ENTRIES_v1";
  let roamingRows = [];
  let roamingTimer = null;

  function toSydneyNoDST(dateObj) {
    const t = dateObj instanceof Date ? dateObj : new Date(dateObj);
    const utcMs = t.getTime() + t.getTimezoneOffset() * 60000;
    return new Date(utcMs + 10 * 3600000);
  }
  function fmtMIS(ts) {
    const d = toSydneyNoDST(new Date(ts));
    const Y = d.getUTCFullYear();
    const M = String(d.getUTCMonth()+1).padStart(2,'0');
    const D = String(d.getUTCDate()).padStart(2,'0');
    const h = String(d.getUTCHours()).padStart(2,'0');
    const m = String(d.getUTCMinutes()).padStart(2,'0');
    const s = String(d.getUTCSeconds()).padStart(2,'0');
    return Y + '//' + M + '//' + D + ' ' + h + m + s;
  }
  function $(sel, root){ return (root||document).querySelector(sel); }
  function $all(sel, root){ return Array.from((root||document).querySelectorAll(sel)); }

  function load(){ try{ roamingRows = JSON.parse(localStorage.getItem(LS_KEY)||"[]"); }catch(e){ roamingRows=[]; } if(!Array.isArray(roamingRows)) roamingRows=[]; }
  function save(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(roamingRows)); }catch(e){} }

  function updateStatus(){
    const st = document.getElementById('roamingStatus');
    if (!st) return;
    st.textContent = roamingTimer ? 'capturing every 15 s' : 'stopped';
  }

  function buildColumns(){ return ["Time"].concat(METRICS, EXTRA_COLS).filter(c => window.STS_isColVisible("roaming", c)); }
  function renderHeaders(){
    const headRow = document.getElementById('roamingHeadRow');
    if (!headRow) return;
    headRow.innerHTML = "";
    for (const c of buildColumns()){
      const th = document.createElement('th');
      th.textContent = (c === "Time") ? "Time (YYYY//MM//DD HHMMSS)" : c;
      headRow.appendChild(th);
    }
  }
  function buildCells(r){
    const out = { "Time": fmtMIS(r.ts) };
    for (const m of METRICS) out[m] = r[m];
    if (Number.isFinite(r.Score)) out["Score"] = r.Score;
    if (Number.isFinite(r.Min)) out["Min"] = r.Min;
    if (Number.isFinite(r.Max)) out["Max"] = r.Max;
    return out;
  }
  function render(){
    renderHeaders();
    const tb = $('#roamingEntriesTable tbody');
    if (!tb) return;
    tb.innerHTML = '';
    const cols = buildColumns();
    for (const r of roamingRows){
      const tr = document.createElement('tr');
      const cells = buildCells(r);
      for (const col of cols){
        const td = document.createElement('td');
        td.textContent = (cells[col] ?? '') + '';
        td.setAttribute('data-col', col);
        tr.appendChild(td);
      }
      window.STS_applyShading(tr);
      tb.appendChild(tr);
    }
  }

  function start(){
    if (roamingTimer) return;
    const delay = 15000 - (Date.now() % 15000);
    roamingTimer = setTimeout(()=>{
      tick();
      roamingTimer = setInterval(tick, 15000);
      updateStatus();
    }, delay);
    updateStatus();
  }
  function stop(){
    if (roamingTimer){
      clearTimeout(roamingTimer);
      clearInterval(roamingTimer);
      roamingTimer = null;
    }
    updateStatus();
  }
  function clearRows(){ roamingRows = []; save(); render(); }
  function exportCSV(){
    const cols = buildColumns();
    const lines = [cols.join(',')];
    roamingRows.forEach(r => {
      const cells = buildCells(r);
      lines.push(cols.map(c => (cells[c] ?? '')).join(','));
    });
    const blob = new Blob([lines.join('\n')+'\n'], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'roaming_entries.csv';
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
  }

  function getSelectionsOrNull(){
    const out = {}; let any = false;
    METRICS.forEach(m => out[m] = null);
    const sel = window.selections || null;
    if (sel && typeof sel === 'object'){
      METRICS.forEach(m => {
        const low = m.toLowerCase();
        const v = sel[low] || sel[m] || null;
        if (Array.isArray(v) && v.length){ out[m] = Number(v[0]); any = true; }
        else if (typeof v === 'number'){ out[m] = v; any = true; }
      });
      if (any) return out;
    }
    const btns = $all('[data-metric].selected, [data-metric].active');
    btns.forEach(btn => {
      const m = (btn.getAttribute('data-metric')||'').trim();
      const key = METRICS.find(K => K.toLowerCase() === m.toLowerCase());
      const num = Number((btn.getAttribute('data-value') || btn.textContent || '').replace(/[^-\d.]/g,''));
      if (key && Number.isFinite(num)){ out[key] = num; any = true; }
    });
    return any ? out : null;
  }

  function readLastMainRowValsAndExtras(){
    const tr = document.querySelector('#logTable tbody tr:last-child');
    if (!tr) return null;
    const out = { vals: {}, extras: {Score:null, Min:null, Max:null} };
    METRICS.forEach(m => {
      const td = tr.querySelector('[data-field="'+m.toLowerCase()+'Sum"]') || tr.querySelector('td[data-col="'+m+'"]');
      const num = td ? Number(String(td.getAttribute('data-value') ?? td.textContent).replace(/[^-\d.]/g,'')) : NaN;
      out.vals[m] = Number.isFinite(num) ? num : null;
    });
    const s = tr.querySelector('td[data-col="Score"]');
    const mn= tr.querySelector('td[data-col="Min"]');
    const mx= tr.querySelector('td[data-col="Max"]');
    out.extras.Score = s ? Number(String(s.textContent).replace(/[^-\d.]/g,'')) : null;
    out.extras.Min   = mn? Number(String(mn.textContent).replace(/[^-\d.]/g,'')) : null;
    out.extras.Max   = mx? Number(String(mx.textContent).replace(/[^-\d.]/g,'')) : null;
    return out;
  }

  function computeExtras(vals, fromMainRowExtras){
    const numbers = Object.values(vals).filter(v => Number.isFinite(v));
    const extras = { Score:null, Min:null, Max:null };
    if (fromMainRowExtras && (Number.isFinite(fromMainRowExtras.Score) || Number.isFinite(fromMainRowExtras.Min) || Number.isFinite(fromMainRowExtras.Max))){
      return {
        Score: Number.isFinite(fromMainRowExtras.Score) ? fromMainRowExtras.Score : null,
        Min: Number.isFinite(fromMainRowExtras.Min) ? fromMainRowExtras.Min : (numbers.length ? Math.min(...numbers) : null),
        Max: Number.isFinite(fromMainRowExtras.Max) ? fromMainRowExtras.Max : (numbers.length ? Math.max(...numbers) : null)
      };
    }
    if (!numbers.length) return extras;
    const mode = (window.STS_UI && window.STS_UI.roamingScoreMode) || "mean";
    extras.Min = Math.min(...numbers);
    extras.Max = Math.max(...numbers);
    extras.Score = (mode === "sum")
      ? numbers.reduce((a,b)=>a+b,0)
      : Math.round(numbers.reduce((a,b)=>a+b,0) / numbers.length * 1000) / 1000;
    return extras;
  }

  function tick(){
    let vals = getSelectionsOrNull();
    let extras = null;
    if (!vals){
      const got = readLastMainRowValsAndExtras();
      if (!got) return;
      vals = got.vals;
      extras = got.extras;
    }
    const agg = computeExtras(vals, extras);
    const row = Object.assign({ ts: Date.now() }, vals, agg);
    roamingRows.push(row);
    save();
    const modal = document.getElementById('roamingEntriesModal');
    if (modal && modal.style.display !== 'none') render();
  }

  function openModal(){ load(); render(); updateStatus(); document.getElementById('roamingEntriesModal').style.display='block'; }
  function closeModal(){ document.getElementById('roamingEntriesModal').style.display='none'; }

  document.addEventListener('DOMContentLoaded', ()=>{
    document.getElementById('roamingCloseBtn')?.addEventListener('click', closeModal);
    document.getElementById('roamingStartBtn')?.addEventListener('click', start);
    document.getElementById('roamingStopBtn')?.addEventListener('click', stop);
    document.getElementById('roamingExportBtn')?.addEventListener('click', exportCSV);
    document.getElementById('roamingClearBtn')?.addEventListener('click', clearRows);
  });

  window.openRoamingEntries = openModal;
  window.startRoamingEntries = start;
  window.stopRoamingEntries = stop;
})();
</script>
<!-- /STS: Roaming Entries (auto-injected) -->

<!-- STS: Roaming Average (auto-injected) -->


<div id="roamingAverageModal" class="sts-modal" role="dialog" aria-labelledby="roamingAverageTitle" aria-modal="true">
  <div class="sts-box" role="document">
    <div class="sts-hdr">
      <h2 id="roamingAverageTitle">Roaming Average</h2>
      <div class="sts-status" id="roamingAverageStatus">stopped</div>
      <button id="roamingAverageCloseBtn" title="Close" style="border:none;background:transparent;font-size:22px;line-height:1;cursor:pointer;">&times;</button>
    </div>
    <div class="sts-ctl">
      <button id="roamingAverageStartBtn" title="Start 15 s averaging">Start</button>
      <button id="roamingAverageStopBtn" title="Stop averaging">Stop</button>
      <button id="roamingAverageExportBtn" title="Export rows as CSV">Export CSV</button>
      <button id="roamingAverageClearBtn" title="Clear rows">Clear</button>
      <div style="font-size:11px; opacity:0.8;">Every 15 s: average last 15 s of main entries per metric (with Score/Min/Max)</div>
    </div>
    <div class="sts-bdy">
      <table id="roamingAverageTable">
        <thead><tr id="roamingAverageHeadRow"></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
</div>

<script>
(function(){
  const METRICS = ["Rush","Mood","Social","Energy","Focus","Anxiety","Impair"];
  const EXTRA_COLS = ["Score","Min","Max"];
  const LS_KEY = "STS_ROAMING_AVG_ENTRIES_v1";
  let rows = [];
  let timer = null;

  function toSydneyNoDST(dateObj) {
    const t = dateObj instanceof Date ? dateObj : new Date(dateObj);
    const utcMs = t.getTime() + t.getTimezoneOffset() * 60000;
    return new Date(utcMs + 10 * 3600000);
  }
  function fmtMIS(ts) {
    const d = toSydneyNoDST(new Date(ts));
    const Y = d.getUTCFullYear();
    const M = String(d.getUTCMonth()+1).padStart(2,'0');
    const D = String(d.getUTCDate()).padStart(2,'0');
    const h = String(d.getUTCHours()).padStart(2,'0');
    const m = String(d.getUTCMinutes()).padStart(2,'0');
    const s = String(d.getUTCSeconds()).padStart(2,'0');
    return Y + '//' + M + '//' + D + ' ' + h + m + s;
  }
  function $(sel, root){ return (root||document).querySelector(sel); }
  function $all(sel, root){ return Array.from((root||document).querySelectorAll(sel)); }

  function load(){ try{ rows = JSON.parse(localStorage.getItem(LS_KEY)||"[]"); }catch(e){ rows=[]; } if(!Array.isArray(rows)) rows=[]; }
  function save(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(rows)); }catch(e){} }

  function updateStatus(){
    const st = document.getElementById('roamingAverageStatus');
    if (!st) return;
    st.textContent = timer ? ('averaging every ' + Math.round(((window.CONFIG && CONFIG.popups && CONFIG.popups.roamingAverage && CONFIG.popups.roamingAverage.intervalMs) || 15000)/1000) + ' s') : 'stopped';
  }

  function buildColumns(){ return ["Time"].concat(METRICS, EXTRA_COLS).filter(c => window.STS_isColVisible("roamingAverage", c)); }
  function renderHeaders(){
    const headRow = document.getElementById('roamingAverageHeadRow');
    if (!headRow) return;
    headRow.innerHTML = "";
    for (const c of buildColumns()){
      const th = document.createElement('th');
      th.textContent = (c === "Time") ? "Time (YYYY//MM//DD HHMMSS)" : c;
      headRow.appendChild(th);
    }
  }
  function buildCells(r){
    const out = { "Time": fmtMIS(r.ts) };
    for (const m of METRICS) out[m] = r[m];
    if (Number.isFinite(r.Score)) out["Score"] = r.Score;
    if (Number.isFinite(r.Min)) out["Min"] = r.Min;
    if (Number.isFinite(r.Max)) out["Max"] = r.Max;
    return out;
  }
  function render(){
    renderHeaders();
    const tb = $('#roamingAverageTable tbody');
    if (!tb) return;
    tb.innerHTML = '';
    const cols = buildColumns();
    for (const r of rows){
      const tr = document.createElement('tr');
      const cells = buildCells(r);
      for (const col of cols){
        const td = document.createElement('td');
        td.textContent = (cells[col] ?? '') + '';
        td.setAttribute('data-col', col);
        tr.appendChild(td);
      }
      window.STS_applyShading(tr);
      tb.appendChild(tr);
    }
  }

  function start(){
    if (timer) return;
    const delay = 15000 - (Date.now() % 15000);
    timer = setTimeout(()=>{
      tick();
      timer = setInterval(tick, 15000);
      updateStatus();
    }, delay);
    updateStatus();
  }
  function stop(){
    if (timer){
      clearTimeout(timer);
      clearInterval(timer);
      timer = null;
    }
    updateStatus();
  }
  function clearRows(){ rows = []; save(); render(); }
  function exportCSV(){
    const cols = buildColumns();
    const lines = [cols.join(',')];
    rows.forEach(r => {
      const cells = buildCells(r);
      lines.push(cols.map(c => (cells[c] ?? '')).join(','));
    });
    const blob = new Blob([lines.join('\n')+'\n'], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'roaming_average.csv';
    document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
  }

  function avg(nums){
    const arr = nums.filter(n => Number.isFinite(n));
    if (!arr.length) return null;
    return Math.round(arr.reduce((a,b)=>a+b,0) / arr.length * 1000) / 1000;
  }

  function tick(){
    // Average last 15 s of MAIN table rows
    const now = Date.now();
    const cutoff = now - 15000;
    const trs = $all('#logTable tbody tr');
    const recent = trs.filter(tr => Number(tr.getAttribute('data-ts') || '0') >= cutoff);
    if (!recent.length) return;
    const valsByMetric = {}; METRICS.forEach(m => valsByMetric[m] = []);
    const scoreArr = [], minArr = [], maxArr = [];
    recent.forEach(tr => {
      METRICS.forEach(m => {
        const td = tr.querySelector('[data-field="'+m.toLowerCase()+'Sum"]') || tr.querySelector('td[data-col="'+m+'"]');
        const raw = td ? (td.getAttribute('data-value') !== null ? td.getAttribute('data-value') : td.textContent) : '';
        const num = Number(String(raw).replace(/[^-\d.]/g,''));
        if (Number.isFinite(num)) valsByMetric[m].push(num);
      });
      const sTd = tr.querySelector('td[data-col="Score"]');
      const mnTd= tr.querySelector('td[data-col="Min"]');
      const mxTd= tr.querySelector('td[data-col="Max"]');
      const s = sTd ? Number(String(sTd.textContent).replace(/[^-\d.]/g,'')) : NaN;
      const mn= mnTd? Number(String(mnTd.textContent).replace(/[^-\d.]/g,'')) : NaN;
      const mx= mxTd? Number(String(mxTd.textContent).replace(/[^-\d.]/g,'')) : NaN;
      if (Number.isFinite(s)) scoreArr.push(s);
      if (Number.isFinite(mn)) minArr.push(mn);
      if (Number.isFinite(mx)) maxArr.push(mx);
    });
    const row = { ts: now };
    METRICS.forEach(m => row[m] = avg(valsByMetric[m]) ?? '');
    row.Score = avg(scoreArr);
    row.Min = avg(minArr);
    row.Max = avg(maxArr);
    rows.push(row);
    save();
    const modal = document.getElementById('roamingAverageModal');
    if (modal && modal.style.display !== 'none') render();
  }

  function openModal(){ load(); render(); updateStatus(); document.getElementById('roamingAverageModal').style.display='block'; }
  function closeModal(){ document.getElementById('roamingAverageModal').style.display='none'; }

  document.addEventListener('DOMContentLoaded', ()=>{
    document.getElementById('roamingAverageCloseBtn')?.addEventListener('click', closeModal);
    document.getElementById('roamingAverageStartBtn')?.addEventListener('click', start);
    document.getElementById('roamingAverageStopBtn')?.addEventListener('click', stop);
    document.getElementById('roamingAverageExportBtn')?.addEventListener('click', exportCSV);
    document.getElementById('roamingAverageClearBtn')?.addEventListener('click', clearRows);
  });

  window.openRoamingAverage = openModal;
  window.startRoamingAverage = start;
  window.stopRoamingAverage = stop;
})();
</script>
<!-- /STS: Roaming Average (auto-injected) -->

<script>
// ──────────────────────────────────────────────────────────────────────────────
// STS: Dose Reviews segmentation helpers (timer reset OR redose)
// ──────────────────────────────────────────────────────────────────────────────
function STS_sinceToSeconds(v) {
  if (v == null) return NaN;
  if (typeof v === "number" && Number.isFinite(v)) return v;
  const s = String(v).trim();
  // numeric string
  if (/^[+-]?\d+(\.\d+)?$/.test(s)) {
    const n = Number(s);
    return Number.isFinite(n) ? n : NaN;
  }
  // HH:MM:SS
  const m = s.match(/^(\d{1,2}):(\d{2}):(\d{2})$/);
  if (m) {
    const h = Number(m[1]), mi = Number(m[2]), se = Number(m[3]);
    if ([h, mi, se].every(Number.isFinite)) return h*3600 + mi*60 + se;
  }
  return NaN;
}
function STS_isTruthy(x) {
  if (x === true) return true;
  const s = String(x ?? "").trim().toLowerCase();
  return ["1","true","yes","y","on"].includes(s);
}
function STS_isRedoseRow(row) {
  // Dedicated checkbox/column
  if ("Redose" in row && STS_isTruthy(row["Redose"])) return true;
  // Text signals
  const fields = ["Phase","Scale","Notes","Custom Notes","Last"];
  for (const f of fields) {
    const val = row[f];
    if (val != null && String(val).toLowerCase().includes("redose")) return true;
  }
  return false;
}
// Build segments from visible rows.
// New segment starts if EITHER:
// 1) Since timer resets (current since < previous since), OR
// 2) Row indicates a redose via STS_isRedoseRow().
function STS_STS_STS_buildDoseSegmentsOnEitherTimerReset(rows) {
  const segments = [];
  let cur = [];
  let prevSince = NaN;
  for (const r of rows) {
    const sinceRaw = r["Since Dose"] ?? r["Since"] ?? r["SinceDose"] ?? r["Time Since Dose"];
    const curSince = STS_sinceToSeconds(sinceRaw);
    const timerReset = Number.isFinite(curSince) && Number.isFinite(prevSince) && (curSince < prevSince);
    const redoseHit  = STS_isRedoseRow(r);
    if (timerReset || redoseHit) {
      if (cur.length) segments.push(cur);
      cur = [];
    }
    cur.push(r);
    prevSince = curSince;
  }
  if (cur.length) segments.push(cur);
  return segments;
}
</script>


<script>
// === STS: Dose Reviews segmentation – ONLY on timer reset (no redose) ===
function STS_parseTimestamp(s){
  if (s == null) return NaN;
  // Expect "YYYY/MM/DD HH:MM:SS"
  const m = String(s).trim().match(/^(\d{4})[\/\-](\d{2})[\/\-](\d{2})\s+(\d{2}):(\d{2}):(\d{2})$/);
  if (!m) return NaN;
  const year = +m[1], mon = +m[2]-1, day = +m[3], hh = +m[4], mm = +m[5], ss = +m[6];
  const d = new Date(year, mon, day, hh, mm, ss);
  return d.getTime();
}
function STS_STS_buildDoseSegmentsOnEitherTimerReset(rows) {
  const arr = Array.isArray(rows) ? rows.slice() : [];
  arr.sort((a,b)=>{
    const ta = STS_parseTimestamp(a["Timestamp"] ?? a["Time"]);
    const tb = STS_parseTimestamp(b["Timestamp"] ?? b["Time"]);
    if (Number.isFinite(ta) && Number.isFinite(tb)) return ta - tb;
    return 0;
  });

  const segments = [];
  let cur = [];
  let prevSince = NaN;

  for (const r of arr) {
    const sinceRaw = r["Since Dose"] ?? r["Since"] ?? r["SinceDose"] ?? r["Time Since Dose"];
    const curSince = STS_sinceToSeconds(sinceRaw);
    // New segment whenever timer decreases (any drop, not just reset)
    const timerDecreased = Number.isFinite(curSince) && Number.isFinite(prevSince) && (curSince < prevSince);
    if (timerDecreased) {
      if (cur.length) segments.push(cur);
      cur = [];
    }
    cur.push(r);
    prevSince = curSince;
  }
  if (cur.length) segments.push(cur);
  return segments;
}
// end STS_buildDoseSegmentsOnResetOnly
</script>


<script>
// === STS: Dose Reviews segmentation – new segment if EITHER timer resets ===
function STS_parseTimestamp(s){
  if (s == null) return NaN;
  const m = String(s).trim().match(/^(\d{4})[\/\-](\d{2})[\/\-](\d{2})\s+(\d{2}):(\d{2}):(\d{2})$/);
  if (!m) return NaN;
  const year = +m[1], mon = +m[2]-1, day = +m[3], hh = +m[4], mm = +m[5], ss = +m[6];
  return new Date(year, mon, day, hh, mm, ss).getTime();
}
function STS_toSeconds(v){
  if (v == null) return NaN;
  if (typeof v === "number" && Number.isFinite(v)) return v;
  const s = String(v).trim();
  if (/^[+-]?\d+(\.\d+)?$/.test(s)) {
    const n = Number(s);
    return Number.isFinite(n) ? n : NaN;
  }
  const m = s.match(/^(\d{1,2}):(\d{2}):(\d{2})$/);
  if (m) {
    const h = +m[1], mi = +m[2], se = +m[3];
    return h*3600 + mi*60 + se;
  }
  return NaN;
}
function STS_STS_buildDoseSegmentsOnEitherTimerReset(rows) {
  const arr = Array.isArray(rows) ? rows.slice() : [];
  arr.sort((a,b)=>{
    const ta = STS_parseTimestamp(a["Timestamp"] ?? a["Time"]);
    const tb = STS_parseTimestamp(b["Timestamp"] ?? b["Time"]);
    if (Number.isFinite(ta) && Number.isFinite(tb)) return ta - tb;
    return 0;
  });
  const segments = [];
  let cur = [];
  let prevSince = NaN;
  let prevElapsed = NaN;
  for (const r of arr) {
    const sinceRaw = r["Since Dose"] ?? r["Since"] ?? r["SinceDose"] ?? r["Time Since Dose"];
    const elapsedRaw = r["Elapsed"];
    const curSince = STS_toSeconds(sinceRaw);
    const curElapsed = STS_toSeconds(elapsedRaw);
    const resetSince = Number.isFinite(curSince) && Number.isFinite(prevSince) && (curSince < prevSince - 5e-4);
    const resetElapsed = Number.isFinite(curElapsed) && Number.isFinite(prevElapsed) && (curElapsed < prevElapsed - 5e-4);
    if (resetSince || resetElapsed) {
      if (cur.length) segments.push(cur);
      cur = [];
    }
    cur.push(r);
    prevSince = curSince;
    prevElapsed = curElapsed;
  }
  if (cur.length) segments.push(cur);
  return segments;
}
</script>


<!-- Rated Popup Modal -->
<div id="ratedPopupModal">
  <div id="ratedPopupBackdrop"></div>
  <div id="ratedPopupCard">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px;">
      <h2>Rated Popup</h2>
      <button aria-label="Close" onclick="closeRatedPopup()">Close</button>
    </div>
    <div style="font-size:11px; opacity:0.7; margin-bottom:6px;">Categories: None, Low, Medium, High (derived from current selections)</div>
    <table id="ratedPopupTable">
      <thead><tr><th>Metric</th><th>Rating</th><th>Detail</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</div>


<!-- All Rated Popup Modal -->
<div id="allRatedPopupModal" style="display:none; position:fixed; inset:0; z-index:10000;">
  <div id="allRatedPopupBackdrop" style="position:absolute; inset:0; background:rgba(0,0,0,0.45);"></div>
  <div id="allRatedPopupCard" style="position:relative; margin:6vh auto; width:min(1100px,95vw); max-height:88vh; overflow:auto; background:#fff; border-radius:12px; box-shadow:0 10px 40px rgba(0,0,0,0.25); padding:16px; border:2px solid #007aff;">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px;">
      <div style="font-weight:700; font-size:18px;">All Rated Popup</div>
      <button aria-label="Close" onclick="closeAllRatedPopup()">Close</button>
    </div>
    <div style="font-size:11px; opacity:0.7; margin-bottom:6px;">Per-row categories computed from numeric sums in the log: None ≤ 0, Low &lt; 1.5, Medium &lt; 3.5, High ≥ 3.5.</div>
    <table id="allRatedPopupTable" style="width:100%; border-collapse:collapse;">
      <thead>
        <tr>
          <th>Time</th>
          <th>Rush</th><th>Mood</th><th>Social</th><th>Energy</th><th>Focus</th>
          <th>Anxiety</th><th>Impair</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>





<!-- All Rated OutOf10 Popup Modal -->
<div id="allRatedOutOf10PopupModal" style="display:none; position:fixed; inset:0; z-index:10000;">
  <div id="allRatedOutOf10PopupBackdrop" style="position:absolute; inset:0; background:rgba(0,0,0,0.45);"></div>
  <div id="allRatedOutOf10PopupCard" style="position:relative; margin:6vh auto; width:min(1100px,95vw); max-height:88vh; overflow:auto; background:#fff; border-radius:12px; box-shadow:0 10px 40px rgba(0,0,0,0.25); padding:16px; border:2px solid #007aff;">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px;">
      <h2>All Rated (/10)</h2>
      <button aria-label="Close" onclick="closeAllRatedOutOf10Popup()">Close</button>
    </div>
    <div style="font-size:11px; opacity:0.7; margin-bottom:6px;">Categories computed on 0–10 scale (Very&nbsp;Low, Low, Medium, High, Very&nbsp;High)</div>
    <table id="allRatedOutOf10PopupTable">
      <thead>
        <tr>
          <th>Timestamp</th>
          <th>Rush</th><th>Mood</th><th>Social</th><th>Energy</th><th>Focus</th><th>Anxiety</th><th>Impair</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<!-- All Rated 5‑Minute Popup Modal -->
<div id="allRated5MinutesPopupModal" style="display:none; position:fixed; inset:0; z-index:10000;">
  <div id="allRated5MinutesPopupBackdrop" style="position:absolute; inset:0; background:rgba(0,0,0,0.45);"></div>
  <div id="allRated5MinutesPopupCard" style="position:relative; margin:6vh auto; width:min(1100px,95vw); max-height:88vh; overflow:auto; background:#fff; border-radius:12px; box-shadow:0 10px 40px rgba(0,0,0,0.25); padding:16px; border:2px solid #007aff;">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px;">
      <h2>All Rated 5‑Minute</h2>
      <button aria-label="Close" onclick="closeAllRated5MinutesPopup()">Close</button>
    </div>
    <div style="font-size:11px; opacity:0.7; margin-bottom:6px;">Averages per 5‑minute block, then +5 to map onto 5‑10 scale</div>
    <table id="allRated5MinutesPopupTable">
      <thead>
        <tr>
          <th>Offset</th>
          <th>Rush</th><th>Mood</th><th>Social</th><th>Energy</th><th>Focus</th><th>Anxiety</th><th>Impair</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>


<!-- All Rated Popups (styled like original) -->
<script>
(function(){
  // ---- helpers ----
  function ensureTableBody(sel){const tb=document.querySelector(sel);if(tb) tb.innerHTML='';return tb;}
  function rowHtml(labelSet){ return (
    `<td class="cat ${labelSet.cls}"><span class="badge ${labelSet.cls}">${labelSet.label}</span></td>`
  );}
  function computeCat10(val){
    if(!Number.isFinite(val)||val===0) return {label:'None',cls:'none'};
    if(val<=2) return {label:'Very Low',cls:'verylow'};
    if(val<=4) return {label:'Low',cls:'low'};
    if(val<=6) return {label:'Medium',cls:'medium'};
    if(val<=8) return {label:'High',cls:'high'};
    return {label:'Very High',cls:'veryhigh'};
  }
  // ---- OutOf10 ----
  
function renderAllRatedOutOf10Popup(){
  window.syncLogDataFromTable && window.syncLogDataFromTable();
  var tb = document.querySelector('#allRatedOutOf10PopupTable tbody');
  if (!tb) return;
  var src = Array.isArray(window.logData) ? window.logData : [];
  var rows = [];
  src.forEach(function(r){
    var t = r.timestamp || r.Time || r.DateTime || r['Date/Time'] || '';
    var cells = [];
    if (typeof computeCat10 === 'function'){
      cells = computeCat10(r); // existing per-metric categoriser
    }else{
      ['Rush','Mood','Social','Energy','Focus','Anxiety','Impair','Score','Max','Min','Weighted','5Max'].forEach(function(k){
        cells.push('<td>'+ (r[k] != null ? r[k] : '') +'</td>');
      });
    }
    rows.push('<tr><td>'+t+'</td>'+cells.join('')+'</tr>');
  });
  tb.innerHTML = rows.join('');
}

</td>`+
        rowHtml(computeCat10(r.rushSum*2))+
        rowHtml(computeCat10(r.moodSum*2))+
        rowHtml(computeCat10(r.socialSum*2))+
        rowHtml(computeCat10(r.energySum*2))+
        rowHtml(computeCat10(r.focusSum*2))+
        rowHtml(computeCat10(computeRatingCategory('anxiety',r.anxietySum).val*2||r.anxietySum*2))+ /* fall back */
        rowHtml(computeCat10(computeRatingCategory('impair',r.impairSum).val*2||r.impairSum*2))+
      `</tr>`);
    });
    tb.innerHTML = rows.join('');
  }
  window.openAllRatedOutOf10Popup = function(){
    renderAllRatedOutOf10Popup();
    const m=document.getElementById('allRatedOutOf10PopupModal');if(m)m.style.display='block';
    const bd=document.getElementById('allRatedOutOf10PopupBackdrop');if(bd)bd.onclick=closeAllRatedOutOf10Popup;
  };
  window.closeAllRatedOutOf10Popup = function(){
    const m=document.getElementById('allRatedOutOf10PopupModal');if(m)m.style.display='none';
  };

  // ---- 5‑Minute ----
  
function fiveMinBuckets(){
  window.syncLogDataFromTable && window.syncLogDataFromTable();
  var src = Array.isArray(window.logData) ? window.logData.slice() : [];
  if (!src.length) return [];

  var map = new Map();
  for (var i=0;i<src.length;i++){
    var r = src[i] || {};
    var ts = parseTimestamp(r.timestamp);
    var bin = window.bucket5min(ts);
    if (bin == null){
      // try alternate fields
      var alt = r.Time || r.DateTime || r['Date/Time'] || r.ts || r.time || '';
      ts = parseTimestamp(alt);
      bin = window.bucket5min(ts);
    }
    if (bin == null) continue; // cannot place this row

    if (!map.has(bin)) map.set(bin, []);
    map.get(bin).push(r);
  }

  // Convert to sorted bucket array
  var out = Array.from(map.entries()).sort(function(a,b){return a[0]-b[0];}).map(function(e){
    return { bin: e[0], rows: e[1] };
  });
  return out;
}

;
    const startT = new Date(src[0].timestamp||0).getTime();
    src.forEach(r=>{
      const ts = new Date(r.timestamp||0).getTime();
      const diff = Math.max(1,Math.floor((ts-startT)/300000)); // 1‑based bin index
      (res[diff]=res[diff]||[]).push(r);
    });
    const out=[];
    Object.keys(res).sort((a,b)=>a-b).forEach(k=>{
      const list=res[k], agg={rush:0,mood:0,social:0,energy:0,focus:0,anxiety:0,impair:0};
      list.forEach(r=>{
        agg.rush+=r.rushSum||0; agg.mood+=r.moodSum||0; agg.social+=r.socialSum||0; agg.energy+=r.energySum||0;
        agg.focus+=r.focusSum||0; agg.anxiety+=r.anxietySum||0; agg.impair+=r.impairSum||0;
      });
      for(const f in agg){ agg[f]/=list.length; } // average
      out.push({offset:+k,values:agg});
    });
    return out;
  }
  
function renderAllRated5MinutesPopup(){
  window.syncLogDataFromTable && window.syncLogDataFromTable();
  var tb = document.querySelector('#allRated5MinutesPopupTable tbody');
  if (!tb) return;
  var buckets = fiveMinBuckets();
  var rows = [];
  buckets.forEach(function(b){
    // header row for bucket (optional)
    var startEpoch = b.bin * 300000; // ms
    var endEpoch = startEpoch + 299999;
    var startStr = new Date(startEpoch).toLocaleString();
    var endStr = new Date(endEpoch).toLocaleString();
    rows.push('<tr class="bucket"><td colspan="99">5‑min bucket: '+startStr+' – '+endStr+' ('+b.rows.length+' rows)</td></tr>');
    b.rows.forEach(function(r){
      var t = r.timestamp || r.Time || r.DateTime || r['Date/Time'] || '';
      // Build cells for rated metrics (existing compute function if present)
      var cells = [];
      if (typeof computeCategoryCells === 'function'){
        cells = computeCategoryCells(r); // project-specific; if exists
      }else{
        // fallback: dump known ratings if present
        ['Rush','Mood','Social','Energy','Focus','Anxiety','Impair','Score','Max','Min','Weighted','5Max'].forEach(function(k){
          cells.push('<td>'+ (r[k] != null ? r[k] : '') +'</td>');
        });
      }
      rows.push('<tr><td>'+t+'</td>'+cells.join('')+'</tr>');
    });
  });
  tb.innerHTML = rows.join('');
}

</td>`+
        rowHtml(computeCat10(b.values.rush+5))+
        rowHtml(computeCat10(b.values.mood+5))+
        rowHtml(computeCat10(b.values.social+5))+
        rowHtml(computeCat10(b.values.energy+5))+
        rowHtml(computeCat10(b.values.focus+5))+
        rowHtml(computeCat10(b.values.anxiety+5))+
        rowHtml(computeCat10(b.values.impair+5))+
      `</tr>`);
    });
    tb.innerHTML = rows.join('');
  }
  
window.openAllRated5MinutesPopup = function(){
  renderAllRated5MinutesPopup();
  var modal = document.getElementById('allRated5MinutesPopupModal');
  if (modal) modal.style.display = 'block';
};

;
  window.closeAllRated5MinutesPopup = function(){
    const m=document.getElementById('allRated5MinutesPopupModal');if(m)m.style.display='none';
  };
})();
</script>


<script>
// QuickStatsOne injector for all summaries
(function(){
  const METRICS = ['Rush','Mood','Social','Energy','Focus','Anxiety','Impair'];

  function numFromText(t){
    if (t == null) return null;
    const s = String(t).replace(/[^0-9.+-]/g,'');
    const n = parseFloat(s);
    return Number.isFinite(n) ? n : null;
  }
  function computeQuickStatsOneFromRow(tr){
    const vals = [];
    METRICS.forEach(k=>{
      // prefer explicit data-col match, fallback to indexed columns by header text
      let td = tr.querySelector(`td[data-col="${k}"]`);
      if (!td){
        const tbl = tr.closest('table');
        if (tbl){
          const ths = Array.from(tbl.querySelectorAll('thead th')).map(th=>th.textContent.trim());
          const idx = ths.findIndex(h=>h===k);
          if (idx>=0 && tr.children[idx]) td = tr.children[idx];
        }
      }
      if (!td) return;
      const v = numFromText(td.textContent);
      if (v != null) vals.push(v);
    });
    const over = vals.filter(v=>v>3);
    if (over.length===0) return "0 (0.00)";
    // Mode on one-decimal rounding of >3 set
    const counts = Object.create(null);
    let modeVal = null, modeCt = 0;
    over.forEach(v=>{
      const key = Number(v.toFixed(1));
      counts[key] = (counts[key]||0)+1;
      if (counts[key]>modeCt || (counts[key]===modeCt && (modeVal===null || key<modeVal))){
        modeCt = counts[key]; modeVal = key;
      }
    });
    const avg = over.reduce((a,b)=>a+b,0)/over.length;
    return `${modeVal.toFixed(1)} (${avg.toFixed(2)})`;
  }
  function ensureHeader(table){
    const thead = table.querySelector('thead');
    if (!thead) return;
    const tr = thead.querySelector('tr');
    if (!tr) return;
    if (tr.querySelector('th[data-col="QuickStatsOne"]')) return;
    // Only attach if table looks like a summary (has the 7 metrics)
    const hasMetrics = Array.from(thead.querySelectorAll('th')).some(th=>METRICS.includes(th.textContent.trim()));
    if (!hasMetrics) return;
    const th = document.createElement('th');
    th.setAttribute('data-col','QuickStatsOne');
    th.textContent = 'QuickStatsOne';
    tr.appendChild(th);
  }
  function appendCell(tr){
    if (tr.querySelector('td[data-col="QuickStatsOne"]')) return;
    const td = document.createElement('td');
    td.setAttribute('data-col','QuickStatsOne');
    td.textContent = computeQuickStatsOneFromRow(tr);
    tr.appendChild(td);
  }
  function processTable(table){
    ensureHeader(table);
    const tbody = table.querySelector('tbody');
    if (!tbody) return;
    Array.from(tbody.querySelectorAll('tr')).forEach(appendCell);
  }

  // Initial sweep after DOM is ready
  function sweep(){
    document.querySelectorAll('table').forEach(tbl=>{
      const head = tbl.querySelector('thead');
      if (!head) return;
      const cols = Array.from(head.querySelectorAll('th')).map(th=>th.textContent.trim());
      const ok = METRICS.some(m=>cols.includes(m));
      if (ok) processTable(tbl);
    });
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', sweep);
  } else {
    try{ sweep(); }catch(e){}
  }

  // Observe for dynamically added rows/tables used by summaries/popups
  const obs = new MutationObserver(ms=>{
    for (const m of ms){
      for (const node of m.addedNodes){
        if (!(node instanceof Element)) continue;
        if (node.matches('table')){
          processTable(node);
          continue;
        }
        if (node.matches('tr')){
          const tbl = node.closest('table');
          if (tbl) processTable(tbl);
          continue;
        }
        node.querySelectorAll && node.querySelectorAll('table').forEach(processTable);
      }
    }
  });
  obs.observe(document.body, {childList:true, subtree:true});
})();
</script>


<script>
// QuickStatsOne injector for all summaries
(function(){
  const METRICS = ['Rush','Mood','Social','Energy','Focus','Anxiety','Impair'];

  function numFromText(t){
    if (t == null) return null;
    const s = String(t).replace(/[^0-9.+-]/g,'');
    const n = parseFloat(s);
    return Number.isFinite(n) ? n : null;
  }
  function computeQuickStatsOneFromRow(tr){
    const vals = [];
    METRICS.forEach(k=>{
      // prefer explicit data-col match, fallback to indexed columns by header text
      let td = tr.querySelector(`td[data-col="${k}"]`);
      if (!td){
        const tbl = tr.closest('table');
        if (tbl){
          const ths = Array.from(tbl.querySelectorAll('thead th')).map(th=>th.textContent.trim());
          const idx = ths.findIndex(h=>h===k);
          if (idx>=0 && tr.children[idx]) td = tr.children[idx];
        }
      }
      if (!td) return;
      const v = numFromText(td.textContent);
      if (v != null) vals.push(v);
    });
    const over = vals.filter(v=>v>3);
    if (over.length===0) return "0 (0.00)";
    // Mode on one-decimal rounding of >3 set
    const counts = Object.create(null);
    let modeVal = null, modeCt = 0;
    over.forEach(v=>{
      const key = Number(v.toFixed(1));
      counts[key] = (counts[key]||0)+1;
      if (counts[key]>modeCt || (counts[key]===modeCt && (modeVal===null || key<modeVal))){
        modeCt = counts[key]; modeVal = key;
      }
    });
    const avg = over.reduce((a,b)=>a+b,0)/over.length;
    return `${modeVal.toFixed(1)} (${avg.toFixed(2)})`;
  }
  function ensureHeader(table){
    const thead = table.querySelector('thead');
    if (!thead) return;
    const tr = thead.querySelector('tr');
    if (!tr) return;
    if (tr.querySelector('th[data-col="QuickStatsOne"]')) return;
    // Only attach if table looks like a summary (has the 7 metrics)
    const hasMetrics = Array.from(thead.querySelectorAll('th')).some(th=>METRICS.includes(th.textContent.trim()));
    if (!hasMetrics) return;
    const th = document.createElement('th');
    th.setAttribute('data-col','QuickStatsOne');
    th.textContent = 'QuickStatsOne';
    tr.appendChild(th);
  }
  function appendCell(tr){
    if (tr.querySelector('td[data-col="QuickStatsOne"]')) return;
    const td = document.createElement('td');
    td.setAttribute('data-col','QuickStatsOne');
    td.textContent = computeQuickStatsOneFromRow(tr);
    tr.appendChild(td);
  }
  function processTable(table){
    ensureHeader(table);
    const tbody = table.querySelector('tbody');
    if (!tbody) return;
    Array.from(tbody.querySelectorAll('tr')).forEach(appendCell);
  }

  // Initial sweep after DOM is ready
  function sweep(){
    document.querySelectorAll('table').forEach(tbl=>{
      const head = tbl.querySelector('thead');
      if (!head) return;
      const cols = Array.from(head.querySelectorAll('th')).map(th=>th.textContent.trim());
      const ok = METRICS.some(m=>cols.includes(m));
      if (ok) processTable(tbl);
    });
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', sweep);
  } else {
    try{ sweep(); }catch(e){}
  }

  // Observe for dynamically added rows/tables used by summaries/popups
  const obs = new MutationObserver(ms=>{
    for (const m of ms){
      for (const node of m.addedNodes){
        if (!(node instanceof Element)) continue;
        if (node.matches('table')){
          processTable(node);
          continue;
        }
        if (node.matches('tr')){
          const tbl = node.closest('table');
          if (tbl) processTable(tbl);
          continue;
        }
        node.querySelectorAll && node.querySelectorAll('table').forEach(processTable);
      }
    }
  });
  obs.observe(document.body, {childList:true, subtree:true});
})();
</script>


<!-- All Rated 5‑Minute (/10) Popup Modal -->
<div id="allRated5MinutesOutOf10PopupModal" style="display:none; position:fixed; inset:0; z-index:10000;">
  <div id="allRated5MinutesOutOf10PopupBackdrop" style="position:absolute; inset:0; background:rgba(0,0,0,0.45);"></div>
  <div id="allRated5MinutesOutOf10PopupCard" style="position:relative; margin:6vh auto; width:min(1100px,95vw); max-height:88vh; overflow:auto; background:#fff; border-radius:12px; box-shadow:0 10px 40px rgba(0,0,0,0.25); padding:16px; border:2px solid #007aff;">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px;">
      <h2>All Rated 5‑Minute (/10)</h2>
      <button aria-label="Close" onclick="closeAllRated5MinutesOutOf10Popup()">Close</button>
    </div>
    <div style="font-size:11px; opacity:0.7; margin-bottom:6px;">Averages per 5‑minute block mapped to a 0–10 scale (×2), then categorised (Very&nbsp;Low → Very&nbsp;High)</div>
    <table id="allRated5MinutesOutOf10PopupTable">
      <thead>
        <tr>
          <th>Offset</th>
          <th>Rush</th><th>Mood</th><th>Social</th><th>Energy</th><th>Focus</th><th>Anxiety</th><th>Impair</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script>
// Self-contained renderer for "All Rated 5‑Minute (/10)" to avoid coupling
(function(){
  function ensureTB(){ var tb = document.querySelector('#allRated5MinutesOutOf10PopupTable tbody'); if (!tb && document.getElementById('allRated5MinutesOutOf10PopupTable')) { tb = document.createElement('tbody'); document.getElementById('allRated5MinutesOutOf10PopupTable').appendChild(tb);} return tb; }
  function cat10(v){ // Very Low(<=2), Low(<=4), Medium(<=6), High(<=8), Very High(>8)
    var x = Number(v); if (!isFinite(x)) x = 0;
    if (x <= 2)  return {cls:'verylow',  label:'Very Low'};
    if (x <= 4)  return {cls:'low',      label:'Low'};
    if (x <= 6)  return {cls:'medium',   label:'Medium'};
    if (x <= 8)  return {cls:'high',     label:'High'};
    return {cls:'veryhigh', label:'Very High'};
  }
  function cell(v){
    var c = cat10(v);
    return '<td class="cat '+c.cls+'"><span class="badge '+c.cls+'">'+c.label+'</span> <span style="opacity:.6">('+ (Number(v).toFixed(2)) +')</span></td>';
  }
  function fiveMinBucketsLocal(){
    var src = Array.isArray(window.logData) ? window.logData : []; if(!src.length) return [];
    var res = {};
    var t0  = src[0] && src[0].timestamp ? new Date(src[0].timestamp).getTime() : Date.now();
    src.forEach(function(r){
      var ts = r.timestamp ? new Date(r.timestamp).getTime() : t0;
      var idx = Math.max(1, Math.floor((ts - t0)/300000)); // 5m bins, 1-based
      (res[idx] = res[idx] || []).push(r);
    });
    var out = [];
    Object.keys(res).sort(function(a,b){return a-b;}).forEach(function(k){
      var list = res[k], agg = {rush:0,mood:0,social:0,energy:0,focus:0,anxiety:0,impair:0};
      list.forEach(function(r){
        agg.rush+=r.rushSum||0; agg.mood+=r.moodSum||0; agg.social+=r.socialSum||0; agg.energy+=r.energySum||0;
        agg.focus+=r.focusSum||0; agg.anxiety+=r.anxietySum||0; agg.impair+=r.impairSum||0;
      });
      for (var f in agg){ agg[f] = list.length ? (agg[f]/list.length) : 0; } // 0..5
      out.push({offset:+k, values:agg});
    });
    return out;
  }
  function render(){
    var tb = ensureTB(); if (!tb) return;
    var rows = [];
    fiveMinBucketsLocal().forEach(function(b){
      var offStr = String(b.offset*5).padStart(2,'0')+':00';
      // Map 0..5 → 0..10 by ×2 (no +5 shift)
      rows.push('<tr><td>+'+offStr+'</td>'
        + cell((b.values.rush||0)*2)
        + cell((b.values.mood||0)*2)
        + cell((b.values.social||0)*2)
        + cell((b.values.energy||0)*2)
        + cell((b.values.focus||0)*2)
        + cell((b.values.anxiety||0)*2)
        + cell((b.values.impair||0)*2)
        + '</tr>');
    });
    tb.innerHTML = rows.join('');
  }
  window.openAllRated5MinutesOutOf10Popup = function(){
    try{ render(); }catch(e){ console.warn(e); }
    var m = document.getElementById('allRated5MinutesOutOf10PopupModal'); if (m) m.style.display='block';
    var bd = document.getElementById('allRated5MinutesOutOf10PopupBackdrop'); if (bd) bd.onclick = closeAllRated5MinutesOutOf10Popup;
  };
  window.closeAllRated5MinutesOutOf10Popup = function(){
    var m = document.getElementById('allRated5MinutesOutOf10PopupModal'); if (m) m.style.display='none';
  };
})();
</script>

<script>
(function(){
  try {
    if (typeof window.openAutoSliderC !== 'function') {
      window.openAutoSliderC = function(){
        var m = document.getElementById('autoSliderCModal'); if (m) m.style.display='block';
        if (typeof refreshAutoSliderC === 'function') try { refreshAutoSliderC(); } catch(e){}
      };
    }
    if (typeof window.openAutoSliderD !== 'function') {
      window.openAutoSliderD = function(){
        var m = document.getElementById('autoSliderDModal'); if (m) m.style.display='block';
        if (typeof startAutoD === 'function') try { startAutoD(); } catch(e){}
      };
    }
  } catch(e){}
})();
</script>

<script>
(function(){
  // Harden createSummaryPopupTable to avoid earlier partial blocks
  try {
    window.createSummaryPopupTable = function(){
      if (typeof ensureSummaryPopup === 'function') ensureSummaryPopup();
      try {
        var endMs = Date.now();
        var M = (typeof computeRollingMeans==='function') ? computeRollingMeans(endMs, (typeof SUMMARY_WINDOW_MINUTES!=='undefined'? SUMMARY_WINDOW_MINUTES : 5)) : null;
        var C = M && (typeof computeCompositeFromMeans==='function') ? computeCompositeFromMeans(M) : null;
        var d = new Date();
        if (M && typeof appendSummaryRowToTable === 'function') {
          appendSummaryRowToTable('summaryPopupTable', d, M, C, {bold:false, labelSuffix:' '+(typeof SUMMARY_WINDOW_MINUTES!=='undefined'? SUMMARY_WINDOW_MINUTES : 5)+'m Now'});
        }
      } catch(e){ console.warn(e); }
    };
  } catch(e){}
})();
</script>

<script>
document.addEventListener("click", function(e){
  var t = e.target;
  if (!t) return;
  var id = (t.id || "");
  if (id === "backfillBtnGlobal" || /^backfillBtn\d+$/.test(id)) {
    if (typeof backfillAll === "function") { backfillAll(); }
  }
});
</script>
<script>
document.addEventListener("DOMContentLoaded", function(){
  var thead = document.querySelectorAll('#logTable thead th');
  var rows = document.querySelectorAll('#logTable tbody tr');
  rows.forEach(function(tr){
    Array.from(tr.children).forEach(function(td, idx){
      var h = thead[idx] ? String(thead[idx].textContent).trim() : "";
      if (h) td.setAttribute('data-col', h);
    });
  });
});
</script>
<script>
(function(){
  if (typeof window.computeScaleFocusFromNotes !== "function") {
    window.computeScaleFocusFromNotes = function(notes){
      try {
        var text = (notes == null ? "" : String(notes));
        var tokens = new Set(text.split(/\s+/));
        var score = 0;
        if (tokens.has("Wired")) score = Math.max(score, 7);
        if (tokens.has("Plumes")) score = Math.max(score, 10);
        if (tokens.has("Billowing")) score = Math.max(score, 10);
        if (tokens.has("Rush")) score = Math.max(score, 10);
        return score;
      } catch (e) { return 0; }
    };
  }
})();
</script>

<script>
(function(){
  function applyDockPadding(){
    try{
      var dock = document.querySelector('.summary-controls');
      if(!dock) return;
      var h = dock.offsetHeight || 0;
      document.body.style.paddingTop = (h ? (h + 10) : 0) + 'px';
    }catch(e){}
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', applyDockPadding);
  }else{
    applyDockPadding();
  }
  window.addEventListener('resize', applyDockPadding);
})();
</script>

<script>

// === Timestamp parsing & bucketing helpers (robust for Safari/WebKit) ===
(function(){
  // Parse a timestamp string into a local epoch milliseconds number.
  // Accepts ISO, 'YYYY/MM/DD HH:MM:SS', 'YYYY-MM-DD HH:MM:SS', 'DD/MM/YYYY HH:MM:SS' (best effort).
  window.parseTimestamp = function(ts){
    if (ts == null) return NaN;
    if (typeof ts === 'number') return Number.isFinite(ts) ? ts : NaN;
    if (typeof ts !== 'string') return NaN;
    var s = ts.trim();
    if (!s) return NaN;

    // 1) Native Date first
    var t = new Date(s).getTime();
    if (!Number.isNaN(t)) return t;

    // 2) Replace slash with dash and add 'T' if space separator
    var s2 = s.replace(/\//g,'-').replace(/(\d)\s+(\d)/,'$1T$2');
    t = new Date(s2).getTime();
    if (!Number.isNaN(t)) return t;

    // 3) Explicit regex for YYYY/MM/DD HH:MM:SS or YYYY-MM-DD HH:MM:SS
    var m = s.match(/^(\d{4})[\/-](\d{1,2})[\/-](\d{1,2})[ T](\d{1,2}):(\d{2})(?::(\d{2}))?$/);
    if (m){
      var Y = +m[1], Mo = +m[2]-1, D = +m[3], h = +m[4], mi = +m[5], se = +(m[6]||0);
      var d = new Date(Y, Mo, D, h, mi, se, 0);
      return d.getTime();
    }

    // 4) DD/MM/YYYY HH:MM:SS (common CSV)
    m = s.match(/^(\d{1,2})[\/](\d{1,2})[\/](\d{4})[ T](\d{1,2}):(\d{2})(?::(\d{2}))?$/);
    if (m){
      var Dd = +m[1], Mm = +m[2]-1, Yy = +m[3], hh = +m[4], mm = +m[5], ss = +(m[6]||0);
      var d2 = new Date(Yy, Mm, Dd, hh, mm, ss, 0);
      return d2.getTime();
    }

    return NaN;
  };

  window.bucket5min = function(epochMs){
    if (!Number.isFinite(epochMs)) return null;
    return Math.floor(epochMs / 300000); // absolute 5-min bin from epoch
  };
  window.bucket10min = function(epochMs){
    if (!Number.isFinite(epochMs)) return null;
    return Math.floor(epochMs / 600000); // absolute 10-min bin from epoch
  };
})();

</script>

<script>

// === Unify data source for popups ===
window.syncLogDataFromTable = function(){
  try{
    if (typeof rowsFromMain === 'function'){
      var rows = rowsFromMain();
      if (Array.isArray(rows) && rows.length){
        // Map to logData shape minimally: timestamp + raw metrics
        window.logData = rows.map(function(r){
          var t = r.ts || r.timestamp || r.Time || r.time || '';
          var out = Object.assign({}, r);
          out.timestamp = (typeof t === 'number') ? t : t;
          return out;
        });
        return;
      }
    }
  }catch(e){ /* fall through */ }

  // Fallback DOM extraction from #logTable
  var tbl = document.querySelector('#logTable');
  if (!tbl) return;
  var hs = Array.from(tbl.querySelectorAll('thead th')).map(function(th){
    var k = th.getAttribute('data-col') || th.textContent || '';
    return (k||'').trim();
  });
  var rows = [];
  Array.from(tbl.querySelectorAll('tbody tr')).forEach(function(tr){
    if (tr.offsetParent === null) return; // skip hidden
    var obj = {};
    Array.from(tr.children).forEach(function(td, i){
      var key = hs[i] || ('col'+i);
      obj[key] = td.textContent.trim();
    });
    // normalise timestamp keys
    obj.timestamp = obj['Timestamp'] || obj['Time'] || obj['DateTime'] || obj['Date/Time'] || obj['ts'] || obj['time'] || obj.timestamp || '';
    rows.push(obj);
  });
  if (rows.length){
    window.logData = rows;
  }
};

</script>

<script>

function tenMinBuckets(){
  window.syncLogDataFromTable && window.syncLogDataFromTable();
  var src = Array.isArray(window.logData) ? window.logData.slice() : [];
  if (!src.length) return [];

  var map = new Map();
  for (var i=0;i<src.length;i++){
    var r = src[i] || {};
    var ts = parseTimestamp(r.timestamp);
    var bin = window.bucket10min(ts);
    if (bin == null){
      var alt = r.Time || r.DateTime || r['Date/Time'] || r.ts || r.time || '';
      ts = parseTimestamp(alt);
      bin = window.bucket10min(ts);
    }
    if (bin == null) continue;
    if (!map.has(bin)) map.set(bin, []);
    map.get(bin).push(r);
  }
  var out = Array.from(map.entries()).sort(function(a,b){return a[0]-b[0];}).map(function(e){
    return { bin: e[0], rows: e[1] };
  });
  return out;
}

</script>

<script>

function renderAllRated10MinutesPopup(){
  window.syncLogDataFromTable && window.syncLogDataFromTable();
  var tb = document.querySelector('#allRated10MinutesPopupTable tbody');
  if (!tb) return;
  var buckets = tenMinBuckets();
  var rows = [];
  buckets.forEach(function(b){
    var startEpoch = b.bin * 600000; // ms
    var endEpoch = startEpoch + 599999;
    var startStr = new Date(startEpoch).toLocaleString();
    var endStr = new Date(endEpoch).toLocaleString();
    rows.push('<tr class="bucket"><td colspan="99">10‑min bucket: '+startStr+' – '+endStr+' ('+b.rows.length+' rows)</td></tr>');
    b.rows.forEach(function(r){
      var t = r.timestamp || r.Time || r.DateTime || r['Date/Time'] || '';
      var cells = [];
      if (typeof computeCategoryCells === 'function'){
        cells = computeCategoryCells(r);
      }else{
        ['Rush','Mood','Social','Energy','Focus','Anxiety','Impair','Score','Max','Min','Weighted','5Max'].forEach(function(k){
          cells.push('<td>'+ (r[k] != null ? r[k] : '') +'</td>');
        });
      }
      rows.push('<tr><td>'+t+'</td>'+cells.join('')+'</tr>');
    });
  });
  tb.innerHTML = rows.join('');
}
window.openAllRated10MinutesPopup = function(){
  renderAllRated10MinutesPopup();
  var modal = document.getElementById('allRated10MinutesPopupModal');
  if (modal) modal.style.display = 'block';
};

</script>


<!-- Rush Mode Modal (injected) -->
<div id="rushModeModal" style="display:none; position:fixed; top:15%; left:50%; transform:translateX(-50%); background:#fff; padding:20px; border:2px solid #007aff; border-radius:8px; box-shadow:0 4px 8px rgba(0,0,0,0.2); z-index:1000;">
  <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px;">
    <div style="font-weight:700; font-size:18px;">Rush Mode</div>
    <button aria-label="Close" onclick="closeRushMode()">Close</button>
  </div>
  <div class="score-columns" id="rushModeButtons"></div>
  <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:10px;">
    <button onclick="applyRushMode()">Apply</button>
    <button onclick="applyRushModeAndAdd()">Apply & Add Entry</button>
    <button onclick="applyRushModeAndAddStay()">Apply, Add & Stay</button>
  </div>
</div>



<script id="rush-mode-logic">
(function(){
// BOOKMARK
  // Configure which metrics/values Rush Mode shows (independent of Rapid)
  const RUSH_MODE_METRICS = ['rush','mood','social','energy','focus','anxiety','impair'];
  const RUSH_MODE_VALUES  = [6,5,4,3,2,1,0,'',0.75,-0.25,-0.5];

  // Local, Rush-Mode-only selections
  const rushModeSelections = Object.create(null);

  function getRushModeLabel(metric, value){
    try{
      const key = String(value);
      if (typeof RAPID_LABEL_OVERRIDES !== 'undefined' &&
          RAPID_LABEL_OVERRIDES && RAPID_LABEL_OVERRIDES[metric] &&
          RAPID_LABEL_OVERRIDES[metric][key] != null){
        return RAPID_LABEL_OVERRIDES[metric][key];
      }
      if (typeof labelMappings !== 'undefined' && labelMappings[metric]){
        return labelMappings[metric][value] || '';
      }
    }catch(e){}
    return '';
  }

  window.buildRushModeButtons = function(){
    try{
      const container = document.getElementById('rushModeButtons');
      if (!container) return;
      container.innerHTML = '';
      RUSH_MODE_METRICS.forEach(metric=>{
        const col = document.createElement('div');
        col.className = 'score-column';
        const t = document.createElement('strong');
        t.innerText = metric.charAt(0).toUpperCase() + metric.slice(1);
        col.appendChild(t);
        RUSH_MODE_VALUES.forEach(v=>{
          const b = document.createElement('button');
b
          const label = getRushModeLabel(metric, v);
          b.innerText = `${v}: ${label}`;
          b.onclick = ()=>{
            if (!Array.isArray(rushModeSelections[metric])) rushModeSelections[metric] = [];
            const i = rushModeSelections[metric].indexOf(v);
            if (i < 0){ rushModeSelections[metric].push(v); b.classList.add('selected-score'); }
            else { rushModeSelections[metric].splice(i,1); b.classList.remove('selected-score'); }
          };
          // Preselect already chosen values
          try{
            if (Array.isArray(rushModeSelections[metric]) && rushModeSelections[metric].includes(v)){
              b.classList.add('selected-score');
            }
          }catch(e){}
          col.appendChild(b);
        });
        container.appendChild(col);
      });
    }catch(e){ console.warn(e); }
  };

  window.openRushMode = function(){
    try{
      buildRushModeButtons();
      var m = document.getElementById('rushModeModal');
      if (!m) return;
      try{
        if (m.parentElement !== document.body){
          document.body.appendChild(m);
        }
        m.style.zIndex = '10000';
      }catch(e){}
      m.style.display = 'block';
    }catch(e){ console.warn(e); }
  };
  window.closeRushMode = function(){
    try{
      const m = document.getElementById('rushModeModal'); if (m) m.style.display = 'none';
    }catch(e){ console.warn(e); }
  };

  function normalizeRushModeSelections(){
    try{
      RUSH_MODE_METRICS.forEach(f=>{
        if (!Array.isArray(rushModeSelections[f])) rushModeSelections[f] = [];
        rushModeSelections[f] = Array.from(new Set(rushModeSelections[f])).sort((a,b)=>b-a);
      });
    }catch(e){}
  }

  // Apply into your existing global selections object so addEntry() uses them
  window.applyRushMode = function(){
    try{
      normalizeRushModeSelections();
      if (typeof selections === 'object' && selections){
        RUSH_MODE_METRICS.forEach(f=>{
          selections[f] = rushModeSelections[f] ? rushModeSelections[f].slice() : [];
        });
      }
      closeRushMode();
      try { if (typeof buildButtons==='function') buildButtons(); } catch(e){}
    }catch(e){ console.warn(e); }
  };

  function finalizeRushEntryAsRushMode(){
    try{
      if (!Array.isArray(logData) || !logData.length) return;
      const entry = logData[logData.length - 1];
      entry.inputSource = 'RushMode';
      ['rush','energy','focus','anxiety','mood','social','impair','anxiety'].forEach(m=>{
        try{
          const arr = Array.isArray(entry[m]) ? entry[m] : [];
          const labs = [];
          const vals = Array.from(new Set(arr.slice().sort((a,b)=>b-a)));
          vals.forEach(v=>{
            const L = getRushModeLabel(m, v);
            if (L) labs.push(L);
          });
          entry[m + 'Label'] = labs.join(', ');
        }catch(e){}
      });
      try { setTripLogDebounced(logData); } catch(e){}
      try { renderTable(); } catch(e){}
    }catch(e){ console.warn(e); }
  }

  window.applyRushModeAndAdd = function(){
    try{
      applyRushMode(); // normalises + copies selections, closes modal
      window._rapidLabelMode = false;
      window._rapidInputSource = 'RushMode';
      if (typeof addEntry === 'function') addEntry('rushMode');
      finalizeRushEntryAsRushMode();
      window.clearRushModeSelections();
      window._rapidInputSource = 'Main';
    }catch(e){ console.warn(e); }
  };

  window.applyRushModeAndAddStay = function(){
    try{
      normalizeRushModeSelections();
      if (typeof selections === 'object' && selections){
        RUSH_MODE_METRICS.forEach(f=>{
          selections[f] = rushModeSelections[f] ? rushModeSelections[f].slice() : [];
        });
      }
      window._rapidInputSource = 'RushMode';
      if (typeof addEntry === 'function') addEntry('rushMode');
      finalizeRushEntryAsRushMode();
      window.clearRushModeSelections();
      window._rapidInputSource = 'Main';
      try{ buildRushModeButtons(); }catch(e){}
      try{ const m=document.getElementById('rushModeModal'); if (m) m.style.display='block'; }catch(e){}
    }catch(e){ console.warn(e); }
  };
  // Clear Rush Mode selections and UI state
  window.clearRushModeSelections = function(){
    try{
      Object.keys(rushModeSelections).forEach(k => { rushModeSelections[k] = []; });
      // Also clear global selections for Rush metrics to avoid carry-over
      try{
        if (typeof selections === 'object' && selections){
          ['rush','mood','social','energy','focus','anxiety','impair'].forEach(f=>{
            selections[f] = [];
          });
        }
      }catch(e){}
      // If modal is open, remove visual selection state
      const modal = document.getElementById('rushModeModal');
      if (modal && modal.style.display !== 'none'){
        const btns = modal.querySelectorAll('.score-column button.selected-score');
        btns.forEach(b => b.classList.remove('selected-score'));
      }
    }catch(e){ console.warn(e); }
  };

})();</script>



<!-- Rush Mode launcher (you can reposition this anywhere in your toolbar) -->

<button id="rushModeBtn" type="button" title="Open Rush Mode" onclick="openRushMode()">Rush Mode</button>
<button id="fastModeBtn" type="button" title="Open Fast Mode" onclick="openFastMode()">Fast Mode</button>

<!-- Scoped button sizing for Rush Mode modal -->
<!-- 
BOOKMARK FOR RUSH MODE BUTTON SIZES
 -->
<style id="rush-mode-size-override">
  #rushModeModal .score-column button {
    width: 150px;
    height: 30px;
    font-size: 13px;
  }
</style>




<!-- Legacy Unlocked toolbar injection removed (2025/10/31). Permanent header button is canonical. -->



<script id="dose-review-segmentation">
(function(){
  function getDrugValue(row){
    const v = (row && (row.drug ?? row.Drug ?? row.DRUG ?? '')).toString().trim();
    return v;
  }
  function getTimerKeys(sampleRow){
    if (!sampleRow || typeof sampleRow !== 'object') return [];
    const keys = Object.keys(sampleRow);
    const sinceKeys = keys.filter(k => /^since/i.test(k));
    return sinceKeys;
  }
  function num(x){
    const n = (typeof x === 'string') ? parseFloat(x) : (typeof x === 'number' ? x : NaN);
    return Number.isFinite(n) ? n : NaN;
  }
  function timersReset(prev, curr, timerKeys){
    try{
      for (const k of timerKeys){
        const p = num(prev?.[k]);
        const c = num(curr?.[k]);
        if (Number.isFinite(p) && Number.isFinite(c) && c < p) return true;
        if (Number.isFinite(p) && p > 0 && Number.isFinite(c) && c === 0) return true;
      }
    }catch(e){}
    return false;
  }
  window.segmentByTimerResetAndDrug = function(rows){
    const data = Array.isArray(rows) ? rows.slice() : [];
    const segments = [];
    if (!data.length) return segments;
    const timerKeys = getTimerKeys(data.find(r => r && typeof r === 'object'));
    let segStart = -1;
    function pushSeg(endIdx){
      if (segStart >= 0 && endIdx >= segStart){
        segments.push({
          startIndex: segStart,
          endIndex: endIdx,
          rows: data.slice(segStart, endIdx + 1)
        });
      }
    }
    for (let i = 0; i < data.length && segStart < 0; i++){
      if (getDrugValue(data[i]).length){ segStart = i; }
    }
    if (segStart < 0){
      segments.push({ startIndex: 0, endIndex: data.length - 1, rows: data.slice() });
      return segments;
    }
    for (let i = segStart + 1; i < data.length; i++){
      const prev = data[i - 1];
      const curr = data[i];
      const drug = getDrugValue(curr);
      const reset = timersReset(prev, curr, timerKeys);
      const hasDrug = drug.length > 0;
      if (reset && hasDrug){
        pushSeg(i - 1);
        segStart = i;
      }
    }
    pushSeg(data.length - 1);
    return segments;
  };

  // Optional alias to preserve old call sites:
  window.segmentRowsBySince = window.segmentByTimerResetAndDrug;

  // Integration wrapper: prefer new segmentation when building Dose Review
  window.buildDoseReviewModal = (function(orig){
    return function(){
      try{
        const rows = (typeof getLogDataSorted === 'function')
          ? getLogDataSorted()
          : (Array.isArray(window.logData) ? window.logData.slice().sort((a,b)=> (a.timestamp||0)-(b.timestamp||0)) : []);
        const segments = window.segmentByTimerResetAndDrug(rows);

        const modal = document.getElementById('doseReviewModal');
        const tbody = modal?.querySelector('tbody');
        if (tbody) tbody.innerHTML = '';

        if (tbody){
          segments.forEach((seg, idx)=>{
            const trH = document.createElement('tr');
            const tdH = document.createElement('td');
            tdH.colSpan = 99;
            const firstTs = seg.rows[0]?.timestamp ?? '';
            const lastTs  = seg.rows[seg.rows.length-1]?.timestamp ?? '';
            tdH.textContent = `Segment ${idx+1} — rows ${seg.startIndex}..${seg.endIndex} — ${firstTs} → ${lastTs}`;
            tdH.style.fontWeight = '700';
            trH.appendChild(tdH);
            tbody.appendChild(trH);

            seg.rows.forEach(r=>{
              const tr = document.createElement('tr');
              const cols = [
                r.timestamp ?? '',
                getDrugValue(r),
                (r.qty ?? r.quantity ?? ''),
                (r.roa ?? ''),
                (r.rush ?? ''),
                (r.energy ?? ''),
                (r.focus ?? ''),
                (r.anxiety ?? ''),
              ];
              cols.forEach(c=>{
                const td = document.createElement('td');
                td.textContent = (c==null?'':c);
                tr.appendChild(td);
              });
              tbody.appendChild(tr);
            });
          });
        }
        if (modal) modal.style.display = 'block';
      }catch(e){
        console.warn('Dose Review build failed:', e);
        if (typeof orig === 'function') try{ return orig(); }catch(_) {}
      }
    };
  })(window.buildDoseReviewModal);
})();
</script>


<script id="rush-mode-delegated-open">
document.addEventListener('click', function(ev){
  try{
    const t = ev.target.closest('#rushModeBtn,[data-open="rushMode"]');
    if (!t) return;
    ev.preventDefault();
    if (typeof window.openRushMode === 'function'){
      window.openRushMode();
    } else {
      console.warn('openRushMode not available yet');
    }
  }catch(e){ console.warn(e); }
}, true);
</script>


<!-- Running Average: dynamic toolbar button injection -->
<script>
// Timestamp: 2025/10/18 00:00:00
(function(){
  function ensureRunningAverageButton(){
    if (document.getElementById('runningAverageBtn')) return;
    var btn = document.createElement('button');
btn
    btn.id = 'runningAverageBtn';
    btn.type = 'button';
    btn.textContent = 'Running Average';
    btn.title = 'Open Running Average logger';
    btn.onclick = function(){ if (typeof openRunningAverage === 'function') openRunningAverage(); };
    btn.className = (btn.className || '') + ' sts-btn';
    // Try common containers
    var targets = [
      document.querySelector('.summary-controls'),
      document.querySelector('#summaryControls'),
      document.querySelector('#toolbar'),
      document.querySelector('.toolbar'),
      document.querySelector('.controls'),
      document.querySelector('#controls'),
      document.querySelector('header'),
      document.body
    ];
    for (var i=0;i<targets.length;i++){
      if (targets[i]){ targets[i].appendChild(btn); return; }
    }
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureRunningAverageButton);
  } else {
    ensureRunningAverageButton();
  }
})();
</script>


<!-- ======================== Running Average Modal ======================== -->
<div id="runningAverageModal" style="display:none; position:fixed; inset:0; z-index:10003;">
  <div style="position:absolute; inset:0; background:rgba(0,0,0,0.45);"></div>
  <div style="position:relative; margin:6vh auto; width:min(1200px,94vw); max-height:88vh; overflow:auto; background:#fff; border:2px solid #007aff; border-radius:12px; box-shadow:0 10px 34px rgba(0,0,0,0.25); padding:14px;">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px;">
      <div style="font-weight:700; font-size:18px;">Running Average (5-minute mean, 1-minute cadence)</div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="runningAvgStartBtn" onclick="runningAverageStart()">Start</button>
        <button id="runningAvgStopBtn"  onclick="runningAverageStop()">Stop</button>
        <button id="runningAvgExportBtn" onclick="exportRunningAverageCSV()">Export CSV</button>
        <button id="runningAvgClearBtn"  onclick="clearRunningAverage()">Clear</button>
        <button id="runningAvgCloseBtn"  onclick="closeRunningAverage()">Close</button>
      </div>
    </div>

    <div id="runningAverageMeta" style="font-size:11px; opacity:0.7; margin-bottom:6px;">
      Cadence: every 1 minute (aligned to :00). Window: last 5 minutes ending at the label minute.
    </div>

    <table id="runningAverageTable" style="width:100%; border-collapse:collapse; background:#fff;">
      <thead>
        <tr id="runningHeadRow">
          <th>Time</th>
          <th>Rush</th><th>Mood</th><th>Social</th><th>Energy</th><th>Focus</th>
          <th>Anxiety</th><th>Impair</th>
          <th>Score</th><th>Max</th><th>Min</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <div style="font-size:11px; opacity:0.65; margin-top:6px;">
      Source: visible rows from the main table only.
    </div>
  </div>
</div>
<!-- ====================== /Running Average Modal ======================== -->


<!-- STS: Running Average (5-minute rolling means, 1-minute cadence) -->
<script>
// Timestamp: 2025/10/18 00:00:00 (Australia/Sydney)
(function(){
  const TABLE_ID = 'runningAverageTable';
  const MODAL_ID = 'runningAverageModal';
  const LS_KEY   = 'STS_RUNNING_AVG_v1';

  const METRICS = ['rush','mood','social','energy','focus','anxiety','impair'];
  const COLS = ['Time','Rush','Mood','Social','Energy','Focus','Anxiety','Impair','Score','Max','Min'];

  // Format "YYYY/MM/DD HH:MM:SS"
  function pad(n){ return String(n).padStart(2,'0'); }
  function fmtStamp(d){
    return d.getFullYear() + '/' + pad(d.getMonth()+1) + '/' + pad(d.getDate()) + ' ' +
           pad(d.getHours()) + ':' + pad(d.getMinutes()) + ':' + pad(d.getSeconds());
  }
  function minuteLabel(d){ return pad(d.getHours()) + ':' + pad(d.getMinutes()) + ' Average'; }

  // Snapshot main table (reads *only* main log rows)
  function snapshotMain(){
    const trs = Array.from(document.querySelectorAll('#logTable tbody tr'));
    return trs.map(tr=>{
      const ts = +(tr.getAttribute('data-ts') || 0);
      function get(field){
        const td = tr.querySelector(`td[data-field="${field}Sum"]`);
        if (!td) return 0;
        const v = parseFloat(td.getAttribute('data-value') || td.textContent || '0');
        return Number.isFinite(v) ? v : 0;
      }
      return {
        _ts: ts,
        rush: get('rush'), mood: get('mood'), social: get('social'),
        energy: get('energy'), focus: get('focus'), anxiety: get('anxiety'), impair: get('impair')
      };
    }).filter(o => o._ts > 0);
  }

  // Means over [startMs, endMs)
  function meansForWindow(startMs, endMs){
    const snap = snapshotMain();
    const sel  = snap.filter(e => e._ts >= startMs && e._ts < endMs);
    if (!sel.length) return null;
    const sums = {rush:0,mood:0,social:0,energy:0,focus:0,anxiety:0,impair:0};
    sel.forEach(e => METRICS.forEach(k => sums[k] += (e[k]||0)));
    const out = {}; METRICS.forEach(k => out[k] = +(sums[k]/sel.length));
    return out;
  }

  // Derived fields from means
  function extrasFromMeans(M){
    if (!M) return {Score:null, Max:null, Min:null};
    const pos = [M.rush,M.mood,M.social,M.energy,M.focus].map(Number).filter(Number.isFinite);
    const Score = (M.rush+M.mood+M.social+M.energy+M.focus) - (M.anxiety+M.impair);
    const Max   = pos.length ? Math.max(...pos) : null;
    const Min   = pos.length ? Math.min(...pos) : null;
    return {Score, Max, Min};
  }

  // Render helpers
  function assembleCells(ts, M, X){
    const d = new Date(ts);
    const row = {
      Time: minuteLabel(d) + ' 5m Avg',
      Rush: M.rush, Mood: M.mood, Social: M.social, Energy: M.energy, Focus: M.focus,
      Anxiety: M.anxiety, Impair: M.impair,
      Score: X.Score, Max: X.Max, Min: X.Min
    };
    return row;
  }
  function renderRows(rows){
    const tb = document.querySelector('#'+TABLE_ID+' tbody'); if (!tb) return;
    tb.innerHTML = '';
    rows.forEach(r=>{
      const tr = document.createElement('tr');
      tr.innerHTML = COLS.map(c=>{
        const v = r[c]; if (c==='Time') return `<td>${v??''}</td>`;
        const n = Number(v); const txt = Number.isFinite(n) ? n.toFixed(2) : '';
        return `<td>${txt}</td>`;
      }).join('');
      try{ window.STS_applyShading?.(tr); }catch(e){}
      tb.appendChild(tr);
    });
  }

  // Persistence
  function load(){ try{ return JSON.parse(localStorage.getItem(LS_KEY)||'[]'); }catch(e){ return []; } }
  function save(rows){ try{ localStorage.setItem(LS_KEY, JSON.stringify(rows||[])); }catch(e){} }

  // Emission (aligned to minute)
  let _timer = null;

  function emitOne(){
    const end = new Date(); end.setSeconds(0,0);   // align to :00
    const endMs = end.getTime();
    const startMs = endMs - 5*60000;               // last 5 minutes
    const M = meansForWindow(startMs, endMs);
    if (!M) return;
    const X = extrasFromMeans(M);
    const row = assembleCells(endMs, M, X);
    const rows = load();
    rows.push(row);
    save(rows);
    const visible = document.getElementById(MODAL_ID)?.style.display !== 'none';
    if (visible) renderRows(rows);
  }

  function startTimer(){
    if (_timer) return;
    const now = new Date();
    const delay = (60 - now.getSeconds())*1000 - now.getMilliseconds();
    setTimeout(()=>{
      emitOne();
      _timer = setInterval(emitOne, 60000);
    }, Math.max(0, delay));
  }
  function stopTimer(){
    if (_timer){ clearInterval(_timer); _timer = null; }
  }

  // Public API
  window.openRunningAverage = function(){
    const modal = document.getElementById(MODAL_ID);
    const rows = load();
    renderRows(rows);
    modal.style.display = 'block';
  };
  window.closeRunningAverage = function(){
    const modal = document.getElementById(MODAL_ID);
    modal.style.display = 'none';
  };
  window.runningAverageStart = function(){
    emitOne(); // emit immediately once
    startTimer();
    const s = document.getElementById('runningAvgStartBtn'); if (s) s.disabled = true;
    const t = document.getElementById('runningAvgStopBtn');  if (t) t.disabled = false;
  };
  window.runningAverageStop = function(){
    stopTimer();
    const s = document.getElementById('runningAvgStartBtn'); if (s) s.disabled = false;
    const t = document.getElementById('runningAvgStopBtn');  if (t) t.disabled = true;
  };
  window.exportRunningAverageCSV = function(){
    const rows = load();
    const header = COLS.join(',');
    const lines = [header].concat(rows.map(r=>COLS.map(c=>{
      const v = r[c];
      const s = (c==='Time') ? String(v||'') : (Number.isFinite(+v) ? (+v).toFixed(2) : '');
      return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
    }).join(',')));
    const blob = new Blob([lines.join('\n')+'\n'], {type:'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'running_average_5m_1m.csv';
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 250);
  };
  window.clearRunningAverage = function(){
    localStorage.removeItem(LS_KEY);
    const tb = document.querySelector('#'+TABLE_ID+' tbody'); if (tb) tb.innerHTML = '';
  };

  // Optional: pause in background to avoid drift
  document.addEventListener('visibilitychange', function(){
    if (document.hidden) stopTimer();
  });
})();
</script>
<!-- /STS: Running Average -->

<!-- Patch: Expose global Backfill and unify callers -->
<script>
// Timestamp: 2025/10/18 00:00:00
(function(){
  if (typeof window.backfillAll !== 'function') {
    /* legacy backfill implementation superseded on 2025/10/31 START */
window.backfillAll = function(){
      try {
        if (typeof window.backfillAllImpl === 'function') {
          return window.backfillAllImpl();
/* legacy backfill implementation superseded on 2025/10/31 END */
        }
        var helper = (typeof window.backfillWindow === 'function') ? window.backfillWindow
                   : (typeof backfillWindow === 'function') ? backfillWindow
                   : null;
        if (!helper) { console.warn('No backfillWindow available'); return; }
        var ids = ["summary5Table", "summary15Table", "summary60Table"];
        var addedTotal = 0;
        ids.forEach(function(id){
          try { var added = helper(null, id); addedTotal += (added||0); } catch(e){}
        });
        console.log('[Backfill] total added rows:', addedTotal);
        return addedTotal;
      } catch (e) {
        console.error('backfillAll failed:', e);
      }
    };
  }
  document.addEventListener('click', function(ev){
    try{
      var el = ev.target;
      if (!el || !el.id) return;
      if (el.id === 'backfillBtnGlobal' || el.id === 'backfillBtn' || /^backfillBtn\d+$/.test(el.id)) {
        if (typeof /* legacy backfill implementation superseded on 2025/10/31 START */
window.backfillAll === 'function') window.backfillAll();
/* legacy backfill implementation superseded on 2025/10/31 END */
      }
    }catch(e){}
  }, true);
})();
</script>

<!-- Statistical Analysis Daily Modal -->
<div id="statAnalysisDailyModal" style="display:none; position:fixed; inset:0; z-index:10000;">
  <div id="statAnalysisDailyBackdrop" style="position:absolute; inset:0; background:rgba(0,0,0,0.45);"></div>
  <div id="statAnalysisDailyCard" style="position:relative; margin:40px auto; max-width:960px; background:#fff; border-radius:8px; box-shadow:0 10px 40px rgba(0,0,0,0.25); padding:16px; border:2px solid #007aff;">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px;">
      <h2>Statistical Analysis — Daily</h2>
      <button aria-label="Close" onclick="closeStatAnalysisDaily()">Close</button>
    </div>
    <div style="font-size:11px; opacity:0.7; margin-bottom:6px;">Daily averages of rated metrics.</div>
    <table id="statAnalysisDailyTable" style="width:100%; border-collapse:collapse;">
      <thead>
        <tr>
          <th style="text-align:left;">Date</th>
          <th>Rush</th><th>Mood</th><th>Social</th><th>Energy</th><th>Focus</th><th>Anxiety</th><th>Impair</th>
          <th>Score</th><th>Max</th><th>Min</th><th>Weighted</th><th>5Max</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script>
// Timestamp: 2025/10/18 00:00:00
(function(){
  function safeNum(v){
    if (v == null) return null;
    var n = parseFloat(String(v).replace(/[^0-9.+-]/g,''));
    return isFinite(n) ? n : null;
  }
  function tsFromRow(r){
    try{
      if (typeof parseTimestamp === 'function') {
        var raw = r.Time || r.DateTime || r['Date/Time'] || r.ts || r.time || '';
        var t = parseTimestamp(raw);
        if (!isNaN(t)) return t;
      }
      var raw2 = r.Time || r.DateTime || r['Date/Time'] || r.ts || r.time || '';
      var s2 = String(raw2).replace(/\//g,'-').replace(/(\d)\s+(\d)/,'$1T$2');
      var t2 = new Date(s2).getTime();
      return isNaN(t2) ? NaN : t2;
    }catch(e){ return NaN; }
  }
  function groupByISODate(rows){
    var map = new Map();
    rows.forEach(function(r){
      var t = tsFromRow(r);
      if (isNaN(t)) return;
      var d = new Date(t);
      var key = d.toISOString().slice(0,10); // YYYY-MM-DD
      if (!map.has(key)) map.set(key, []);
      map.get(key).push(r);
    });
    return map;
  }
  function avg(list, key){
    var vals = list.map(function(r){ return safeNum(r[key]); }).filter(function(n){ return n!=null; });
    if (!vals.length) return '';
    var s = vals.reduce(function(a,b){ return a+b; }, 0);
    return (s/vals.length).toFixed(2);
  }
  function getSource(){
    if (typeof window.syncLogDataFromTable === 'function') { try{ window.syncLogDataFromTable(); }catch(e){} }
    var src = Array.isArray(window.logData) ? window.logData : [];
    return src;
  }
  function renderStatAnalysisDaily(){
    var src = getSource();
    var map = groupByISODate(src);
    var days = Array.from(map.keys()).sort();
    var tb = document.querySelector('#statAnalysisDailyTable tbody'); if (!tb) return;
    var MET = ['Rush','Mood','Social','Energy','Focus','Anxiety','Impair','Score','Max','Min','Weighted','5Max'];
    var lines = [];
    days.forEach(function(day){
      var list = map.get(day);
      var tds = MET.map(function(k){ return '<td>'+avg(list,k)+'</td>'; }).join('');
      lines.push('<tr><td style="text-align:left;">'+day+'</td>'+tds+'</tr>');
    });
    tb.innerHTML = lines.join('');
  }
  window.openStatAnalysisDaily = function(){
    renderStatAnalysisDaily();
    var m = document.getElementById('statAnalysisDailyModal'); if (m) m.style.display = 'block';
    var bd = document.getElementById('statAnalysisDailyBackdrop'); if (bd) bd.onclick = closeStatAnalysisDaily;
  };
  window.closeStatAnalysisDaily = function(){
    var m = document.getElementById('statAnalysisDailyModal'); if (m) m.style.display = 'none';
  };
})();
</script>

<!-- ===== STS Five-Minute Time-Weighted Averager (auto-insert rows) ===== -->
<script>
(function(){
  // ---- Config ----
  window.CONFIG = window.CONFIG || {};
  CONFIG.popups = CONFIG.popups || {};
  CONFIG.popups.fiveMinuteAverager = Object.assign({
    enabled: true,                 // master toggle
    intervalMs: 5 * 60 * 1000,     // run every 5 minutes
    lookbackMs: 5 * 60 * 1000,     // average the previous 5 minutes
    alignToBoundary: true,         // :00, :05, :10, ...
    label: '5mAvg',                // Phase label for synthetic rows
    minCoverageRatio: 0.5,         // require >= 50% coverage of samples within the window
    targetTableId: 'logTable',     // table id
    targetTbodyId: 'autoCBody'     // tbody id
  }, CONFIG.popups.fiveMinuteAverager || {});

  const COL = { // column indices for #logTable (0-based)
    Timestamp: 1,
    Phase: 4,
    Rush: 9,
    Mood: 11,
    Social: 13,
    Energy: 15,
    Focus: 17,
    Anxiety: 19,
    Impair: 21,
    Score: 37,
    Weighted: 46,
    FiveMax: 47
  };

  function floorToFiveMinuteBoundary(d) {
    const five = 5 * 60 * 1000;
    return new Date(Math.floor(d.getTime() / five) * five);
  }
  function formatTsYYYYMMDD_HHMMSS(d) {
    const pad = n => String(n).padStart(2, '0');
    return `${d.getFullYear()}/${pad(d.getMonth()+1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }
  // Robust AU timestamp parser: handles 'DD/MM/YYYY, HH:MM:SS' and 'YYYY/MM/DD HH:MM:SS'
  function parseTimestampAU(s) {
    if (!s) return null;
    s = String(s).trim();
    // Remove comma if present (en-AU toLocaleString often returns 'DD/MM/YYYY, HH:MM:SS')
    s = s.replace(',', '');
    // Try YYYY/MM/DD HH:MM:SS
    let m = s.match(/^(\d{4})\/(\d{2})\/(\d{2})\s+(\d{2}):(\d{2})(?::(\d{2}))?$/);
    if (m) {
      const [_, Y,M,D,h,mi,se] = m;
      return new Date(Number(Y), Number(M)-1, Number(D), Number(h), Number(mi), Number(se||'0'));
    }
    // Try DD/MM/YYYY HH:MM:SS
    m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})\s+(\d{2}):(\d{2})(?::(\d{2}))?$/);
    if (m) {
      const [_, D,M,Y,h,mi,se] = m;
      return new Date(Number(Y), Number(M)-1, Number(D), Number(h), Number(mi), Number(se||'0'));
    }
    // Fallback: Date constructor
    const d = new Date(s);
    return isNaN(d) ? null : d;
  }

  function getNumeric(td) {
    if (!td) return null;
    const v = Number(String(td.textContent || '').replace(/[^\d.\-]/g,''));
    return Number.isFinite(v) ? v : null;
  }

  function getRowsFromDOM() {
    const tbody = document.getElementById(CONFIG.popups.fiveMinuteAverager.targetTbodyId);
    if (!tbody) return [];
    const rows = [];
    const trs = tbody.querySelectorAll('tr');
    for (const tr of trs) {
      const tds = tr.children;
      const phase = (tds[COL.Phase]?.textContent || '').trim();
      // Exclude synthetic 5m rows (to avoid feedback), but include all other phases
      if (/5mAvg/i.test(phase)) continue;
      const tsText = tds[COL.Timestamp]?.textContent || '';
      const ts = parseTimestampAU(tsText);
      if (!(ts instanceof Date) || isNaN(ts)) continue;
      const row = {
        ts,
        rush:   getNumeric(tds[COL.Rush]),
        mood:   getNumeric(tds[COL.Mood]),
        social: getNumeric(tds[COL.Social]),
        energy: getNumeric(tds[COL.Energy]),
        focus:  getNumeric(tds[COL.Focus]),
        anxiety:getNumeric(tds[COL.Anxiety]),
        impair: getNumeric(tds[COL.Impair])
      };
      rows.push(row);
    }
    rows.sort((a,b)=>a.ts - b.ts);
    return rows;
  }

  function clip(a, lo, hi) { return Math.max(lo, Math.min(hi, a)); }

  // Time-weighted average over (T-5m, T]
  function timeWeightedAverage(windowEnd, rows, lookbackMs) {
    const windowStart = new Date(windowEnd.getTime() - lookbackMs);
    let coveredMs = 0;
    const sums = {rush:0,mood:0,social:0,energy:0,focus:0,anxiety:0,impair:0};
    if (!rows.length) return {avg:null, coverage:0};

    // Build segments by pairing each sample with the next timestamp (or windowEnd)
    for (let i=0;i<rows.length;i++) {
      const cur = rows[i];
      const nextTs = (i < rows.length-1) ? rows[i+1].ts : windowEnd;
      // segment the sample's influence
      const segStart = new Date(Math.max(cur.ts.getTime(), windowStart.getTime()));
      const segEnd   = new Date(Math.min(nextTs.getTime(), windowEnd.getTime()));
      const dur = segEnd.getTime() - segStart.getTime();
      if (dur <= 0) continue;

      // Only if sample actually overlaps window
      // Accumulate time-weighted contributions (zero if metric is null/NaN)
      for (const k of Object.keys(sums)) {
        const v = cur[k];
        if (typeof v === 'number' && isFinite(v)) {
          sums[k] += v * dur;
        }
      }
      coveredMs += dur;
    }

    if (coveredMs <= 0) return {avg:null, coverage:0};
    const avg = {};
    for (const k of Object.keys(sums)) avg[k] = sums[k] / coveredMs;
    return {avg, coverage: coveredMs / lookbackMs};
  }

  function recomputeDerived(avgBase) {
    // Use app's existing calculators if present
    const base = {
      rush: avgBase.rush || 0,
      mood: avgBase.mood || 0,
      social: avgBase.social || 0,
      energy: avgBase.energy || 0,
      focus: avgBase.focus || 0,
      anxiety: avgBase.anxiety || 0,
      impair: avgBase.impair || 0
    };
    let weighted = null, fiveMax = null;
    try { if (typeof window.computeWeighted === 'function') weighted = window.computeWeighted(base); } catch(e){}
    try { if (typeof window.computeFiveMax === 'function') fiveMax = window.computeFiveMax(base); } catch(e){}
    return { weighted, fiveMax };
  }

  function insertAveragedRow(boundary, avgBase, derived) {
    const tbody = document.getElementById(CONFIG.popups.fiveMinuteAverager.targetTbodyId);
    if (!tbody) return;

    const tr = document.createElement('tr');
    const td = (txt='') => { const c=document.createElement('td'); c.textContent = txt; return c; };

    // Build cells in the same order the table expects (fill blanks for unrelated columns).
    // 0 Select
    tr.appendChild(td(''));
    // 1 Timestamp
    tr.appendChild(td(formatTsYYYYMMDD_HHMMSS(boundary)));
    // 2 Since
    tr.appendChild(td(''));
    // 3 Elapsed
    tr.appendChild(td(''));
    // 4 Phase
    tr.appendChild(td(CONFIG.popups.fiveMinuteAverager.label || '5mAvg'));
    // 5 Scale
    tr.appendChild(td(''));
    // 6-8 Drug/Qty/ROA
    tr.appendChild(td(''));
    tr.appendChild(td(''));
    tr.appendChild(td(''));

    // Ensure we have at least COL.Impair*2 + 1 cells before metric block due to duplicates in the layout
    while (tr.children.length < COL.Rush) tr.appendChild(td(''));

    // Metrics pairs (value + label-duplicate column pattern)
    function addMetricPair(val) {
      tr.appendChild(td(Number.isFinite(val) ? val.toFixed(2) : ''));
      tr.appendChild(td(Number.isFinite(val) ? val.toFixed(2) : ''));
    }
    addMetricPair(avgBase.rush);
    addMetricPair(avgBase.mood);
    addMetricPair(avgBase.social);
    addMetricPair(avgBase.energy);
    addMetricPair(avgBase.focus);
    addMetricPair(avgBase.anxiety);
    addMetricPair(avgBase.impair);

    // Pad up to Score column
    while (tr.children.length < COL.Score) tr.appendChild(td(''));
    tr.appendChild(td('')); // Score (you may compute your own Score if you want)

    // Pad up to Weighted & 5Max
    while (tr.children.length < COL.Weighted) tr.appendChild(td(''));
    tr.appendChild(td(Number.isFinite(derived.weighted) ? derived.weighted.toFixed(2) : ''));
    tr.appendChild(td(Number.isFinite(derived.fiveMax) ? derived.fiveMax.toFixed(2) : ''));

    tbody.appendChild(tr);

    // If your app has shading logic, call it
    if (typeof window.STS_applyShading === 'function') window.STS_applyShading(tr);
  }

  function setupScheduler(){
    const cfg = CONFIG.popups.fiveMinuteAverager;
    if (!cfg?.enabled) return;

    const emitted = new Set(); // boundary ISO strings

    function emitIfDue(boundary){
      const key = boundary.toISOString();
      if (emitted.has(key)) return;
      const all = getRowsFromDOM();
      const {avg, coverage} = timeWeightedAverage(boundary, all, cfg.lookbackMs);
      if (!avg) return;
      if (coverage < (cfg.minCoverageRatio || 0)) return;
      const derived = recomputeDerived(avg);
      insertAveragedRow(boundary, avg, derived);
      emitted.add(key);
    }

    function schedule(){
      const now = new Date();
      const five = cfg.intervalMs;
      const boundary = cfg.alignToBoundary ? floorToFiveMinuteBoundary(now) : now;
      // compute next boundary
      const next = new Date(boundary.getTime() + five);
      const delay = Math.max(0, next.getTime() - now.getTime());

      // On first run: if exactly on boundary, emit immediately; else wait until next boundary
      if (cfg.alignToBoundary && (now - boundary < 1000)) {
        emitIfDue(boundary);
      }
      setTimeout(function onBoundary(){
        const b = cfg.alignToBoundary ? floorToFiveMinuteBoundary(new Date()) : new Date();
        emitIfDue(b);
        setInterval(() => {
          const bb = cfg.alignToBoundary ? floorToFiveMinuteBoundary(new Date()) : new Date();
          emitIfDue(bb);
        }, five);
      }, delay);
    }

    schedule();
  }

  // Defer until DOM is ready
  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setupScheduler();
  } else {
    document.addEventListener('DOMContentLoaded', setupScheduler);
  }
})();
</script>
<!-- ===== End Five-Minute Averager ===== -->


<!-- Patch block: fixes 1–4 inserted 2025/10/19 01:02:50 (Australia/Sydney) -->
<script>
(function(){
  'use strict';
  // === Fix 1: Deduplicate "All Rated 5m" button and bind safely ===
  try {
    (function dedupeAllRated5m(){
      var nodes = document.querySelectorAll('#allRated5mBtn');
      if (nodes && nodes.length > 1) {
        for (var i = 1; i < nodes.length; i++) nodes[i].parentNode && nodes[i].parentNode.removeChild(nodes[i]);
        console.warn('[allRated5m] Removed duplicate button(s).');
      }
    })();
  } catch(e) { console.warn('[allRated5m] Dedupe failed:', e); }

  // === Fix 2: Ensure Rush Mode metrics unique (defensive) ===
  try {
    if (window.RUSH_MODE_METRICS && Array.isArray(window.RUSH_MODE_METRICS)) {
      var seen = Object.create(null), uniq = [];
      for (var i=0;i<window.RUSH_MODE_METRICS.length;i++) {
        var k = String(window.RUSH_MODE_METRICS[i]);
        if (!seen[k]) { seen[k]=1; uniq.push(k); }
      }
      if (uniq.length !== window.RUSH_MODE_METRICS.length) {
        window.RUSH_MODE_METRICS = Object.freeze(uniq);
        console.info('[RushMode] De-duplicated metric list to', uniq);
      }
    }
  } catch(e) { console.warn('[RushMode] Metric normalisation failed:', e); }

  // === Fix 3: Idempotent addEntry wrapper with event ===
  try {
    var ADDENTRY_ORIG = Symbol.for('app.addEntry.original');
    if (typeof window.addEntry === 'function' && !window[ADDENTRY_ORIG]) {
      var original = window.addEntry;
      window[ADDENTRY_ORIG] = original;
      window.addEntry = function wrappedAddEntry() {
        var args = Array.prototype.slice.call(arguments);
        var result = window[ADDENTRY_ORIG].apply(this, args);
        try {
          var evt = new CustomEvent('entry:added', { detail: { args: args, result: result, ts: Date.now() } });
          window.dispatchEvent(evt);
        } catch (e) { console.warn('[AutoHook] event dispatch failed:', e); }
        try {
          if (window.autoSummaryActive === true && typeof window.handleAutoSummary === 'function') {
            window.handleAutoSummary(args, result);
          }
        } catch (e) { console.error('[AutoHook] inline autoSummaryActive logic failed:', e); }
        return result;
      };
      console.info('[AutoHook] addEntry wrapped safely (idempotent).');
    }
  } catch(e) { console.warn('[AutoHook] Wrapper installation failed:', e); }

  // === Fix 4: Canonicalise CONFIG.ui and provide controlled updater ===
  try {
    window.CONFIG = window.CONFIG || {};
    var defaultUI = { hiddenColumns: [], shadedCaps: { min: null, max: null }, colourSet: 'default' };
    var ui = (window.CONFIG.ui && typeof window.CONFIG.ui === 'object') ? window.CONFIG.ui : defaultUI;
    // make a shallow merged copy to avoid freezing external reference
    window.CONFIG.ui = Object.assign({}, defaultUI, ui);
    if (typeof window.applyUiColumnVisibility === 'function') window.applyUiColumnVisibility(window.CONFIG.ui);
    if (typeof window.applyUiShading === 'function') window.applyUiShading(window.CONFIG.ui);
    // expose controlled updater
    window.updateUiConfig = function(patch) {
      var next = Object.assign({}, window.CONFIG.ui, patch || {});
      window.CONFIG.ui = next;
      if (typeof window.applyUiColumnVisibility === 'function') window.applyUiColumnVisibility(window.CONFIG.ui);
      if (typeof window.applyUiShading === 'function') window.applyUiShading(window.CONFIG.ui);
      return window.CONFIG.ui;
    };
  } catch(e) { console.warn('[UI] Canonicalisation failed:', e); }
})();
</script>
<!-- Unlocked Mode Module (2025/10/21 15:50:00) -->

<!-- Legacy Unlocked toolbar injection removed (2025/10/31). Permanent header button is canonical. -->


<!-- Backfill Fix Module (2025/10/21 15:50:00) -->
<script>
(() => {
  'use strict';

  function canonicalBackfillAll(){
    const helper = window.backfillWindow || (typeof backfillWindow==='function' ? backfillWindow : null);
    if (!helper) { console.warn('[Backfill] backfillWindow not found'); return 0; }
    const plan = [[5,'summary5Table'], [15,'summary15Table'], [60,'summary60Table']];
    let total = 0;
    for (const [mins, tableId] of plan){
      try { const n = helper(mins, tableId) || 0; total += n; }
      catch (e){ console.error('[Backfill] error on', mins, tableId, e); }
    }
    console.log('[Backfill] added rows total:', total);
    return total;
  }

  // Force our implementation
  Object.defineProperty(window, 'backfillAll', { configurable: true, writable: true, value: canonicalBackfillAll });

  function cloneAndRebindBackfill(){
    let btn = document.getElementById('backfillBtn') || document.querySelector('[data-action="backfill"], button#backfill');
    if (!btn) return;
    // Drop existing listeners by cloning
    const newBtn = btn.cloneNode(true);
    btn.replaceWith(newBtn);
    newBtn.addEventListener('click', (ev)=>{
      try { ev && ev.preventDefault(); window.backfillAll(); }
      catch(e){ console.error('[Backfill] run failed', e); }
    }, { capture: true }); // capture to pre-empt bubbling handlers
  }

  if (document.readyState==='loading') {
    document.addEventListener('DOMContentLoaded', cloneAndRebindBackfill);
  } else {
    cloneAndRebindBackfill();
  }
})();
</script>


<!-- BEGIN: ChatGPT patch 2025/10/21 05:01:46 -->

<!-- Legacy Unlocked toolbar injection removed (2025/10/31). Permanent header button is canonical. -->

<!-- END: ChatGPT patch 2025/10/21 05:01:46 -->

<!-- === Begin: Dose Reviews Segment-Aware Patch (injected) === -->
<script>
// ===== Dose Review Segmentation: helpers =====
(function(){
  // Parse "HH:MM:SS" -> seconds (number) or null
  function parseSinceHMS(s){
    if (!s) return null;
    try {
      const m = String(s).trim().match(/^(\d{1,2}):(\d{2}):(\d{2})$/);
      if (!m) return null;
      const h = +m[1], mi = +m[2], se = +m[3];
      if (!Number.isFinite(h) || !Number.isFinite(mi) || !Number.isFinite(se)) return null;
      return (h*3600) + (mi*60) + se;
    } catch(e){ return null; }
  }

  // Date from AU timestamp "dd/mm/yyyy, HH:MM:SS" OR "dd/mm/yyyy HH:MM:SS"
  function parseAUDateTime(ts){
    if (!ts) return null;
    try {
      const s = String(ts).replace(',', ' ').trim();
      const m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})\s+(\d{1,2}):(\d{2}):(\d{2})$/);
      if (!m) return null;
      const d = +m[1], mo = +m[2], y = +m[3], h = +m[4], mi = +m[5], se = +m[6];
      const dt = new Date(y, mo-1, d, h, mi, se);
      if (isNaN(dt.getTime())) return null;
      return dt;
    } catch(e){ return null; }
  }

  function isDoseEvent(drugStr){
    if (!drugStr) return false;
    return String(drugStr).trim() !== '';
  }

  function byTimeAsc(a,b){
    const ta = (a && a._ts) ? a._ts : (parseAUDateTime(a && a.timestamp) || 0);
    const tb = (b && b._ts) ? b._ts : (parseAUDateTime(b && b.timestamp) || 0);
    const va = (typeof ta==='number') ? ta : (ta? ta.getTime():0);
    const vb = (typeof tb==='number') ? tb : (tb? tb.getTime():0);
    return va - vb;
  }

  function medianOf(arr){
    const xs = arr.slice().filter(v => Number.isFinite(+v)).map(Number).sort((x,y)=>x-y);
    if (!xs.length) return 0;
    const mid = Math.floor(xs.length/2);
    if (xs.length % 2 === 0) return (xs[mid-1] + xs[mid]) / 2;
    return xs[mid];
  }

  function statsOf(arr){
    if (!arr || !arr.length) return {avg:0, med:0, min:0, max:0};
    const n = arr.length;
    let sum = 0, lo = +arr[0], hi = +arr[0];
    for (let i=0;i<n;i++){
      const v = +arr[i];
      if (!Number.isFinite(v)) continue;
      sum += v;
      if (v < lo) lo = v;
      if (v > hi) hi = v;
    }
    return {
      avg: sum / n,
      med: medianOf(arr),
      min: lo,
      max: hi
    };
  }

  // Compute segments from logData
  function computeDoseSegments(data){
    const rows = (Array.isArray(data) ? data.slice() : []).sort(byTimeAsc);
    const segments = [];
    let current = [];
    let prevSince = null;

    for (const r of rows){
      const sinceS = parseSinceHMS(r && r.sincedose);
      const drugStr = r && r.drug;
      const newSeg =
        (isDoseEvent(drugStr)) ||
        (prevSince != null && sinceS != null && sinceS < prevSince) ||
        doseToken(r && r.notes) || doseToken(r && r.info);

      if (newSeg && current.length){
        segments.push(current);
        current = [];
      }
      current.push(r);
      if (sinceS != null) prevSince = sinceS;
    }
    if (current.length) segments.push(current);
    return segments;
  }

  function safeNum(x){ const n = +x; return Number.isFinite(n) ? n : 0; }

  function segmentRowToMetrics(r){
    return {
      rush:    safeNum(r && r.rushSum),
      mood:    safeNum(r && r.moodSum),
      social:  safeNum(r && r.socialSum),
      energy:  safeNum(r && r.energySum),
      focus:   safeNum(r && r.focusSum),
      anxiety: safeNum(r && r.anxietySum),
      impair:  safeNum(r && r.impairSum),
      score:   safeNum(r && r.score),
      max:     safeNum(r && r.max),
      min:     safeNum(r && r.min),
      weighted:safeNum(r && r.weighted),
      fiveMax: safeNum(r && r.fiveMax)
    };
  }

  function summariseSegment(seg){
    const t0 = seg[0], tN = seg[seg.length-1];
    const tsStart = t0 && t0.timestamp ? String(t0.timestamp) : '';
    const tsEnd   = tN && tN.timestamp ? String(tN.timestamp) : '';
    const cols = {rush:[],mood:[],social:[],energy:[],focus:[],anxiety:[],impair:[],score:[],max:[],min:[],weighted:[],fiveMax:[]};
    for (const r of seg){
      const m = segmentRowToMetrics(r);
      Object.keys(cols).forEach(k => cols[k].push(m[k]));
    }
    const S = {};
    Object.keys(cols).forEach(k => { S[k] = statsOf(cols[k]); });
    return { start: tsStart, end: tsEnd, n: seg.length, S };
  }

  function fmt2(n){ return Number.isFinite(+n) ? (+n).toFixed(2) : ''; }

  function pickStat(label){
    const L = String(label).toLowerCase();
    if (L.startsWith('med')) return 'med';
    if (L.startsWith('min')) return 'min';
    if (L.startsWith('max')) return 'max';
    return 'avg';
  }

  function pushSummaryRow(tbody, label, segIdx, segMeta){
    const which = pickStat(label);
    const tr = document.createElement('tr');
    const vals = {
      rush:     segMeta.S.rush[which],
      mood:     segMeta.S.mood[which],
      social:   segMeta.S.social[which],
      energy:   segMeta.S.energy[which],
      focus:    segMeta.S.focus[which],
      anxiety:  segMeta.S.anxiety[which],
      impair:   segMeta.S.impair[which],
      score:    segMeta.S.score[which],
      max:      segMeta.S.max[which],
      min:      segMeta.S.min[which],
      weighted: segMeta.S.weighted[which],
      fiveMax:  segMeta.S.fiveMax[which]
    };
    const headers = ["Label","Segment","Time","Rush","Mood","Social","Energy","Focus","Anxiety","Impair","Score","Max","Min","Weighted","5Max"];
    const cells = [
      label,
      String(segIdx),
      `${segMeta.start} → ${segMeta.end}`,
      fmt2(vals.rush), fmt2(vals.mood), fmt2(vals.social), fmt2(vals.energy), fmt2(vals.focus),
      fmt2(vals.anxiety), fmt2(vals.impair),
      fmt2(vals.score), fmt2(vals.max), fmt2(vals.min), fmt2(vals.weighted), fmt2(vals.fiveMax)
    ];
    for (let i=0;i<headers.length;i++){
      const td = document.createElement('td');
      td.textContent = cells[i] != null ? String(cells[i]) : '';
      td.setAttribute('data-col', headers[i]);
      tr.appendChild(td);
    }
    try { window.STS_applyShading(tr); } catch(e){}
    tbody.appendChild(tr);
  }

  function buildDoseReviewsExportRows(){
    const rows = [];
    const table = document.getElementById('doseReviewsTable');
    if (!table) return rows;
    const header = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
    rows.push(header.join(','));
    const bodyRows = table.querySelectorAll('tbody tr');
    bodyRows.forEach(tr => {
      const cols = Array.from(tr.children).map(td => {
        const raw = td.textContent.replace(/"/g,'""');
        return `"${raw}"`;
      });
      rows.push(cols.join(','));
    });
    return rows;
  }

  // Override: openDoseReviews with segment awareness
  window.openDoseReviews = function(){
    try {
      const modal = document.getElementById('doseReviewsModal');
      const tbody = document.querySelector('#doseReviewsTable tbody');
      const meta  = document.getElementById('doseReviewsMeta');
      if (!modal || !tbody){ alert('Dose Reviews UI not found.'); return; }

      const data = Array.isArray(window.logData) ? window.logData.slice() : [];
      if (!data.length){ alert('No log data to review.'); return; }

      const segments = computeDoseSegments(data);
      tbody.innerHTML = '';
      let totalRows = 0;

      segments.forEach((seg, idx) => {
        const segIdx = idx + 1;
        const segMeta = summariseSegment(seg);
        pushSummaryRow(tbody, 'Average', segIdx, segMeta);
        pushSummaryRow(tbody, 'Median',  segIdx, segMeta);
        pushSummaryRow(tbody, 'Minimum', segIdx, segMeta);
        pushSummaryRow(tbody, 'Maximum', segIdx, segMeta);
        totalRows += 4;
      });

      if (meta) meta.textContent = `Detected ${segments.length} segment(s); summarised ${totalRows} rows (${segments.length} × 4). Source: current log data at open time.`;
      modal.style.display = 'block';
    } catch(err){
      console.error(err);
      alert('Dose Reviews failed: ' + err.message);
    }
  };

  // Override: exportDoseReviewsCsv to export the visible segmented table
  window.exportDoseReviewsCsv = function(){
    try{
      const lines = buildDoseReviewsExportRows();
      if (!lines.length){ alert('Nothing to export.'); return; }
      const blob = new Blob([lines.join('\\n')], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'dose_reviews_segments.csv';
      document.body.appendChild(a);
      a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
    } catch(err){
      console.error(err);
      alert('Export failed: ' + err.message);
    }
  };

  if (!window.closeDoseReviews){
    window.closeDoseReviews = function(){
      const modal = document.getElementById('doseReviewsModal');
      if (modal) modal.style.display = 'none';
    };
  }
})();
</script>
<!-- === End: Dose Reviews Segment-Aware Patch (injected) === -->

<!-- === Begin: Backfill Consolidation + Toast + Popup Sync Patch === -->
<style>
#stsToast {
  position: fixed;
  left: 50%;
  bottom: 24px;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 10px 14px;
  border-radius: 8px;
  font-size: 12px;
  z-index: 100000;
  opacity: 0;
  pointer-events: none;
  transition: opacity 180ms ease;
}
#stsToast.show { opacity: 1; }
</style>
<div id="stsToast" role="status" aria-live="polite"></div>

<script>
(() => {
  'use strict';

  // ===== Canonical Backfill (header-based, AU timestamps) =====
  function backfillAllCanonical() {
    const TABLE_SEL = '#mainLogTable';
    const table = document.querySelector(TABLE_SEL);
    if (!table) { console.error('[Backfill] table not found:', TABLE_SEL); return; }

    // Resolve timestamp column by header name
    const idxes = __findHeaderIndexes(table);
    if (idxes.timestamp == null) { alert('Timestamp column not found'); return; }

    // Extract rows with parsed timestamps
    const rows = [];
    for (const tr of __iterDataRows(table)) {
      const cells = Array.from(tr.children);
      const tsCell = cells[idxes.timestamp];
      const tsText = tsCell ? tsCell.textContent.trim() : '';
      const when = __parseAULocalTimestamp(tsText);
      if (!when) continue;
      rows.push({ tr, ts: when, tsText });
    }
    if (!rows.length) { alert('No timestamped rows to backfill.'); return; }

    // Sort by time ascending for window processing
    rows.sort((a,b) => a.ts - b.ts);

    // Compute windows in milliseconds
    const minutes = (window.CONFIG?.backfill?.windowsMin || [5, 15, 60]).slice().sort((a,b)=>a-b);
    const windowsMs = minutes.map(m => m * 60 * 1000);

    function summaryKey(anchorISO, windowMin) {
      return `bf:${anchorISO}:+${windowMin}m`;
    }

    function ensureSummaryRow(anchorTr, anchorISO, windowMin, data) {
      const key = summaryKey(anchorISO, windowMin);
      const existing = table.querySelector(`tbody tr[data-bf-key="${key}"]`);
      if (existing) {
        const sumCell = existing.querySelector('td[data-bf-field="summary"]');
        if (sumCell) sumCell.textContent = data.summaryText;
        return existing;
      }
      const tr = document.createElement('tr');
      tr.setAttribute('data-bf-key', key);
      tr.classList.add('backfill-summary-row');

      const headerCells = table.querySelectorAll('thead tr th');
      const cellCount = headerCells.length || 1;
      for (let i = 0; i < cellCount; i++) {
        const td = document.createElement('td');
        if (i === 0) {
          td.setAttribute('data-bf-field', 'summary');
          td.textContent = data.summaryText;
        } else {
          td.textContent = '';
        }
        tr.appendChild(td);
      }

      const body = table.querySelector('tbody') || table;
      const next = anchorTr.nextSibling;
      if (next) body.insertBefore(tr, next); else body.appendChild(tr);
      return tr;
    }

    function aggregateWindow(anchorIdx, windowMs) {
      const anchor = rows[anchorIdx];
      const t0 = anchor.ts;
      const t1 = new Date(t0.getTime() + windowMs);
      let count = 0;
      let lastTs = null;
      for (let j = anchorIdx; j < rows.length; j++) {
        const t = rows[j].ts;
        if (t > t1) break;
        if (t >= t0 && t <= t1) {
          count++;
          lastTs = t;
        }
      }
      return { count, lastTs };
    }

    for (let i = 0; i < rows.length; i++) {
      const anchorISO = rows[i].ts.toISOString();
      for (let w = 0; w < windowsMs.length; w++) {
        const winMs = windowsMs[w];
        const winMin = minutes[w];
        const key = summaryKey(anchorISO, winMin);
        if (table.querySelector(`tbody tr[data-bf-key="${key}"]`)) continue;

        const agg = aggregateWindow(i, winMs);
        const summaryText = `Backfill ${winMin} min: ${agg.count} row(s)` +
                            (agg.lastTs ? `; last @ ${agg.lastTs.toLocaleString()}` : '');
        ensureSummaryRow(rows[i].tr, anchorISO, winMin, { summaryText });
      }
    }

    try { console.info('[Backfill] Completed via canonical header-based routine.'); } catch {}
  }

  window.backfillAllCanonical = backfillAllCanonical;
})();
</script>

<!-- === End: Backfill Consolidation + Toast + Popup Sync Patch === -->
<!-- Unlocked Mode Module (patched, 2025/10/23 12:00:00) -->
<script>
(() => {
  'use strict';

  // ===== Config =====
  const MODAL_ID = 'unlockedModeModal';
  const BTN_ID = 'unlockedModeBtn'; // we reuse existing header button if present
  const TITLE = 'Unlocked Mode';

  const METRICS = [
    { field: 'rushSum',    label: 'Rush Sum' },
    { field: 'moodSum',    label: 'Mood Sum' },
    { field: 'socialSum',  label: 'Social Sum' },
    { field: 'energySum',  label: 'Energy Sum' },
    { field: 'focusSum',   label: 'Focus Sum' },
    { field: 'anxietySum', label: 'Anxiety Sum' },
    { field: 'impairSum',  label: 'Impair Sum' }
  ];

  // Column of discrete numeric buttons per metric.
  // BOOKMARK unlcoked mode metrics
  // Render `null` as a visual divider.
  const VALUES = CONFIG.values;

  // Notes palette (fallback when no scrapeable notes are found)
  const FALLBACK_NOTES = [
    'Correlate','Flag','Now','Then','Next','Last','Changes','Note','Context','Associate','Plan','Review',
    'Hindsight','Redose','Hit','Continue','Food','Drink','Sleep','LastRow','LastDose','LastHit','Single','Multiple',
    'DrugAdded','NothingAdded','UsingRemains','LeftRemains','MaybeUsable','LotsUsable','Weighed','Eyeballed','Guessed',
    'Estimate','Scales','HardToSee','LightRoom','DarkRoom','Less','More','Somewhat','Lots'
  ];

  // ===== State =====
  const selection = new Map();      // metricField -> number
  const selectedNotes = new Set();  // string labels

  // ===== UI Builders =====
  function ensureModal() {
    if (document.getElementById(MODAL_ID)) return;
    const html = `
      <div id="${MODAL_ID}" style="position:fixed; inset:0; display:none; background:rgba(0,0,0,0.35); z-index:99999;">
        <div style="position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:min(96vw, 980px); max-height:86vh; background:#fff; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.2); display:flex; flex-direction:column;">
          <div style="display:flex; align-items:center; justify-content:space-between; padding:12px 16px; border-bottom:1px solid #eee;">
            <strong>${TITLE}</strong>
            <div style="display:flex; gap:8px; align-items:center;">
              <button id="umSubmitBtn" type="button">Add Entry</button>
              <button id="umResetBtn" type="button">Reset</button>
              <button id="umCloseBtn" type="button">Close</button>
            </div>
          </div>
          <div id="umBody" style="padding:12px 16px; overflow:auto;">
            <div id="umMetrics"></div>
            <div style="height:10px;"></div>
            <div id="umNotesWrap">
              <div style="display:flex; align-items:center; justify-content:space-between; margin:6px 0;">
                <strong>Notes</strong>
                <small id="umNotesHint" style="color:#666;">Tap to toggle (grid 10-wide)</small>
              </div>
              <div id="umNotes" style="display:grid; grid-template-columns: repeat(10, minmax(0, 1fr)); gap:6px;"></div>
            </div>
          </div>
          <div style="padding:8px 16px; border-top:1px solid #eee; color:#555; font-size:12px;">
            <span id="umStatus">Ready.</span>
          </div>
        </div>
      </div>`;
    document.body.insertAdjacentHTML('beforeend', html);
    document.getElementById('umCloseBtn').addEventListener('click', closeModal);
    document.getElementById('umSubmitBtn').addEventListener('click', submitEntry);
    document.getElementById('umResetBtn').addEventListener('click', resetAll);
    buildMetricRows();
    buildNotes();
  }

  function buildMetricRows() {
    const host = document.getElementById('umMetrics');
    if (!host) return;
    host.innerHTML = '';
    host.style.display = 'flex';
    host.style.flexDirection = 'column';
    host.style.gap = '10px';

    METRICS.forEach((m) => {
      const section = document.createElement('div');
      section.style.display = 'flex';
      section.style.flexDirection = 'column';
      section.style.padding = '8px 10px';
      section.style.border = '1px solid #eee';
      section.style.borderRadius = '8px';
      section.style.background = '#fff';

      const label = document.createElement('div');
      label.textContent = m.label;
      label.style.fontWeight = '600';
      label.style.marginBottom = '6px';
      section.appendChild(label);

      const col = document.createElement('div');
      col.style.display = 'flex';
      col.style.flexDirection = 'column';
      col.style.gap = '6px';
      section.appendChild(col);

      CONFIG.values.forEach((v) => {
        if (v === null) {
          const divider = document.createElement('div');
          divider.style.height = '6px';
          divider.style.borderTop = '1px dashed #ddd';
          divider.style.margin = '2px 0';
          col.appendChild(divider);
          return;
        }
        const b = document.createElement('button');
b
        b.type = 'button';
        b.dataset.field = m.field;
        b.dataset.val = String(v);
        b.textContent = String(v);
        Object.assign(b.style, {
          display: 'block',
          width: '100%',
          textAlign: 'center',
          padding: '8px 10px',
          minHeight: '34px',
          cursor: 'pointer',
          border: '1px solid #ddd',
          borderRadius: '8px',
          background: '#fafafa',
          userSelect: 'none',
          fontWeight: '500'
        });
        b.addEventListener('click', () => onValueClick(b, m.field, v));
        col.appendChild(b);
      });

      host.appendChild(section);
    });
  }

  function onValueClick(btn, field, value) {
    selection.set(field, value);
    const section = btn.parentElement;
    section.querySelectorAll('button[data-field="'+field+'"]').forEach(b=>{
      b.style.background='#fafafa'; b.style.borderColor='#ddd'; b.style.fontWeight='400';
    });
    btn.style.background='#e8f5ff'; btn.style.borderColor='#57a9ff'; btn.style.fontWeight='600';
    setStatus(field+' = '+value);
  }

  function buildNotes() {
    const host = document.getElementById('umNotes'); if (!host) return;
    host.innerHTML = '';

    const labels = scrapeExistingNotes() || FALLBACK_NOTES;
    labels.forEach((lbl) => {
      const b = document.createElement('button');
b
      b.type = 'button';
      b.textContent = lbl;
      b.dataset.note = lbl;
      Object.assign(b.style, {
        padding: '6px 8px',
        minHeight: '28px',
        cursor: 'pointer',
        border: '1px solid #e6c200',
        borderRadius: '6px',
        background: '#ffef8a',
        userSelect: 'none'
      });
      b.addEventListener('click', () => {
        if (selectedNotes.has(lbl)) { selectedNotes.delete(lbl); b.style.opacity='1'; b.style.outline='none'; }
        else { selectedNotes.add(lbl); b.style.opacity='0.7'; b.style.outline='2px solid #caa800'; }
      });
      host.appendChild(b);
    });
  }

  function scrapeExistingNotes() {
    const candidates = Array.from(document.querySelectorAll('button[data-note], .note-yellow, button.note, .yellow-note, [data-notelabel]'));
    const labels = new Set();
    candidates.forEach((el) => {
      const t = (el.getAttribute('data-note') || el.getAttribute('data-notelabel') || el.textContent || '').trim();
      if (t) labels.add(t);
    });
    return labels.size ? Array.from(labels) : null;
  }

  // ===== Submit / Reset =====
  function submitEntry() {
    const payload = {};
    METRICS.forEach(m => { if (selection.has(m.field)) payload[m.field] = selection.get(m.field); });
    const notes = Array.from(selectedNotes); if (notes.length) payload.notes = notes;

    let committed = false;
    // Preferred: app integration
    try { if (typeof window.addEntry === 'function') { window.addEntry(payload, {source:'UnlockedMode'}); committed = true; } } catch(e){}
    // Fallback: older signature
    if (!committed){ try { if (typeof window.addEntry === 'function') { window.addEntry(payload); committed = true; } } catch(e){} }
    // Fallback: DOM injection into main table
    if (!committed){
      try{
        const tbody = document.querySelector('#logTable tbody');
        if (tbody) {
          const tr = document.createElement('tr');
          const ts = Date.now();
          tr.setAttribute('data-ts', String(ts));
          const tc = document.createElement('td');
          tc.textContent = new Date(ts).toLocaleString('en-AU', { hour12: false });
          // prepend a blank "Select" cell then timestamp to match your table structure
          tr.innerHTML = `<td></td><td>${tc.textContent}</td><td></td><td></td>`;
          METRICS.forEach(m => {
            const v = payload[m.field];
            const tdSum = document.createElement('td');
            tdSum.setAttribute('data-field', m.field);
            if (typeof v === 'number') { tdSum.setAttribute('data-value', String(v)); tdSum.textContent = String(v.toFixed ? v.toFixed(2) : v); }
            tr.appendChild(tdSum);
            const tdLbl = document.createElement('td');
            tdLbl.setAttribute('data-label-for', m.field);
            tdLbl.textContent = '';
            tr.appendChild(tdLbl);
          });
          const tdN = document.createElement('td'); tdN.textContent = (notes || []).join(' ');
          tr.appendChild(tdN);
          tbody.appendChild(tr);
          committed = true;
        }
      }catch(e){}
    }

    if (committed) { setStatus('Entry added.'); resetAll(); }
    else { setStatus('Could not add entry.'); console.warn('UnlockedMode: commit failed', payload); }
  }

  function resetAll() {
    selection.clear();
    selectedNotes.clear();
    document.querySelectorAll('#'+CSS.escape(MODAL_ID)+' button[data-field]').forEach(b=>{ b.style.background='#fafafa'; b.style.borderColor='#ddd'; b.style.fontWeight='400'; });
    document.querySelectorAll('#umNotes button').forEach(b=>{ b.style.opacity='1'; b.style.outline='none'; });
    setStatus('Reset.');
  }

  function setStatus(msg){ const el = document.getElementById('umStatus'); if (el) el.textContent = msg; }

  function openModal(){ ensureModal(); document.getElementById(MODAL_ID).style.display = 'block'; setStatus('Ready.'); }
  function closeModal(){ const el = document.getElementById(MODAL_ID); if (el) el.style.display = 'none'; }

  // ===== Boot =====
  function boot(){
    try {
      ensureModal();
      // If an existing header button is present, use it. Otherwise, do not inject a duplicate into the UI.
      const btn = document.getElementById(BTN_ID);
      if (btn && !btn._umBound) {
        btn.addEventListener('click', function(){
          if (typeof openUnlockedMode === 'function') {
            // New horizontal Unlocked Mode
            openUnlockedMode();
          } else {
            // Fallback to legacy Unlocked modal
            openModal();
          }
        });
        btn._umBound = true;
      }
      console.debug('[UnlockedMode] ready');
    } catch(e) {
      console.warn('[UnlockedMode] boot error', e);
    }
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', boot);
  else boot();

  // Expose minimal API
  window.UnlockedMode = { open: openModal, submit: submitEntry, reset: resetAll };
})();
</script>

<!-- Legacy Unlocked toolbar injection removed (2025/10/31). Permanent header button is canonical. -->
 \1
<script>
function openEmotionModal() {
    document.getElementById('emotionModal').style.display = 'block';
    buildEmotionButtons();
}
function closeEmotionModal() {
    document.getElementById('emotionModal').style.display = 'none';
}
function buildEmotionButtons() {
    const container = document.getElementById("emotionButtons");
    if (container.childNodes.length > 0) return; // Avoid rebuilding
    const emotions = [
        "Joy","Happy","Cheerful","Content","Proud","Optimistic","Excited","Energetic","Affectionate","Compassionate","Peaceful","Relieved","Satisfied","Love",
        "Fear","Scared","Frightened","Helpless","Panic","Insecure","Worried","Nervous","Horrified","Terrified","Hysterical","Anxious","Overwhelmed",
        "Anger","Annoyed","Agitated","Frustrated","Mad","Rage","Hostile","Hateful","Jealous","Bitter","Irritated","Exasperated",
        "Sadness","Depressed","Lonely","Isolated","Ashamed","Guilty","Disappointed","Sorrow","Grief","Despair","Hurt","Powerless","Neglected",
        "Surprise","Amazed","Startled","Stunned","Confused","Shocked","Speechless","Awestruck","Overcome","Perplexed","Disillusioned"
    ];
    emotions.forEach(word => {
        const btn = document.cr
<script>
/* === Metric completeness helpers (2025/10/26 00:00:00) === */
const MAIN_FIELDS = ['rush','mood','social','energy','focus','anxiety','impair'];

/** Return how many of the seven main metrics are completed on a TR element. */
function countCompletedMetricsFromRow(tr){
  let n = 0;
  for (const f of MAIN_FIELDS){
    const td = tr.querySelector(`td[data-field="${f}Sum"]`);
    if (!td) continue;
    const hasDataValue = td.hasAttribute('data-value') && td.getAttribute('data-value').trim() !== '';
    const hasText = (td.textContent || '').trim() !== '';
    if (hasDataValue || hasText) n++;
  }
  return n;
}

/** Return how many of the seven main metrics are completed on a plain entry object (e.g., CSV/imported). */
function countCompletedMetricsFromEntry(e){
  let n = 0;
  for (const f of MAIN_FIELDS){
    const lbl = e && typeof e[`${f}Label`] === 'string' ? e[`${f}Label`].trim() : '';
    const hasLabel = lbl !== '';
    const val = e ? e[`${f}Sum`] : null;
    const hasValue = Number.isFinite(+val);
    if (hasLabel || hasValue) n++;
  }
  return n;
}

/** True if at least seven main metrics are completed. */
function hasAtLeastSeven(eOrTr){
  if (eOrTr && eOrTr.nodeType === 1) return countCompletedMetricsFromRow(eOrTr) >= 7;
  return countCompletedMetricsFromEntry(eOrTr) >= 7;
}
</script>
<script>
/* === Metric completeness helpers (2025/10/26 00:00:00) === */
const MAIN_FIELDS = ['rush','mood','social','energy','focus','anxiety','impair'];

/** Return how many of the seven main metrics are completed on a TR element. */
function countCompletedMetricsFromRow(tr){
  let n = 0;
  for (const f of MAIN_FIELDS){
    const td = tr.querySelector(`td[data-field="${f}Sum"]`);
    if (!td) continue;
    const hasDataValue = td.hasAttribute('data-value') && td.getAttribute('data-value').trim() !== '';
    const hasText = (td.textContent || '').trim() !== '';
    if (hasDataValue || hasText) n++;
  }
  return n;
}

/** Return how many of the seven main metrics are completed on a plain entry object (e.g., CSV/imported). */
function countCompletedMetricsFromEntry(e){
  let n = 0;
  for (const f of MAIN_FIELDS){
    const lbl = e && typeof e[`${f}Label`] === 'string' ? e[`${f}Label`].trim() : '';
    const hasLabel = lbl !== '';
    const val = e ? e[`${f}Sum`] : null;
    const hasValue = Number.isFinite(+val);
    if (hasLabel || hasValue) n++;
  }
  return n;
}

/** True if at least seven main metrics are completed. */
function hasAtLeastSeven(eOrTr){
  if (eOrTr && eOrTr.nodeType === 1) return countCompletedMetricsFromRow(eOrTr) >= 7;
  return countCompletedMetricsFromEntry(eOrTr) >= 7;
}
</script>
eateElement('button');
        btn.textContent = word;
        btn.className = 'note-btn';
        btn.style.minWidth = '80px';
        btn.onclick = () => {
            const notes = document.getElementById('notesInput');
            if (!notes.value.includes(word)) {
                notes.value = (notes.value + ' ' + word).trim();
            }
        };
        container.appendChild(btn);
    });
}
</script>

<script>
/* Injected on 2025/11/05 00:00:00
 * Feature: "All Rated 5-Minute (/10)" shows:
 *   (1) Global 5-min averages for the first 7 "* Sum" metrics + Score avg/min/max
 *   (2) Per-dose 5-min averages after each detected dose event (dose = Since/Elapsed < 00:00:05 OR decrease vs previous)
 * Feature: Dose Reviews modal gains an appended section showing per-dose 5-min averages (same metrics)
 * No style or structural changes; renders into existing containers.
 */

/* ---------- Helpers ---------- */
function parseRowTimestamp(tsText) {
  if (!tsText) return null;
  const t = String(tsText).trim();
  const m = t.match(/^(\d{4})\/(\d{2})\/(\d{2})[ T](\d{2}):(\d{2})(?::(\d{2}))?$/);
  if (m) {
    const Y = +m[1], M = +m[2]-1, D = +m[3], h = +m[4], mi = +m[5], s = +(m[6] ?? 0);
    const d = new Date(Y, M, D, h, mi, s, 0);
    return isNaN(d.getTime()) ? null : d;
  }
  const d2 = new Date(t);
  return isNaN(d2.getTime()) ? null : d2;
}
function hmsToSeconds(hmsText) {
  if (!hmsText) return null;
  const m = String(hmsText).trim().match(/^(\d{2}):(\d{2}):(\d{2})$/);
  if (!m) return null;
  return (+m[1])*3600 + (+m[2])*60 + (+m[3]);
}
function parseNum(x) {
  if (x == null) return null;
  const n = Number(String(x).trim());
  return Number.isFinite(n) ? n : null;
}
function floorTo5MinMs(dateObj) {
  const ms = dateObj.getTime(), five = 5*60*1000;
  return Math.floor(ms/five)*five;
}
function p2(n){ return String(n).padStart(2,'0'); }
function fmtStamp(d){ return `${d.getFullYear()}/${p2(d.getMonth()+1)}/${p2(d.getDate())} ${p2(d.getHours())}:${p2(d.getMinutes())}:${p2(d.getSeconds())}`; }
function format5MinWindow(msStart){ const s=new Date(msStart), e=new Date(msStart+5*60*1000); return `${fmtStamp(s)} – ${fmtStamp(e)}`; }

function detectMetricSumColumns(tableEl, maxMetrics=7) {
  const headers = Array.from(tableEl.querySelectorAll("thead tr th")).map(th => th.textContent.trim());
  const idxByName = {};
  const indices = [];
  const names = [];
  for (let i=0;i<headers.length;i++) {
    const h = headers[i];
    if (/sum$/i.test(h)) {
      indices.push(i);
      names.push(h);
      idxByName[h] = i;
      if (indices.length >= maxMetrics) break;
    }
  }
  return { idxByName, indicesInOrder: indices, namesInOrder: names };
}

/* ---------- Read main table (logTable) ---------- */
function readMainRowsMulti() {
  const table = document.querySelector("#logTable");
  if (!table) return { rows: [], metricNames: [], scoreIdx: -1 };

  const header = Array.from(table.querySelectorAll("thead tr th")).map(th => th.textContent.trim());
  const idxTimestamp = header.findIndex(t => /timestamp/i.test(t));
  const idxSince     = header.findIndex(t => /since|elapsed/i.test(t));
  const idxScore     = header.findIndex(t => /^score$/i.test(t));
  const metricScan   = detectMetricSumColumns(table, 7);
  const metricIdxs   = metricScan.indicesInOrder;
  const metricNames  = metricScan.namesInOrder;

  const bodyRows = Array.from(table.querySelectorAll("tbody tr"));
  const rows = [];

  for (const tr of bodyRows) {
    const tds = Array.from(tr.cells);
    const ts   = parseRowTimestamp(idxTimestamp>=0 ? tds[idxTimestamp]?.textContent : "");
    const sinceSec = hmsToSeconds(idxSince>=0 ? tds[idxSince]?.textContent : "");
    const score = idxScore>=0 ? parseNum(tds[idxScore]?.textContent) : null;

    const metrics = {};
    for (let k=0;k<metricIdxs.length;k++) {
      const ci = metricIdxs[k];
      const name = metricNames[k];
      const val = parseNum(tds[ci]?.textContent);
      metrics[name] = val;
    }

    rows.push({
      el: tr,
      ts,
      tsMs: ts ? ts.getTime() : null,
      sinceSec,
      score,
      metrics
    });
  }

  return {
    rows: rows.filter(r => r.tsMs !== null),
    metricNames,
    scoreIdx: idxScore
  };
}

/* ---------- Dose detection (no Drug requirement) ---------- */
function detectDoseStartsNoDrug(rows) {
  const starts = [];
  for (let i=0;i<rows.length;i++) {
    const s = rows[i].sinceSec;
    const prev = (i>0) ? rows[i-1].sinceSec : null;
    const condA = (s != null && s < 5);
    const condB = (s != null && prev != null && s < prev);
    if (condA || condB) starts.push(i);
  }
  return starts;
}

/* ---------- Global 5-minute averages ---------- */
function computeGlobal5MinAverages(rows, metricNames) {
  const buckets = new Map(); // msStart -> { n, metrics:{name:{sum,n}} , score:{sum,min,max,n} }
  for (const r of rows) {
    const ms = floorTo5MinMs(r.ts);
    let agg = buckets.get(ms);
    if (!agg) {
      agg = { n: 0, metrics: {}, score: { n:0, sum:0, min:Infinity, max:-Infinity } };
      for (const name of metricNames) agg.metrics[name] = { sum: 0, n: 0 };
      buckets.set(ms, agg);
    }
    agg.n++;
    for (const name of metricNames) {
      const v = r.metrics[name];
      if (v != null) { agg.metrics[name].sum += v; agg.metrics[name].n++; }
    }
    if (r.score != null) {
      agg.score.n++;
      agg.score.sum += r.score;
      if (r.score < agg.score.min) agg.score.min = r.score;
      if (r.score > agg.score.max) agg.score.max = r.score;
    }
  }

  return Array.from(buckets.entries())
    .sort((a,b)=>a[0]-b[0])
    .map(([ms, agg]) => {
      const item = {
        window: format5MinWindow(ms),
        count: agg.n,
        averages: {},
        scoreAvg: (agg.score.n>0 ? agg.score.sum/agg.score.n : null),
        scoreMin: (agg.score.n>0 ? agg.score.min : null),
        scoreMax: (agg.score.n>0 ? agg.score.max : null)
      };
      for (const name of metricNames) {
        const m = agg.metrics[name];
        item.averages[name] = (m.n>0 ? m.sum/m.n : null);
      }
      return item;
    });
}

/* ---------- Per-dose 5-minute averages ---------- */
function computePerDose5MinAverages(rows, doseStarts, metricNames) {
  const results = [];
  for (let d=0; d<doseStarts.length; d++) {
    const iStart = doseStarts[d];
    const tStartMs = rows[iStart].tsMs;
    const nextStartMs = (d+1 < doseStarts.length) ? rows[doseStarts[d+1]].tsMs : Infinity;

    const buckets = new Map(); // msBucketStart -> agg
    for (let j=iStart; j<rows.length; j++) {
      const r = rows[j];
      if (r.tsMs >= nextStartMs) break;
      if (r.tsMs < tStartMs) continue;

      const relBucketStart = tStartMs + Math.floor((r.tsMs - tStartMs) / (5*60*1000)) * (5*60*1000);
      let agg = buckets.get(relBucketStart);
      if (!agg) {
        agg = { n: 0, metrics: {}, score: { n:0, sum:0, min:Infinity, max:-Infinity } };
        for (const name of metricNames) agg.metrics[name] = { sum: 0, n: 0 };
        buckets.set(relBucketStart, agg);
      }
      agg.n++;
      for (const name of metricNames) {
        const v = r.metrics[name];
        if (v != null) { agg.metrics[name].sum += v; agg.metrics[name].n++; }
      }
      if (r.score != null) {
        agg.score.n++;
        agg.score.sum += r.score;
        if (r.score < agg.score.min) agg.score.min = r.score;
        if (r.score > agg.score.max) agg.score.max = r.score;
      }
    }

    const windows = Array.from(buckets.entries())
      .sort((a,b)=>a[0]-b[0])
      .map(([ms, agg]) => {
        const out = {
          window: format5MinWindow(ms),
          count: agg.n,
          averages: {},
          scoreAvg: (agg.score.n>0 ? agg.score.sum/agg.score.n : null),
          scoreMin: (agg.score.n>0 ? agg.score.min : null),
          scoreMax: (agg.score.n>0 ? agg.score.max : null)
        };
        for (const name of metricNames) {
          const m = agg.metrics[name];
          out.averages[name] = (m.n>0 ? m.sum/m.n : null);
        }
        return out;
      });

    results.push({ doseIndex: iStart, doseTime: new Date(tStartMs), windows });
  }
  return results;
}

/* ---------- Rendering ---------- */
function renderGlobal5MinTableIntoCard(cardEl, globalData, metricNames) {
  const section = document.createElement('section');
  const h = document.createElement('h3');
  h.textContent = 'Global 5-minute averages (raw Sum)';
  section.appendChild(h);

  const table = document.createElement('table');
  table.className = 'table table-striped table-sm';
  const thead = document.createElement('thead');
  const headerCells = [
    '<th>5-minute window</th>',
    ...metricNames.map(n=>`<th class="text-right">${n}</th>`),
    '<th class="text-right">Score Avg</th>',
    '<th class="text-right">Score Min</th>',
    '<th class="text-right">Score Max</th>',
    '<th class="text-right">n</th>'
  ];
  thead.innerHTML = `<tr>${headerCells.join('')}</tr>`;
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  for (const row of globalData) {
    const metricTds = metricNames.map(n => {
      const v = row.averages[n];
      return `<td class="text-right">${v!=null ? v.toFixed(2) : '—'}</td>`;
    });
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${row.window}</td>
      ${metricTds.join('')}
      <td class="text-right">${row.scoreAvg!=null ? row.scoreAvg.toFixed(2) : '—'}</td>
      <td class="text-right">${row.scoreMin!=null ? row.scoreMin.toFixed(2) : '—'}</td>
      <td class="text-right">${row.scoreMax!=null ? row.scoreMax.toFixed(2) : '—'}</td>
      <td class="text-right">${row.count}</td>
    `;
    tbody.appendChild(tr);
  }
  table.appendChild(tbody);
  section.appendChild(table);

  cardEl.appendChild(section);
}

function renderPerDose5MinTablesIntoCard(cardEl, perDoseData, metricNames) {
  const topH = document.createElement('h3');
  topH.textContent = 'Per-dose 5-minute averages (raw Sum)';
  cardEl.appendChild(topH);

  for (const seg of perDoseData) {
    const section = document.createElement('section');
    section.className = 'mb-4';

    const h = document.createElement('h4');
    h.textContent = `Dose starting ${fmtStamp(seg.doseTime)}`;
    section.appendChild(h);

    const table = document.createElement('table');
    table.className = 'table table-striped table-sm';
    const thead = document.createElement('thead');
    const headerCells = [
      '<th>5-minute window</th>',
      ...metricNames.map(n=>`<th class="text-right">${n}</th>`),
      '<th class="text-right">Score Avg</th>',
      '<th class="text-right">Score Min</th>',
      '<th class="text-right">Score Max</th>',
      '<th class="text-right">n</th>'
    ];
    thead.innerHTML = `<tr>${headerCells.join('')}</tr>`;
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    for (const w of seg.windows) {
      const metricTds = metricNames.map(n => {
        const v = w.averages[n];
        return `<td class="text-right">${v!=null ? v.toFixed(2) : '—'}</td>`;
      });
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${w.window}</td>
        ${metricTds.join('')}
        <td class="text-right">${w.scoreAvg!=null ? w.scoreAvg.toFixed(2) : '—'}</td>
        <td class="text-right">${w.scoreMin!=null ? w.scoreMin.toFixed(2) : '—'}</td>
        <td class="text-right">${w.scoreMax!=null ? w.scoreMax.toFixed(2) : '—'}</td>
        <td class="text-right">${w.count}</td>
      `;
      tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    section.appendChild(table);
    cardEl.appendChild(section);
  }
}

/* ---------- Drivers / Wiring ---------- */
function refreshAllRated5MinViews() {
  const { rows, metricNames } = readMainRowsMulti();
  rows.sort((a,b)=>a.tsMs-b.tsMs);

  const doseStarts = detectDoseStartsNoDrug(rows);
  const globalData = computeGlobal5MinAverages(rows, metricNames);
  const perDoseData = computePerDose5MinAverages(rows, doseStarts, metricNames);

  // Render inside the popup "card" container so we can show two tables
  const card = document.getElementById('allRated5MinutesOutOf10PopupCard');
  if (card) {
    // Clear only the dynamic area; avoid nuking close buttons etc.
    // We'll place content into/after a dedicated content div if present; else we add our own.
    let content = card.querySelector('#allRated5m-content');
    if (!content) {
      content = document.createElement('div');
      content.id = 'allRated5m-content';
      card.appendChild(content);
    }
    content.innerHTML = '';
    renderGlobal5MinTableIntoCard(content, globalData, metricNames);
    renderPerDose5MinTablesIntoCard(content, perDoseData, metricNames);
  } else {
    // Fallback: render into table id if the card is unavailable (will replace its content)
    const tbl = document.getElementById('allRated5MinutesOutOf10PopupTable');
    if (tbl && tbl.parentElement) {
      const host = tbl.parentElement;
      // clear siblings after table and then append our composed content
      const content = document.createElement('div');
      content.id = 'allRated5m-content';
      renderGlobal5MinTableIntoCard(content, globalData, metricNames);
      renderPerDose5MinTablesIntoCard(content, perDoseData, metricNames);
      host.appendChild(content);
    }
  }
}

// Wrap the opener to inject rendering after existing UI opens
(function wireAll5Open(){
  const orig = window.openAllRated5MinutesOutOf10Popup;
  if (typeof orig === 'function') {
    window.openAllRated5MinutesOutOf10Popup = function() {
      try { orig(); } catch(_e) {}
      setTimeout(refreshAllRated5MinViews, 50);
    };
  } else {
    // If no opener, expose manual refresh
    window.refreshAllRated5MinViews = refreshAllRated5MinViews;
  }
})();

/* Dose Reviews: append per-dose 5-min averages section beneath #doseReviewsTable */
function appendPerDoseToDoseReviews() {
  const { rows, metricNames } = readMainRowsMulti();
  rows.sort((a,b)=>a.tsMs-b.tsMs);
  const doseStarts = detectDoseStartsNoDrug(rows);
  const perDoseData = computePerDose5MinAverages(rows, doseStarts, metricNames);

  const table = document.getElementById('doseReviewsTable');
  if (!table) return;
  // Ensure a container after the existing table
  let host = document.getElementById('doseReviewsPer5min');
  if (!host) {
    host = document.createElement('div');
    host.id = 'doseReviewsPer5min';
    table.insertAdjacentElement('afterend', host);
  }
  host.innerHTML = '';

  // Render similarly to per-dose card rendering
  renderPerDose5MinTablesIntoCard(host, perDoseData, metricNames);
}

(function wireDoseReviewsOpen(){
  const orig = window.openDoseReviews;
  if (typeof orig === 'function') {
    window.openDoseReviews = function() {
      try { orig(); } catch(_e) {}
      setTimeout(appendPerDoseToDoseReviews, 50);
    };
  } else {
    // expose manual
    window.appendPerDoseToDoseReviews = appendPerDoseToDoseReviews;
  }
})();
</script>

<script>
/* Injected on 2025/11/05 00:00:00
 * EXACT columns for 5-min averages (global + per-dose):
 * Rush Sum, Mood Sum, Social Sum, Energy Sum, Focus Sum, Anxiety Sum, Impair Sum, Score, Min, Max, Weighted, 5Max
 * Dose start rule: Since/Elapsed < 00:00:05 OR Since/Elapsed decreased vs previous row (no Drug requirement)
 */

/*** === EXACT METRIC LIST (order required) === ***/
const METRIC_COLUMNS_EXACT = [
  "Rush Sum","Mood Sum","Social Sum","Energy Sum","Focus Sum","Anxiety Sum","Impair Sum",
  "Score","Min","Max","Weighted","5Max"
];

function normaliseHeaderName(s){
  return String(s||"").toLowerCase().replace(/\s+/g," ").trim();
}

function headerIndexMapExact(tableEl){
  const heads = Array.from(tableEl.querySelectorAll("thead tr th")).map(th => th.textContent.trim());
  const normHeads = heads.map(normaliseHeaderName);
  const wanted = METRIC_COLUMNS_EXACT.map(normaliseHeaderName);
  const idx = {};
  for (let i=0;i<wanted.length;i++){
    const name = wanted[i];
    const pos = normHeads.indexOf(name);
    idx[METRIC_COLUMNS_EXACT[i]] = (pos>=0 ? pos : -1);
  }
  // Also find Timestamp and Since/Elapsed
  const tsIdx = normHeads.findIndex(h => h.includes("timestamp"));
  const sinceIdx = normHeads.findIndex(h => h.includes("since") || h.includes("elapsed"));
  return { heads, normHeads, idx, tsIdx, sinceIdx };
}

/*** time + numeric helpers ***/
function parseRowTimestamp(tsText) {
  if (!tsText) return null;
  const t = String(tsText).trim();
  const m = t.match(/^(\d{4})\/(\d{2})\/(\d{2})[ T](\d{2}):(\d{2})(?::(\d{2}))?$/);
  if (m) {
    const Y = +m[1], M = +m[2]-1, D = +m[3], h = +m[4], mi = +m[5], s = +(m[6] ?? 0);
    const d = new Date(Y, M, D, h, mi, s, 0);
    return isNaN(d.getTime()) ? null : d;
  }
  const d2 = new Date(t);
  return isNaN(d2.getTime()) ? null : d2;
}
function hmsToSeconds(hmsText) {
  if (!hmsText) return null;
  const m = String(hmsText).trim().match(/^(\d{2}):(\d{2}):(\d{2})$/);
  if (!m) return null;
  return (+m[1])*3600 + (+m[2])*60 + (+m[3]);
}
function parseNum(x) {
  if (x == null) return null;
  const n = Number(String(x).trim());
  return Number.isFinite(n) ? n : null;
}
function floorTo5MinMs(dateObj) {
  const ms = dateObj.getTime(), five = 5*60*1000;
  return Math.floor(ms/five)*five;
}
function p2(n){ return String(n).padStart(2,'0'); }
function fmtStamp(d){ return `${d.getFullYear()}/${p2(d.getMonth()+1)}/${p2(d.getDate())} ${p2(d.getHours())}:${p2(d.getMinutes())}:${p2(d.getSeconds())}`; }
function format5MinWindow(msStart){ const s=new Date(msStart), e=new Date(msStart+5*60*1000); return `${fmtStamp(s)} – ${fmtStamp(e)}`; }

/*** read main table with EXACT metric columns ***/
function readMainRowsExact(){
  const table = document.querySelector("#logTable");
  if (!table) return { rows: [], metricNames: METRIC_COLUMNS_EXACT.slice() };

  const map = headerIndexMapExact(table);
  const bodyRows = Array.from(table.querySelectorAll("tbody tr"));
  const rows = [];

  for (const tr of bodyRows){
    const tds = Array.from(tr.cells);
    const ts   = (map.tsIdx>=0) ? parseRowTimestamp(tds[map.tsIdx]?.textContent) : null;
    if (!ts) continue;
    const sinceSec = (map.sinceIdx>=0) ? hmsToSeconds(tds[map.sinceIdx]?.textContent) : null;

    const metrics = {};
    for (const name of METRIC_COLUMNS_EXACT){
      const idx = map.idx[name];
      metrics[name] = (idx>=0 ? parseNum(tds[idx]?.textContent) : null);
    }

    rows.push({
      el: tr,
      ts,
      tsMs: ts.getTime(),
      sinceSec,
      metrics
    });
  }

  rows.sort((a,b)=>a.tsMs-b.tsMs);
  return { rows, metricNames: METRIC_COLUMNS_EXACT.slice() };
}

/*** dose starts (no Drug requirement) ***/
function detectDoseStartsNoDrug(rows){
  const starts=[];
  for (let i=0;i<rows.length;i++){
    const s = rows[i].sinceSec;
    const prev = (i>0) ? rows[i-1].sinceSec : null;
    const condA = (s!=null && s<5);
    const condB = (s!=null && prev!=null && s<prev);
    if (condA || condB) starts.push(i);
  }
  return starts;
}

/*** compute global 5-min averages for EXACT columns ***/
function computeGlobal5MinAveragesExact(rows, metricNames){
  const buckets = new Map(); // msStart -> { n, metrics: {name:{sum,n}} }
  for (const r of rows){
    const ms = floorTo5MinMs(r.ts);
    let agg = buckets.get(ms);
    if (!agg){
      agg = { n:0, metrics:{} };
      for (const name of metricNames) agg.metrics[name] = { sum:0, n:0 };
      buckets.set(ms, agg);
    }
    agg.n++;
    for (const name of metricNames){
      const v = r.metrics[name];
      if (v!=null){ agg.metrics[name].sum += v; agg.metrics[name].n++; }
    }
  }
  return Array.from(buckets.entries())
    .sort((a,b)=>a[0]-b[0])
    .map(([ms, agg])=>{
      const averages = {};
      for (const name of metricNames){
        const m = agg.metrics[name];
        averages[name] = (m.n>0 ? m.sum/m.n : null);
      }
      return { window: format5MinWindow(ms), count: agg.n, averages };
    });
}

/*** compute per-dose 5-min averages for EXACT columns ***/
function computePerDose5MinAveragesExact(rows, doseStarts, metricNames){
  const out=[];
  for (let d=0; d<doseStarts.length; d++){
    const iStart = doseStarts[d];
    const tStart = rows[iStart].tsMs;
    const nextStart = (d+1<doseStarts.length) ? rows[doseStarts[d+1]].tsMs : Infinity;

    const buckets = new Map(); // relStartMs -> agg
    for (let j=iStart; j<rows.length; j++){
      const r = rows[j];
      if (r.tsMs >= nextStart) break;
      if (r.tsMs <  tStart) continue;

      const rel = r.tsMs - tStart;
      const bStart = tStart + Math.floor(rel/(5*60*1000))*(5*60*1000);
      let agg = buckets.get(bStart);
      if (!agg){
        agg = { n:0, metrics:{} };
        for (const name of metricNames) agg.metrics[name] = { sum:0, n:0 };
        buckets.set(bStart, agg);
      }
      agg.n++;
      for (const name of metricNames){
        const v = r.metrics[name];
        if (v!=null){ agg.metrics[name].sum += v; agg.metrics[name].n++; }
      }
    }

    const windows = Array.from(buckets.entries())
      .sort((a,b)=>a[0]-b[0])
      .map(([ms, agg])=>{
        const averages = {};
        for (const name of metricNames){
          const m = agg.metrics[name];
          averages[name] = (m.n>0 ? m.sum/m.n : null);
        }
        return { window: format5MinWindow(ms), count: agg.n, averages };
      });

    out.push({ doseIndex: iStart, doseTime: new Date(tStart), windows });
  }
  return out;
}

/*** rendering ***/
function renderTableFromWindows_EXACT(host, rows, metricNames, titleText){
  const section = document.createElement('section');
  const h = document.createElement('h3');
  h.textContent = titleText;
  section.appendChild(h);

  const table = document.createElement('table');
  table.className = 'table table-striped table-sm';
  const thead = document.createElement('thead');
  thead.innerHTML = `<tr>
    <th>5-minute window</th>
    ${metricNames.map(n=>`<th class="text-right">${n}</th>`).join('')}
    <th class="text-right">n</th>
  </tr>`;
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  for (const row of rows){
    const metricTds = metricNames.map(n=>{
      const v = row.averages[n];
      return `<td class="text-right">${v!=null ? v.toFixed(2) : '—'}</td>`;
    });
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${row.window}</td>
      ${metricTds.join('')}
      <td class="text-right">${row.count}</td>
    `;
    tbody.appendChild(tr);
  }
  table.appendChild(tbody);
  section.appendChild(table);
  host.appendChild(section);
}

function renderPerDoseTables_EXACT(host, perDose, metricNames){
  const title = document.createElement('h3');
  title.textContent = 'Per-dose 5-minute averages (raw)';
  host.appendChild(title);

  for (const seg of perDose){
    const section = document.createElement('section');
    section.className = 'mb-4';

    const h = document.createElement('h4');
    h.textContent = `Dose starting ${fmtStamp(seg.doseTime)}`;
    section.appendChild(h);

    const table = document.createElement('table');
    table.className = 'table table-striped table-sm';
    const thead = document.createElement('thead');
    thead.innerHTML = `<tr>
      <th>5-minute window</th>
      ${METRIC_COLUMNS_EXACT.map(n=>`<th class="text-right">${n}</th>`).join('')}
      <th class="text-right">n</th>
    </tr>`;
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    for (const w of seg.windows){
      const metricTds = METRIC_COLUMNS_EXACT.map(n=>{
        const v = w.averages[n];
        return `<td class="text-right">${v!=null ? v.toFixed(2) : '—'}</td>`;
      });
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${w.window}</td>
        ${metricTds.join('')}
        <td class="text-right">${w.count}</td>
      `;
      tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    section.appendChild(table);
    host.appendChild(section);
  }
}

/*** drivers / wiring ***/
function refreshAllRated5MinViews_EXACT(){
  const { rows, metricNames } = readMainRowsExact();
  const doseStarts = detectDoseStartsNoDrug(rows);
  const globalData = computeGlobal5MinAveragesExact(rows, metricNames);
  const perDoseData = computePerDose5MinAveragesExact(rows, doseStarts, metricNames);

  const card = document.getElementById('allRated5MinutesOutOf10PopupCard');
  if (card){
    let content = card.querySelector('#allRated5m-content');
    if (!content){
      content = document.createElement('div');
      content.id = 'allRated5m-content';
      card.appendChild(content);
    }
    content.innerHTML = '';
    renderTableFromWindows_EXACT(content, globalData, metricNames, 'Global 5-minute averages (raw)');
    renderPerDoseTables_EXACT(content, perDoseData, metricNames);
  } else {
    const tbl = document.getElementById('allRated5MinutesOutOf10PopupTable');
    if (tbl && tbl.parentElement){
      let content = tbl.parentElement.querySelector('#allRated5m-content');
      if (!content){
        content = document.createElement('div');
        content.id = 'allRated5m-content';
        tbl.parentElement.appendChild(content);
      }
      content.innerHTML = '';
      renderTableFromWindows_EXACT(content, globalData, metricNames, 'Global 5-minute averages (raw)');
      renderPerDoseTables_EXACT(content, perDoseData, metricNames);
    }
  }
}

(function wireAll5Open_EXACT(){
  const orig = window.openAllRated5MinutesOutOf10Popup;
  if (typeof orig === 'function'){
    window.openAllRated5MinutesOutOf10Popup = function(){
      try { orig(); } catch(e){}
      setTimeout(refreshAllRated5MinViews_EXACT, 50);
    };
  } else {
    window.refreshAllRated5MinViews_EXACT = refreshAllRated5MinViews_EXACT;
  }
})();

function appendPerDoseToDoseReviews_EXACT(){
  const { rows, metricNames } = readMainRowsExact();
  const doseStarts = detectDoseStartsNoDrug(rows);
  const perDoseData = computePerDose5MinAveragesExact(rows, doseStarts, metricNames);

  const table = document.getElementById('doseReviewsTable');
  if (!table) return;
  let host = document.getElementById('doseReviewsPer5min');
  if (!host){
    host = document.createElement('div');
    host.id = 'doseReviewsPer5min';
    table.insertAdjacentElement('afterend', host);
  }
  host.innerHTML = '';
  renderPerDoseTables_EXACT(host, perDoseData, metricNames);
}

(function wireDoseReviewsOpen_EXACT(){
  const orig = window.openDoseReviews;
  if (typeof orig === 'function'){
    window.openDoseReviews = function(){
      try { orig(); } catch(e){}
      setTimeout(appendPerDoseToDoseReviews_EXACT, 50);
    };
  } else {
    window.appendPerDoseToDoseReviews_EXACT = appendPerDoseToDoseReviews_EXACT;
  }
})();
</script>

<script>
/* Injected on 2025/11/05 00:00:01
 * Fix: populate the 7 main "* Sum" metrics by summing paired columns:
 * Rush = cols 'Rush' (two cols), etc. Score/Min/Max/Weighted/5Max read from their single columns.
 */

(function(){
  const METRIC_COLUMNS_EXACT = [
    "Rush Sum","Mood Sum","Social Sum","Energy Sum","Focus Sum","Anxiety Sum","Impair Sum",
    "Score","Min","Max","Weighted","5Max"
  ];

  function normaliseHeaderName(s){
    return String(s||"").toLowerCase().replace(/\s+/g," ").trim();
  }

  function headerNameArray(table){
    const heads = Array.from(table.querySelectorAll("thead tr th")).map(th => th.textContent.trim());
    const norm = heads.map(normaliseHeaderName);
    return {heads, norm};
  }

  function indicesByExactName(normHeads, label){
    const target = normaliseHeaderName(label);
    const idxs = [];
    for (let i=0;i<normHeads.length;i++){
      if (normHeads[i] === target) idxs.push(i);
    }
    return idxs;
  }

  // Override readMainRowsExact with pair-sum derivation
  window.readMainRowsExact = function(){
    const table = document.querySelector("#logTable");
    if (!table) return { rows: [], metricNames: METRIC_COLUMNS_EXACT.slice() };

    const {heads, norm} = headerNameArray(table);

    const tsIdx = norm.findIndex(h => h.includes("timestamp"));
    const sinceIdx = norm.findIndex(h => h.includes("since") || h.includes("elapsed"));

    // base metric pairs
    const baseNames = ["Rush","Mood","Social","Energy","Focus","Anxiety","Impair"];
    const pairIdxs = {};
    for (const base of baseNames){
      pairIdxs[base] = indicesByExactName(norm, base.toLowerCase());
    }
    const singleIdxs = {
      "Score": indicesByExactName(norm, "score")[0] ?? -1,
      "Min": indicesByExactName(norm, "min")[0] ?? -1,
      "Max": indicesByExactName(norm, "max")[0] ?? -1,
      "Weighted": indicesByExactName(norm, "weighted")[0] ?? -1,
      "5Max": indicesByExactName(norm, "5max")[0] ?? -1
    };

    function parseNum(x){
      if (x == null) return null;
      const n = Number(String(x).trim());
      return Number.isFinite(n) ? n : null;
    }
    function parseRowTimestamp(tsText) {
      if (!tsText) return null;
      const t = String(tsText).trim();
      const m = t.match(/^(\d{4})\/(\d{2})\/(\d{2})[ T](\d{2}):(\d{2})(?::(\d{2}))?$/);
      if (m) {
        const Y = +m[1], M = +m[2]-1, D = +m[3], h = +m[4], mi = +m[5], s = +(m[6] ?? 0);
        const d = new Date(Y, M, D, h, mi, s, 0);
        return isNaN(d.getTime()) ? null : d;
      }
      const d2 = new Date(t);
      return isNaN(d2.getTime()) ? null : d2;
    }
    function hmsToSeconds(hmsText) {
      if (!hmsText) return null;
      const m = String(hmsText).trim().match(/^(\d{2}):(\d{2}):(\d{2})$/);
      if (!m) return null;
      return (+m[1])*3600 + (+m[2])*60 + (+m[3]);
    }

    const bodyRows = Array.from(table.querySelectorAll("tbody tr"));
    const rows = [];

    for (const tr of bodyRows){
      const tds = Array.from(tr.cells);
      const ts   = (tsIdx>=0) ? parseRowTimestamp(tds[tsIdx]?.textContent) : null;
      if (!ts) continue;
      const sinceSec = (sinceIdx>=0) ? hmsToSeconds(tds[sinceIdx]?.textContent) : null;

      const metrics = Object.create(null);

      // 7 sums from pairs
      for (const base of baseNames){
        const idxs = pairIdxs[base];
        let s = null;
        for (const ci of idxs){
          const v = parseNum(tds[ci]?.textContent);
          if (v != null){
            s = (s==null ? v : s+v);
          }
        }
        metrics[`${base} Sum`] = s;
      }

      // Singles
      metrics["Score"]    = (singleIdxs["Score"]>=0) ? parseNum(tds[singleIdxs["Score"]]?.textContent) : null;
      metrics["Min"]      = (singleIdxs["Min"]>=0) ? parseNum(tds[singleIdxs["Min"]]?.textContent) : null;
      metrics["Max"]      = (singleIdxs["Max"]>=0) ? parseNum(tds[singleIdxs["Max"]]?.textContent) : null;
      metrics["Weighted"] = (singleIdxs["Weighted"]>=0) ? parseNum(tds[singleIdxs["Weighted"]]?.textContent) : null;
      metrics["5Max"]     = (singleIdxs["5Max"]>=0) ? parseNum(tds[singleIdxs["5Max"]]?.textContent) : null;

      rows.push({
        el: tr,
        ts,
        tsMs: ts.getTime(),
        sinceSec,
        metrics
      });
    }

    rows.sort((a,b)=>a.tsMs-b.tsMs);
    return { rows, metricNames: METRIC_COLUMNS_EXACT.slice() };
  };
})();
</script>

<script>
/* Injected on 2025/11/05 00:00:02 (Australia/Sydney)
 * Raw averages (no +5), cell shading like main grid, multi-dose detection via Since/Elapsed rule.
 */
const METRIC_COLUMNS_EXACT = [
  "Rush Sum","Mood Sum","Social Sum","Energy Sum","Focus Sum","Anxiety Sum","Impair Sum",
  "Score","Min","Max","Weighted","5Max"
];
function _normHeader(s){ return String(s||"").toLowerCase().replace(/\s+/g," ").trim(); }
function _getHeaderMap(table){
  const heads = Array.from(table.querySelectorAll("thead tr th")).map(th => th.textContent.trim());
  const norm = heads.map(_normHeader);
  const tsIdx = norm.findIndex(h => h.includes("timestamp"));
  const sinceIdx = norm.findIndex(h => h.includes("since") || h.includes("elapsed"));
  return {heads, norm, tsIdx, sinceIdx};
}
function _parseTS(t){
  if (!t) return null;
  const s = String(t).trim();
  const m = s.match(/^(\d{4})\/(\d{2})\/(\d{2})[ T](\d{2}):(\d{2})(?::(\d{2}))?$/);
  if (m) { const d=new Date(+m[1], +m[2]-1, +m[3], +m[4], +m[5], +(m[6]||0), 0); return isNaN(d.getTime())?null:d; }
  const d2 = new Date(s); return isNaN(d2.getTime())?null:d2;
}
function _hmsToSec(h){ if (!h) return null; const m=String(h).trim().match(/^(\d{2}):(\d{2}):(\d{2})$/); if(!m) return null; return (+m[1])*3600+(+m[2])*60+(+m[3]); }
function _num(x){ if (x==null) return null; const n=Number(String(x).trim()); return Number.isFinite(n)?n:null; }
function _p2(n){return String(n).padStart(2,'0');}
function _fmt(d){return `${d.getFullYear()}/${_p2(d.getMonth()+1)}/${_p2(d.getDate())} ${_p2(d.getHours())}:${_p2(d.getMinutes())}:${_p2(d.getSeconds())}`;}
function _fmtWin(ms){const s=new Date(ms), e=new Date(ms+5*60*1000); return _fmt(s)+' – '+_fmt(e);}
function _bucket5(dt){return Math.floor(dt.getTime()/(5*60*1000))*(5*60*1000);}

function _readRows(){
  const table = document.querySelector('#logTable');
  if (!table) return {rows:[], metricNames: METRIC_COLUMNS_EXACT.slice()};
  const map = _getHeaderMap(table);
  const ths = Array.from(table.querySelectorAll('thead tr th')).map(th => th.textContent.trim());
  const bases = ['Rush','Mood','Social','Energy','Focus','Anxiety','Impair'];
  const pairIdxs = {}; for (const b of bases){ pairIdxs[b]=[]; for (let i=0;i<ths.length;i++) if (ths[i].toLowerCase()===b.toLowerCase()) pairIdxs[b].push(i); }
  const singles = { Score: ths.findIndex(h=>h.toLowerCase()==='score'),
    Min: ths.findIndex(h=>h.toLowerCase()==='min'),
    Max: ths.findIndex(h=>h.toLowerCase()==='max'),
    Weighted: ths.findIndex(h=>h.toLowerCase()==='weighted'),
    '5Max': ths.findIndex(h=>h.toLowerCase()==='5max') };

  const body = Array.from(table.querySelectorAll('tbody tr'));
  const out=[];
  for (const tr of body){
    const tds = Array.from(tr.cells);
    const ts = (map.tsIdx>=0) ? _parseTS(tds[map.tsIdx]?.textContent) : null;
    if (!ts) continue;
    const sinceSec = (map.sinceIdx>=0) ? _hmsToSec(tds[map.sinceIdx]?.textContent) : null;

    const metrics = {};
    for (const b of bases){
      let s = null;
      for (const ci of pairIdxs[b]){ const v=_num(tds[ci]?.textContent); if (v!=null) s=(s==null? v : s+v); }
      metrics[b+' Sum'] = s;
    }
    for (const k of Object.keys(singles)){ const i=singles[k]; metrics[k]=(i>=0? _num(tds[i]?.textContent): null); }

    out.push({ el: tr, ts, tsMs: ts.getTime(), sinceSec, metrics });
  }
  out.sort((a,b)=>a.tsMs-b.tsMs);
  return { rows: out, metricNames: METRIC_COLUMNS_EXACT.slice() };
}

function _detectDoseStarts(rows){
  const starts=[];
  for (let i=0;i<rows.length;i++){ const s=rows[i].sinceSec; const prev=(i>0? rows[i-1].sinceSec: null);
    if ((s!=null && s<5) || (s!=null && prev!=null && s<prev)) starts.push(i);
  } return starts;
}

function _avgWindowsGlobal(rows, metricNames){
  const buckets=new Map();
  for (const r of rows){
    const b=_bucket5(r.ts); let agg=buckets.get(b);
    if (!agg){ agg={n:0, metrics:{}}; for (const n of metricNames) agg.metrics[n]={sum:0,c:0}; buckets.set(b,agg); }
    agg.n++; for (const n of metricNames){ const v=r.metrics[n]; if (v!=null){ agg.metrics[n].sum+=v; agg.metrics[n].c++; } }
  }
  return Array.from(buckets.entries()).sort((a,b)=>a[0]-b[0]).map(([ms,agg])=>{
    const averages={}; for (const n of metricNames){ const m=agg.metrics[n]; averages[n]=(m.c>0? m.sum/m.c : null); }
    return { window:_fmtWin(ms), count:agg.n, averages };
  });
}

function _avgWindowsPerDose(rows, doseStarts, metricNames){
  const out=[];
  for (let d=0; d<doseStarts.length; d++){
    const iStart=doseStarts[d], t0=rows[iStart].tsMs, tNext=(d+1<doseStarts.length? rows[doseStarts[d+1]].tsMs: Infinity);
    const buckets=new Map();
    for (let j=iStart; j<rows.length; j++){
      const r=rows[j]; if (r.tsMs>=tNext) break; if (r.tsMs<t0) continue;
      const relStart=t0+Math.floor((r.tsMs-t0)/(5*60*1000))*(5*60*1000); let agg=buckets.get(relStart);
      if (!agg){ agg={n:0, metrics:{}}; for (const n of metricNames) agg.metrics[n]={sum:0,c:0}; buckets.set(relStart, agg); }
      agg.n++; for (const n of metricNames){ const v=r.metrics[n]; if (v!=null){ agg.metrics[n].sum+=v; agg.metrics[n].c++; } }
    }
    const windows=Array.from(buckets.entries()).sort((a,b)=>a[0]-b[0]).map(([ms,agg])=>{
      const averages={}; for (const n of metricNames){ const m=agg.metrics[n]; averages[n]=(m.c>0? m.sum/m.c : null); }
      return { window:_fmtWin(ms), count:agg.n, averages };
    });
    out.push({ doseIndex:iStart, doseTime:new Date(t0), windows });
  }
  return out;
}

function _td(name, val){
  const td=document.createElement('td');
  td.textContent = (val==null? '—' : Number(val).toFixed(2));
  td.setAttribute('data-col', name.replace(/ Sum$/,''));
  if (val!=null) td.setAttribute('data-value', String(val));
  return td;
}
function _shadeTR(tr){ try{ if (typeof window.applyRowShading==='function') window.applyRowShading(tr); }catch(e){} }

function _renderAll5(){
  const {rows, metricNames} = _readRows();
  const doseStarts=_detectDoseStarts(rows);
  const globalData=_avgWindowsGlobal(rows, metricNames);
  const perDoseData=_avgWindowsPerDose(rows, doseStarts, metricNames);

  const card = document.getElementById('allRated5MinutesOutOf10PopupCard');
  const fallbackTbl = document.getElementById('allRated5MinutesOutOf10PopupTable');
  let host=null;
  if (card){ host=card.querySelector('#allRated5m-content'); if(!host){ host=document.createElement('div'); host.id='allRated5m-content'; card.appendChild(host);} host.innerHTML=''; }
  else if (fallbackTbl && fallbackTbl.parentElement){ host=fallbackTbl.parentElement.querySelector('#allRated5m-content'); if(!host){ host=document.createElement('div'); host.id='allRated5m-content'; fallbackTbl.parentElement.appendChild(host);} host.innerHTML=''; }
  if (!host) return;

  function renderSection(title, rowsArr){
    const section=document.createElement('section');
    const h=document.createElement('h3'); h.textContent=title; section.appendChild(h);
    const table=document.createElement('table'); table.className='table table-striped table-sm';
    const thead=document.createElement('thead');
    thead.innerHTML = `<tr><th>5-minute window</th>${metricNames.map(n=>`<th class="text-right">${n}</th>`).join('')}<th class="text-right">n</th></tr>`;
    table.appendChild(thead);
    const tbody=document.createElement('tbody');
    for (const row of rowsArr){
      const tr=document.createElement('tr');
      const tdw=document.createElement('td'); tdw.textContent=row.window; tr.appendChild(tdw);
      for (const n of metricNames) tr.appendChild(_td(n, row.averages[n]));
      const tdn=document.createElement('td'); tdn.className='text-right'; tdn.textContent=String(row.count); tr.appendChild(tdn);
      tbody.appendChild(tr); _shadeTR(tr);
    }
    table.appendChild(tbody); section.appendChild(table); host.appendChild(section);
  }

  renderSection('Global 5-minute averages (raw)', globalData);
  const top=document.createElement('h3'); top.textContent='Per-dose 5-minute averages (raw)'; host.appendChild(top);
  for (const seg of perDoseData){
    const segWrap=document.createElement('section');
    const h=document.createElement('h4'); h.textContent='Dose starting '+_fmt(seg.doseTime); segWrap.appendChild(h);
    const table=document.createElement('table'); table.className='table table-striped table-sm';
    const thead=document.createElement('thead');
    thead.innerHTML = `<tr><th>5-minute window</th>${metricNames.map(n=>`<th class="text-right">${n}</th>`).join('')}<th class="text-right">n</th></tr>`;
    table.appendChild(thead);
    const tbody=document.createElement('tbody');
    for (const w of seg.windows){
      const tr=document.createElement('tr');
      const tdw=document.createElement('td'); tdw.textContent=w.window; tr.appendChild(tdw);
      for (const n of metricNames) tr.appendChild(_td(n, w.averages[n]));
      const tdn=document.createElement('td'); tdn.className='text-right'; tdn.textContent=String(w.count); tr.appendChild(tdn);
      tbody.appendChild(tr); _shadeTR(tr);
    }
    table.appendChild(tbody); segWrap.appendChild(table); host.appendChild(segWrap);
  }
}

(function(){
  const orig = window.openAllRated5MinutesOutOf10Popup;
  if (typeof orig === 'function'){ window.openAllRated5MinutesOutOf10Popup = function(){ try{orig();}catch(e){} setTimeout(_renderAll5,50); }; }
  else { window.renderAllRated5Raw = _renderAll5; }
})();

function _appendPerDoseToDoseReviews(){
  const {rows, metricNames} = _readRows();
  const doseStarts=_detectDoseStarts(rows);
  const perDose=_avgWindowsPerDose(rows, doseStarts, metricNames);
  const table=document.getElementById('doseReviewsTable');
  if (!table) return;
  let host=document.getElementById('doseReviewsPer5min');
  if (!host){ host=document.createElement('div'); host.id='doseReviewsPer5min'; table.insertAdjacentElement('afterend', host); }
  host.innerHTML='';
  const top=document.createElement('h3'); top.textContent='Per-dose 5-minute averages (raw)'; host.appendChild(top);
  for (const seg of perDose){
    const section=document.createElement('section'); const h=document.createElement('h4'); h.textContent='Dose starting '+_fmt(seg.doseTime); section.appendChild(h);
    const t=document.createElement('table'); t.className='table table-striped table-sm';
    const thead=document.createElement('thead'); thead.innerHTML=`<tr><th>5-minute window</th>${metricNames.map(n=>`<th class="text-right">${n}</th>`).join('')}<th class="text-right">n</th></tr>`; t.appendChild(thead);
    const tb=document.createElement('tbody');
    for (const w of seg.windows){
      const tr=document.createElement('tr'); const tdw=document.createElement('td'); tdw.textContent=w.window; tr.appendChild(tdw);
      for (const n of metricNames) tr.appendChild(_td(n, w.averages[n]));
      const tdn=document.createElement('td'); tdn.className='text-right'; tdn.textContent=String(w.count); tr.appendChild(tdn);
      tb.appendChild(tr); _shadeTR(tr);
    }
    t.appendChild(tb); section.appendChild(t); host.appendChild(section);
  }
}
(function(){
  const orig=window.openDoseReviews;
  if (typeof orig==='function'){ window.openDoseReviews=function(){ try{orig();}catch(e){} setTimeout(_appendPerDoseToDoseReviews,50); }; }
  else { window.appendPerDoseToDoseReviews=_appendPerDoseToDoseReviews; }
})();
</script>
</html>
<!-- === OVERRIDE: Auto timers reworked to isolate targets and cadences === -->
<script>
(function(){
  // Ensure globals exist from earlier script
  window.autoSummaryActive = !!window.autoSummaryActive;

  // Local state for four cadences
  let int1 = null, int5 = null, int15 = null, int60 = null;
  let last1 = null, last5 = null, last15 = null, last60 = null;

  // Helper: compute minute key "YYYYMMDDHHmm"
  function minuteKey(d){
    return d.getFullYear()
      + String(d.getMonth()+1).padStart(2,"0")
      + String(d.getDate()).padStart(2,"0")
      + String(d.getHours()).padStart(2,"0")
      + String(d.getMinutes()).padStart(2,"0");
  }
  // Label "HH:MM Average"
  function formatMinuteLabel(d){
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    return `${hh}:${mm} Average`;
  }

  // Read-only snapshot from main table (same invariant as existing code)
  function snapshotFromMainTable() {
  const table = document.querySelector(CFG.mainTableSelector);
  if (!table) return [];

  const thead = table.tHead || table.querySelector('thead');
  const tbody = table.tBodies?.[0] || table.querySelector('tbody');

  let headers = [];
  if (thead) {
    headers = Array.from(thead.querySelectorAll('th')).map(th => th.textContent.trim());
  } else {
    const firstRow = table.querySelector('tr');
    if (firstRow) headers = Array.from(firstRow.cells).map(td => td.textContent.trim());
  }
  if (!headers.length) return [];

  const tsIdx = (() => {
    const wanted = (window.CONFIG?.backfill?.timestampHeaderNames) || CFG.tsHeaderNames;
    const idxExact = headers.findIndex(h => wanted.some(n => h.toLowerCase() === n.toLowerCase()));
    if (idxExact >= 0) return idxExact;
    const idxContains = headers.findIndex(h => /time|timestamp/i.test(h));
    return idxContains;
  })();
  if (tsIdx < 0) return [];

  const rowEls = tbody ? Array.from(tbody.rows)
                       : Array.from(table.querySelectorAll('tr')).slice(1);
  const rows = [];
  for (const tr of rowEls) {
    if (tr.classList?.contains('backfill-summary-row')) continue;
    const tds = Array.from(tr.cells);
    if (tds.length <= tsIdx) continue;
    const cells = tds.map(td => td.textContent.trim());
    const ts = parseLocalAU(cells[tsIdx], tds[tsIdx]);
    if (ts) rows.push({_ts: ts.getTime(), tr, cells});
  }
  rows.sort((a,b)=>a._ts-b._ts);

  if (!rows.length) {
    console.warn('[Backfill] Snapshot empty. Headers=', headers, 'tsIdx=', tsIdx, 'rowCount=', rowEls.length);
  }
  return rows;
}
  function computeMeansForWindow(startMs, endMs){
    const snap = snapshotFromMainTable();
    const sel = snap.filter(e => e._ts >= startMs && e._ts < endMs);
    if (!sel.length) return null;
    const flds = ['rush','mood','social','energy','focus','anxiety','impair'];
    const sums = {rush:0,mood:0,social:0,energy:0,focus:0,anxiety:0,impair:0};
    sel.forEach(e => flds.forEach(f => sums[f] += (e[f]||0)));
    const means = {}; flds.forEach(f => means[f] = +(sums[f]/sel.length));
    return means;
  }
  function computeRollingMeans(endMs, minutes){
    return computeMeansForWindow(endMs - minutes*60*1000, endMs);
  }
  function computeCompositeFromMeans(M){
    const score = (M.rush+M.mood+M.social+M.energy+M.focus) - (M.anxiety+M.impair);
    const max   = Math.max(M.rush,M.mood,M.social,M.energy,M.focus);
    const min   = Math.min(M.rush,M.mood,M.social,M.energy,M.focus);
    const weighted = computeWeighted(M);
    const fiveMax  = ((M.rush + M.mood + M.social + M.energy + M.focus - M.anxiety - M.impair) / 5) + 5;
    return {score, max, min, weighted, fiveMax};
  }

  function appendSummaryRowToTable(tableId, d, M, C, labelSuffix){
    if (!M) return;
    const table = document.getElementById(tableId);
    if (!table) return;
    const tbody = table.querySelector('tbody'); if (!tbody) return;
    const row = [
      (formatMinuteLabel(d) + (labelSuffix?(" "+labelSuffix):"")),
      M.rush, M.mood, M.social, M.energy, M.focus, M.anxiety, M.impair,
      C.score, C.max, C.min, C.weighted, C.fiveMax
    ];
    const tr = document.createElement("tr");
    const cols = ["Time","Rush","Mood","Social","Energy","Focus","Anxiety","Impair","Score","Max","Min","Weighted","5Max"];
    tr.innerHTML = row.map((v,i)=>{
      if (i===0) return `<td>${v??''}</td>`;
      const num = Number(v);
      const isNum = Number.isFinite(num);
      // reuse global cellBgFor if present
      const name = cols[i];
      const bg = isNum && typeof window.cellBgFor==='function' ? window.cellBgFor(name, num) : '';
      const val = isNum ? num.toFixed(2) : (v ?? '');
      return `<td${bg?` style="background-color:${bg};"`:''}>${val}</td>`;
    }).join("");
    tbody.appendChild(tr);
  }

  // Boundary alignment helpers
  function msToNextMinute(d){ const t = new Date(d); t.setSeconds(0,0); return 60000 - (d - t); }
  function msToNextMultipleMinutes(d, m){
    const t = new Date(d);
    const curMin = t.getMinutes();
    const next = curMin + (m - (curMin % m || 0));
    t.setMinutes(next, 0, 0);
    return t.getTime() - d.getTime();
  }
  function msToTopOfHour(d){
    const t = new Date(d); t.setMinutes(60,0,0);
    return t.getTime() - d.getTime();
  }

  // Emitters for 1/5/15/60 with de-dup keys
  function emitCadence(periodMin, tableId, lastKeyRef){
    const now = new Date();
    const end = new Date(now); end.setSeconds(0,0);
    const key = end.getFullYear()
      + String(end.getMonth()+1).padStart(2,"0")
      + String(end.getDate()).padStart(2,"0")
      + String(end.getHours()).padStart(2,"0")
      + String(end.getMinutes()).padStart(2,"0");
    if (lastKeyRef.key === key) return;
    lastKeyRef.key = key;
    const M = computeRollingMeans(end.getTime(), periodMin);
    if (!M) return;
    const C = computeCompositeFromMeans(M);
    appendSummaryRowToTable(tableId, end, M, C, `${periodMin}m Avg`);
  }

  // Clear all timers
  function clearAll(){
    [int1,int5,int15,int60].forEach(x => { if (x) { clearInterval(x); } });
    int1=int5=int15=int60=null;
    last1=last5=last15=last60=null;
  }

  // Public toggle override
  window.toggleAutoSummary = function(){
    const btn = document.getElementById('autoSummaryToggleBtn');
    const wasActive = !!window.autoSummaryActive;
    if (wasActive){
      clearAll();
      window.autoSummaryActive = false;
      if (btn) btn.textContent = 'Auto';
      return;
    }
    // Turning ON
    clearAll();
    window.autoSummaryActive = true;
    if (btn) btn.textContent = 'Auto (On)';
    // Update titles to reflect 1m rolling
    const t = document.getElementById('autoSummaryTitle');
    if (t) t.textContent = 'Auto Summary (1m rolling)';
    // Ensure tables exist
    ['autoSummaryTable','summary5Table','summary15Table','summary60Table'].forEach(id=>{
      const el = document.getElementById(id);
      if (el){
        const tb = el.querySelector('tbody');
        if (tb) tb.innerHTML=''; // clear on (re)start
      }
    });
    // Schedule boundary-aligned timers
    const now = new Date();
    // 1 minute cadence -> autoSummaryTable
    last1 = {key:null};
    setTimeout(()=>{
      emitCadence(1, 'autoSummaryTable', last1);
      int1 = setInterval(()=>emitCadence(1, 'autoSummaryTable', last1), 60000);
    }, msToNextMinute(now));
    // 5 minute cadence -> summary5Table
    last5 = {key:null};
    setTimeout(()=>{
      emitCadence(5, 'summary5Table', last5);
      int5 = setInterval(()=>emitCadence(5, 'summary5Table', last5), 300000);
    }, msToNextMultipleMinutes(now, 5));
    // 15 minute cadence -> summary15Table
    last15 = {key:null};
    setTimeout(()=>{
      emitCadence(15, 'summary15Table', last15);
      int15 = setInterval(()=>emitCadence(15, 'summary15Table', last15), 900000);
    }, msToNextMultipleMinutes(now, 15));
    // 60 minute cadence -> summary60Table
    last60 = {key:null};
    setTimeout(()=>{
      emitCadence(60, 'summary60Table', last60);
      int60 = setInterval(()=>emitCadence(60, 'summary60Table', last60), 3600000);
    }, msToTopOfHour(now));
  };

  // Remove any immediate "Now" or mirroring behaviour by shadowing any old helpers
  // (No-op stubs to avoid accidental cross-posting from earlier code)
  window.emitAuto1m = function(){};           // disable old 1s spammer
  window.emitAuto5m = function(){};           // keep disabled; we use new per-table emitters
  // setSummaryWindowAndOpen remains untouched; summary buttons will simply open/focus any UI you already have
})();

// ──────────────────────────────────────────────────────────────────────────────
// Dose Reviews popup: show summaries (avg/median/min/max) + all visible rows
// ──────────────────────────────────────────────────────────────────────────────
(function(){
  // Columns we will extract (must match data-col in main table rows)
  const NUM_COLS = ["Rush","Mood","Social","Energy","Focus","Anxiety","Impair","Score","Max","Min","Weighted","5Max"]; const ALL_COLS = ["Time","Since Dose", ...NUM_COLS];

  // Attempt to find the main table reliably
  function getMainTable(){
    // Try common IDs used in earlier builds; fallback to the first big data table
    const candidates = [
      "#dataTable", "#mainTable", "#logTable",
      "table[data-role='main']", ".main-table"
    ];
    for (const sel of candidates){
      const el = document.querySelector(sel);
      if (el) return el;
    }
    // Fallback: the largest table in DOM (by number of body rows)
    const tables = Array.from(document.querySelectorAll("table"));
    let best = null, bestCount = -1;
    for (const t of tables){
      const c = t.tBodies && t.tBodies[0] ? t.tBodies[0].rows.length : 0;
      if (c > bestCount){ best = t; bestCount = c; }
    }
    return best;
  }

  // Read visible rows and extract a normalized object per row
  function collectVisibleMainRows(){
    const tbl = getMainTable();
    const out = [];
    if (!tbl || !tbl.tBodies || !tbl.tBodies[0]) return out;
    const rows = Array.from(tbl.tBodies[0].rows);
    for (const tr of rows){
      const style = window.getComputedStyle(tr);
      if (style.display === 'none' || tr.hidden) continue; // skip non-visible
      // Extract by data-col if present; else map by header text
      const cells = Array.from(tr.cells);
      const rowObj = {};

      // Build index by data-col
      const byCol = {};
      for (const td of cells){
        const col = (td.getAttribute('data-col')||'').trim();
        if (col) byCol[col] = td;
      }

      // Helper to get cell text/value for a named col
      function cellVal(colName){
        let td = byCol[colName];
        if (!td){
          // fallback: try to locate by header position
          const ths = tbl.tHead ? Array.from(tbl.tHead.rows[0].cells) : [];
          const idx = ths.findIndex(th => (th.textContent||'').trim().toLowerCase() === colName.toLowerCase());
          if (idx >= 0 && cells[idx]) td = cells[idx];
        }
        if (!td) return null;
        // Prefer numeric from data-value if present; otherwise parse text
        const dv = td.getAttribute('data-value');
        if (dv !== null && dv !== undefined) return dv;
        return td.textContent || "";
      }

      for (const c of ALL_COLS){
        rowObj[c] = cellVal(c);
      }

      // Try to parse a timestamp for stable ordering; tolerate various formats
      let ts = null;
      if (rowObj.Time){
        const tryNum = +rowObj.Time;
        if (Number.isFinite(tryNum) && tryNum > 1e10){
          ts = tryNum; // maybe ms-since-epoch
        } else {
          const d = new Date(rowObj.Time);
          if (!isNaN(d.getTime())) ts = d.getTime();
        }
      }
      rowObj._ts = ts;

      // Coerce numeric columns
      {
        const n = +rowObj["Since Dose"];
        rowObj["Since Dose"] = Number.isFinite(n) ? n : null;
      }
      for (const k of NUM_COLS){
        const n = +rowObj[k];
        rowObj[k] = Number.isFinite(n) ? n : null;
      }
      out.push(rowObj);
    }
    // Sort by timestamp if we have it, otherwise keep order
    out.sort((a,b)=>{
      if (a._ts && b._ts) return a._ts - b._ts;
      return 0;
    });
    return out;
  }

  // Stats helpers
  function arrNum(xs){ return xs.filter(v => Number.isFinite(v)); }
  function mean(xs){
    const a = arrNum(xs); if (!a.length) return null;
    let s = 0; for (const v of a) s += v; return s / a.length;
  }
  function median(xs){
    const a = arrNum(xs).slice().sort((x,y)=>x-y);
    if (!a.length) return null;
    const m = Math.floor(a.length/2);
    return (a.length % 2) ? a[m] : (a[m-1]+a[m])/2;
  }
  function minv(xs){
    const a = arrNum(xs); if (!a.length) return null;
    return Math.min(...a);
  }
  function maxv(xs){
    const a = arrNum(xs); if (!a.length) return null;
    return Math.max(...a);
  }
  function toFixedMaybe(v, p=2){ return (v===null || v===undefined) ? "" : (+v).toFixed(p); }

  function buildSummaryRows(visibleRows){
    // Build column-wise arrays
    const cols = {};
    for (const k of NUM_COLS) cols[k] = [];
    for (const r of visibleRows){
      for (const k of NUM_COLS){
        cols[k].push(r[k]);
      }
    }
    // Compute the four summaries
    const summaries = [
      { label: "Average", fn: mean },
      { label: "Median",  fn: median },
      { label: "Minimum", fn: minv },
      { label: "Maximum", fn: maxv },
    ];
    const out = [];
    for (const s of summaries){
      const rowObj = { Label: s.label, Time: "" };
      for (const k of NUM_COLS){
        rowObj[k] = s.fn(cols[k]);
      }
      out.push(rowObj);
    }
    return out;
  }

  function renderDoseReviewsTable(visibleRows){
    const tbody = document.querySelector('#doseReviewsTable tbody');
    const meta  = document.querySelector('#doseReviewsMeta');
    if (!tbody) return;
    tbody.innerHTML = '';

    const segments = segmentBySinceDose(visibleRows);

    // Meta line
    if (meta){
      const n = visibleRows.length;
      const when = new Date().toLocaleString('en-AU', { hour12:false });
      meta.textContent = `Computed from ${n} visible row(s) in ${segments.length} segment(s) at ${when}.`;
    }

    // For each segment: header, 4 summary rows, separator, then rows
    segments.forEach(seg => {
      // Segment header row (visual)
      const hdr = document.createElement('tr');
      hdr.innerHTML = `<td data-col="Label" colspan="${2 + NUM_COLS.length}" style="font-weight:700; background:#f7f7f7;">Segment ${seg.index}</td>`;
      tbody.appendChild(hdr);

      // Summary rows
      const summaries = buildSummaryRowsFor(seg.rows);
      for (const s of summaries){
        const tr = document.createElement('tr');
        let html = `<td data-col="Label" style="font-weight:600;">${s.Label}</td><td data-col="Segment">${seg.index}</td><td data-col="Time"></td>`;
        for (const k of NUM_COLS){
          const v = s[k];
          const vv = (v===null||v===undefined) ? "" : (+v).toFixed(2);
          html += `<td data-col="${k}" data-value="${v??''}">${vv}</td>`;
        }
        tr.innerHTML = html;
        try { tagRowCells(tr); } catch(_){}
        try { applyRowShading(tr); } catch(_){}
        try { applyUiColumnVisibility(); } catch(_){}
        tbody.appendChild(tr);
      }

      // Thin separator
      const sep = document.createElement('tr');
      sep.innerHTML = `<td colspan="${2 + 1 + NUM_COLS.length}" style="height:6px; background:#ececec;"></td>`;
      tbody.appendChild(sep);

      // Segment rows
      for (const r of seg.rows){
        const tr = document.createElement('tr');
        const timeTxt = r.Time ? r.Time : "";
        let html = `<td data-col="Label"></td><td data-col="Segment">${seg.index}</td><td data-col="Time">${timeTxt}</td>`;
        for (const k of NUM_COLS){
          const v = r[k];
          const vv = (v===null||v===undefined) ? "" : (+v).toFixed(2);
          html += `<td data-col="${k}" data-value="${v??''}">${vv}</td>`;
        }
        tr.innerHTML = html;
        try { tagRowCells(tr); } catch(_){}
        try { applyRowShading(tr); } catch(_){}
        try { applyUiColumnVisibility(); } catch(_){}
        tbody.appendChild(tr);
      }

      // Extra space between segments
      const space = document.createElement('tr');
      space.innerHTML = `<td colspan="${2 + 1 + NUM_COLS.length}" style="height:8px;"></td>`;
      tbody.appendChild(space);
    });
  }

  function csvEscape(s){
    const t = String(s ?? "");
    return /[",\n]/.test(t) ? `"${t.replace(/"/g,'""')}"` : t;
  }
  function tableToCsv(tbl){
    const ths = Array.from(tbl.tHead.rows[0].cells).map(th => th.textContent.trim());
    const rows = Array.from(tbl.tBodies[0].rows).map(tr =>
      Array.from(tr.cells).map(td => csvEscape(td.textContent.trim())).join(",")
    );
    return [ths.join(","), ...rows].join("\n");
  }

  // --- Segment rows by "Since Dose" resets (== 0 starts a new segment) ---
  
function segmentBySinceDose(visibleRows){
  const segments = [];
  let cur = [];
  let segIndex = 0;

  const readSD = (r) => {
    if (r && Object.prototype.hasOwnProperty.call(r, 'Since Dose')) return Number(r['Since Dose']);
    if (r && Object.prototype.hasOwnProperty.call(r, 'sincedose')) return Number(r['sincedose']);
    return NaN;
  };

  const pushCur = () => {
    if (cur.length){
      segments.push({ index: ++segIndex, rows: cur });
      cur = [];
    }
  };

  for (let i = 0; i < visibleRows.length; i++){
    const r = visibleRows[i];
    if (i > 0){
      const prev = readSD(visibleRows[i-1]);
      const curr = readSD(r);
      if (Number.isFinite(prev) && Number.isFinite(curr) && curr < prev){
        // start new segment at this row because Since Dose decreased
        pushCur();
      }
    }
    cur.push(r);
  }
  pushCur();

  if (!segments.length && visibleRows.length){
    segments.push({ index: 1, rows: visibleRows.slice() });
  }
  return segments;
}


  function buildSummaryRowsFor(rows){
    const cols = {};
    for (const k of NUM_COLS) cols[k] = [];
    for (const r of rows){
      for (const k of NUM_COLS){
        cols[k].push(r[k]);
      }
    }
    const summaries = [
      { label: "Average", fn: mean },
      { label: "Median",  fn: median },
      { label: "Minimum", fn: minv },
      { label: "Maximum", fn: maxv },
    ];
    const out = [];
    for (const s of summaries){
      const rowObj = { Label: s.label, Time: "", Segment: "" };
      for (const k of NUM_COLS){
        rowObj[k] = s.fn(cols[k]);
      }
      out.push(rowObj);
    }
    return out;
  }

  // Public entrypoints
  window.openDoseReviews = function(){
    try{
      const vis = collectVisibleMainRows();
      if (!vis.length){
        alert("No visible rows in the main table.");
        return;
      }
      const summaries = buildSummaryRows(vis);
      renderDoseReviewsTable(vis, summaries);
      const modal = document.getElementById('doseReviewsModal');
      if (modal) modal.style.display = 'block';
    }catch(e){
      console.error(e);
      alert("Dose Reviews failed: " + e.message);
    }
  };
  window.closeDoseReviews = function(){
    const modal = document.getElementById('doseReviewsModal');
    if (modal) modal.style.display = 'none';
  };
  window.exportDoseReviewsCsv = function(){
    const tbl = document.getElementById('doseReviewsTable');
    if (!tbl) return;
    const csv = tableToCsv(tbl);
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8;"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const stamp = new Date().toISOString().replace(/[-:TZ.]/g,'').slice(0,14);
    a.href = url;
    a.download = `dose_reviews_${stamp}.csv`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  // Close on backdrop click / ESC
  document.addEventListener('click', (e)=>{
    if (e.target && e.target.id === 'doseReviewsBackdrop') closeDoseReviews();
  });
  document.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape') closeDoseReviews();
  });
})();
// ──────────────────────────────────────────────────────────────────────────────
</script>
<script>

// Ensure Auto Entries open/clear/export exist
(function(){
  if (typeof window.openAutoEntries === 'function') return;
  function appendAutoEntriesRow(d){
    var tb=document.querySelector('#autoEntriesTable tbody'); if(!tb) return;
    var tr=document.createElement('tr');
    function td(n,v){ var c=document.createElement('td'); c.textContent=(v!=null?v:''); c.setAttribute('data-col', n); return c; }
    var now = (typeof timeLabel==='function') ? timeLabel(Date.now()) : new Date().toLocaleTimeString();
    tr.appendChild(td('Time', now));
    tr.appendChild(td('Rush', (d&&d.Rush)||0));  tr.appendChild(td('Mood', (d&&d.Mood)||0));  tr.appendChild(td('Social', (d&&d.Social)||0));
    tr.appendChild(td('Energy',(d&&d.Energy)||0));tr.appendChild(td('Focus',(d&&d.Focus)||0));tr.appendChild(td('Anxiety',(d&&d.Anxiety)||0));
    tr.appendChild(td('Impair',(d&&d.Impair)||0));tr.appendChild(td('Weighted',(d&&d.Weighted)||0));tr.appendChild(td('Score5',(d&&d.Score5)||0));
    try{ applyRowShading(tr); }catch(e){} tb.appendChild(tr);
  }
  function loadEntries(){ try{return JSON.parse(localStorage.getItem('auto_entries_rows')||'[]');}catch(e){return [];} }
  function saveEntries(r){ try{localStorage.setItem('auto_entries_rows', JSON.stringify(r||[]));}catch(e){} }
  window.openAutoEntries=function(){
    var tb=document.querySelector('#autoEntriesTable tbody'); if(tb) tb.innerHTML='';
    (loadEntries()||[]).forEach(function(r){ appendAutoEntriesRow(r.data); });
    if (typeof openModal==='function') openModal('#autoEntriesModal'); else { var m=document.getElementById('autoEntriesModal'); if(m) m.style.display='block'; }
  };
  window.toggleAutoEntries=function(){
    if (window.autoEntriesTimer){ clearInterval(window.autoEntriesTimer); window.autoEntriesTimer=null; return; }
    function emit(){ var data=readCurrentSelections(); var rows=loadEntries(); rows.push({t:Date.now(), data:data}); saveEntries(rows); appendAutoEntriesRow(data); }
    emit(); window.autoEntriesTimer = setInterval(emit, 15000);
  };
  window.clearAutoEntries=function(){ saveEntries([]); var tb=document.querySelector('#autoEntriesTable tbody'); if(tb) tb.innerHTML=''; };
  window.exportAutoEntriesCSV=function(){
    var rows = loadEntries(); if(!rows.length){ alert('No rows to export.'); return; }
    var out = ['Time,Rush,Mood,Social,Energy,Focus,Anxiety,Impair,Weighted,Score5'];
    rows.forEach(function(r){ var d=r.data||{}; out.push([timeLabel(r.t),d.Rush,d.Mood,d.Social,d.Energy,d.Focus,d.Anxiety,d.Impair,d.Weighted,d.Score5].join(',')); });
    var blob=new Blob([out.join('\n')],{type:'text/csv'}); var a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='auto_entries.csv'; a.click(); URL.revokeObjectURL(a.href);
  };
})();

</script>

<!-- === Rolling Average Patch (bind missing APIs) === -->
<script>
(function(){
  // Storage keys and state
  var LS_KEY_RA = 'rolling_average_rows';
  function loadRolling(){ try{ return JSON.parse(localStorage.getItem(LS_KEY_RA) || '[]'); }catch(e){ return []; } }
  function saveRolling(rows){ try{ localStorage.setItem(LS_KEY_RA, JSON.stringify(rows||[])); }catch(e){} }

  function getLogRows(){
    return Array.from(document.querySelectorAll('#logTable tbody tr')).filter(function(tr){
      return tr.offsetParent !== null;
    });
  }
  function getLogTableColumnMap(){
    var map = {};
    document.querySelectorAll('#logTable thead th').forEach(function(th, idx){
      var name = (th.textContent || '').trim();
      if (name) map[name] = idx;
    });
    return map;
  }
  function resolveMetricIndex(colMap, headerCells, rowEl, baseName){
    if (colMap[baseName + ' Sum'] != null) return colMap[baseName + ' Sum'];
    var idxs = []; headerCells.forEach(function(h,i){ if (h === baseName) idxs.push(i); });
    if (!idxs.length) return colMap[baseName];
    var tr = rowEl;
    if (!tr){
      var tb = document.querySelector('#logTable tbody');
      tr = tb && tb.querySelector('tr') ? tb.querySelector('tr') : null;
    }
    function isNum(t){ var s=String(t||'').trim(); var x=parseFloat(s); return s && !isNaN(x); }
    for (var k=0;k<idxs.length;k++){
      var i=idxs[k]; var cell=tr&&tr.children&&tr.children[i]? tr.children[i].textContent:null;
      if (isNum(cell)) return i;
    }
    return idxs[idxs.length-1];
  }
  function rowToObj(tr, col){
    var c = tr.children;
    function cell(name){ var idx = col[name]; return (idx != null && c[idx]) ? (c[idx].textContent || '').trim() : ''; }
    function numBy(base){
      var hs = Array.from(document.querySelectorAll('#logTable thead th')).map(function(t){return t.textContent.trim();});
      var i = resolveMetricIndex(col, hs, tr, base);
      return i!=null ? (parseFloat(c[i].textContent)||0) : 0;
    }
    return {
      Rush: numBy('Rush'), Mood: numBy('Mood'), Social: numBy('Social'),
      Energy: numBy('Energy'), Focus: numBy('Focus'), Anxiety: numBy('Anxiety'), Impair: numBy('Impair'),
      Weighted: parseFloat(cell('Weighted')) || 0,
      Score5: parseFloat(cell('5Max')) || parseFloat(cell('Score5')) || 0
    };
  }

  function computeRollingAverage(){
    var col = getLogTableColumnMap();
    var rs = getLogRows().map(function(tr){ return rowToObj(tr, col); });
    if (rs.length < 1) return null;
    var windowSize = (CONFIG && CONFIG.popups && CONFIG.popups.rollingAverage && CONFIG.popups.rollingAverage.windowRows) || 5;
    var slice = rs.slice(-windowSize);
    function mean(k){ return slice.reduce(function(a,r){return a+(+r[k]||0);},0) / slice.length; }
    return {
      Rush: mean('Rush'), Mood: mean('Mood'), Social: mean('Social'), Energy: mean('Energy'),
      Focus: mean('Focus'), Anxiety: mean('Anxiety'), Impair: mean('Impair'),
      Weighted: mean('Weighted'), Score5: mean('Score5')
    };
  }

  function appendRollingRow(avg){
    var tb = document.querySelector('#rollingAverageTable tbody'); if (!tb) return;
    var tr = document.createElement('tr');
    function td(n,v){ var c=document.createElement('td'); c.textContent=(v!=null? (typeof v==='number'? v.toFixed(2):v):''); c.setAttribute('data-col',n); return c; }
    var now = new Date();
    tr.appendChild(td('Time', now.toLocaleTimeString()));
    tr.appendChild(td('Rush', avg.Rush)); tr.appendChild(td('Mood', avg.Mood)); tr.appendChild(td('Social', avg.Social));
    tr.appendChild(td('Energy', avg.Energy)); tr.appendChild(td('Focus', avg.Focus)); tr.appendChild(td('Anxiety', avg.Anxiety));
    tr.appendChild(td('Impair', avg.Impair)); tr.appendChild(td('Weighted', avg.Weighted)); tr.appendChild(td('Score5', avg.Score5));
    try{ if (typeof applyRowShading==='function') applyRowShading(tr); }catch(e){}
    tb.appendChild(tr);
  }

  window.openRollingAverage = function(){
    var tb = document.querySelector('#rollingAverageTable tbody');
    if (tb) tb.innerHTML = '';

    var rows = loadRolling() || [];

    // If no stored rolling rows yet, compute one on demand from current log
    if (!rows.length) {
      try {
        var avg = computeRollingAverage();
        if (avg) {
          var snap = { t: Date.now(), data: avg };
          rows.push(snap);
          saveRolling(rows);
        }
      } catch (e) {
        console.warn('openRollingAverage compute error', e);
      }
    }

    rows.forEach(function(r){
      appendRollingRow(r.data);
    });

    if (typeof openModal === 'function') {
      openModal('#rollingAverageModal');
    } else {
      var m = document.getElementById('rollingAverageModal');
      if (m) m.style.display = 'block';
    }
  };
  window.clearRollingAverage = function(){
    saveRolling([]); var tb = document.querySelector('#rollingAverageTable tbody'); if (tb) tb.innerHTML='';
  };
  window.exportRollingAverageCSV = function(){
    var rows = loadRolling(); if (!rows.length){ alert('No rows to export.'); return; }
    var out = ['Time,Avg Rush,Avg Mood,Avg Social,Avg Energy,Avg Focus,Avg Anxiety,Avg Impair,Weighted,Score5'];
    rows.forEach(function(r){
      var d = r.data;
      out.push([
        (new Date(r.t)).toLocaleTimeString(),
        d.Rush.toFixed(2), d.Mood.toFixed(2), d.Social.toFixed(2), d.Energy.toFixed(2),
        d.Focus.toFixed(2), d.Anxiety.toFixed(2), d.Impair.toFixed(2),
        d.Weighted.toFixed(2), d.Score5.toFixed(2)
      ].join(','));
    });
    var blob = new Blob([out.join('\n')], {type:'text/csv'});
    var a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download='rolling_average.csv'; a.click(); URL.revokeObjectURL(a.href);
  };

  // Optional toggle timer (30s) — if you have a button, wire to this.
  window.toggleRollingAverage = function(){
    if (window.rollingAvgTimer){ clearInterval(window.rollingAvgTimer); window.rollingAvgTimer=null; return; }
    function emit(){ var avg = computeRollingAverage(); if (!avg) return; var rows = loadRolling(); rows.push({t:Date.now(), data:avg}); saveRolling(rows); appendRollingRow(avg); }
    emit(); window.rollingAvgTimer = setInterval(emit, 30000);
  };
})();
document.addEventListener('DOMContentLoaded', function(){
  var btn = document.getElementById('rollingAvgBtn');
  if (btn && !btn._raBound) {
    btn.addEventListener('click', function(){
      // Always open the popup
      if (typeof openRollingAverage === 'function') {
        openRollingAverage();
      }
      // Start background rolling average updates if not already running
      if (typeof toggleRollingAverage === 'function' && !window.rollingAvgTimer) {
        toggleRollingAverage();
      }
    });
    btn._raBound = true;
  }
});

// === Rated Popup ===


const RATING_CONFIG = {
  rush: [
    { test: v => v > 4.5, label: 'Extreme', cls: 'veryhigh' },
    { test: v => v >= 4 && v <= 4.5, label: 'Very Strong', cls: 'veryhigh' },
    { test: v => v >= 3 && v < 4, label: 'Strong', cls: 'high' },
    { test: v => v >= 2 && v < 3, label: 'Moderate', cls: 'medium' },
    { test: v => v > 0 && v < 2, label: 'Some', cls: 'low' },
    { test: v => v === 0, label: 'No', cls: 'none' }
  ],
  mood: [
    { test: v => v > 4.5, label: 'Extreme', cls: 'veryhigh' },
    { test: v => v >= 4 && v <= 4.5, label: 'Very High', cls: 'veryhigh' },
    { test: v => v >= 3 && v < 4, label: 'High', cls: 'high' },
    { test: v => v >= 2 && v < 3, label: 'Moderate', cls: 'medium' },
    { test: v => v > 0 && v < 2, label: 'Some', cls: 'low' },
    { test: v => v === 0, label: 'None', cls: 'none' }
  ],
  social: [
    { test: v => v > 4.5, label: 'Extreme', cls: 'veryhigh' },
    { test: v => v >= 4 && v <= 4.5, label: 'Very High', cls: 'veryhigh' },
    { test: v => v >= 3 && v < 4, label: 'High', cls: 'high' },
    { test: v => v >= 2 && v < 3, label: 'Moderate', cls: 'medium' },
    { test: v => v > 0 && v < 2, label: 'Some', cls: 'low' },
    { test: v => v === 0, label: 'No', cls: 'none' }
  ],
  energy: [
    { test: v => v > 4.5, label: 'Extreme', cls: 'veryhigh' },
    { test: v => v >= 4 && v <= 4.5, label: 'Very High', cls: 'veryhigh' },
    { test: v => v >= 3 && v < 4, label: 'High', cls: 'high' },
    { test: v => v >= 2 && v < 3, label: 'Moderate', cls: 'medium' },
    { test: v => v > 0 && v < 2, label: 'Some', cls: 'low' },
    { test: v => v === 0, label: 'Low', cls: 'none' }
  ],
  focus: [
    { test: v => v > 4.5, label: 'Extreme', cls: 'veryhigh' },
    { test: v => v >= 4 && v <= 4.5, label: 'Very Strong', cls: 'veryhigh' },
    { test: v => v >= 3 && v < 4, label: 'Strong', cls: 'high' },
    { test: v => v >= 2 && v < 3, label: 'Moderate', cls: 'medium' },
    { test: v => v > 0 && v < 2, label: 'Some', cls: 'low' },
    { test: v => v === 0, label: 'Low', cls: 'none' }
  ],
  anxiety: [
    { test: v => v > 4.5, label: 'Extreme', cls: 'veryhigh' },
    { test: v => v >= 4 && v <= 4.5, label: 'Very High', cls: 'veryhigh' },
    { test: v => v >= 3 && v < 4, label: 'High', cls: 'high' },
    { test: v => v > 2 && v < 3, label: 'Moderate', cls: 'medium' },
    { test: v => v >= 1 && v <= 2, label: 'Some', cls: 'low' },
    { test: v => v >= 0 && v < 1, label: 'Low/None', cls: 'none' }
  ],
  impair: [
    { test: v => v > 4.5, label: 'Extreme', cls: 'veryhigh' },
    { test: v => v >= 4 && v <= 4.5, label: 'Very High', cls: 'veryhigh' },
    { test: v => v >= 3 && v < 4, label: 'High', cls: 'high' },
    { test: v => v > 2 && v < 3, label: 'Moderate', cls: 'medium' },
    { test: v => v >= 1 && v <= 2, label: 'Some', cls: 'low' },
    { test: v => v >= 0 && v < 1, label: 'Low/None', cls: 'none' }
  ]
};

function normaliseMetricKey(m){
  if (!m) return '';
  const s = String(m).toLowerCase();
  if (s.startsWith('rush')) return 'rush';
  if (s.startsWith('mood')) return 'mood';
  if (s.startsWith('soc'))  return 'social';
  if (s.startsWith('ener')) return 'energy';
  if (s.startsWith('foc'))  return 'focus';
  if (s.startsWith('anx'))  return 'anxiety';
  if (s.startsWith('imp'))  return 'impair';
  if (s.startsWith('impair')) return 'impair';
  return s;
}


function computeRatingCategory(metricOrVal, maybeVal){
  let metric = '', val;
  if (typeof metricOrVal === 'string'){
    metric = normaliseMetricKey(metricOrVal);
    val = Number(maybeVal);
  } else {
    val = Number(metricOrVal);
  }
  if (!Number.isFinite(val)) return { label:'None', cls:'none' };
  const cfg = RATING_CONFIG[metric] || RATING_CONFIG['rush'];
  for (const rule of cfg){
    if (rule.test(val)) return { label: rule.label, cls: rule.cls };
  }
  return { label:'None', cls:'none' };
}


function currentMaxFor(metric){
  try{
    const arr = (selections && Array.isArray(selections[metric])) ? selections[metric] : [];
    if (!arr.length) return 0;
    const nums = arr.map(Number).filter(Number.isFinite);
    if (!nums.length) return 0;
    return Math.max.apply(null, nums);
  }catch(e){ return 0; }
}
function renderRatedPopup(){
  const tbl = document.querySelector('#ratedPopupTable tbody');
  if (!tbl) return;
  const rows = [];
  const order = ['rush','mood','social','energy','focus','anxiety','impair'];
  order.forEach(m=>{
    const maxv = currentMaxFor(m);
    const cat = computeRatingCategory(m, maxv);
    const label = m.charAt(0).toUpperCase() + m.slice(1);
    rows.push(`<tr><td>${label}</td><td class="cat ${String(cat).toLowerCase()}"><span class="badge ${String(cat).toLowerCase()}">${cat}</span></td><td>${(Number.isFinite(maxv)? maxv.toFixed(2): '')}</td></tr>`);
  });
  tbl.innerHTML = rows.join('');
}
function openRatedPopup(){
  try { renderRatedPopup(); } catch(e){}
  const el = document.getElementById('ratedPopupModal');
  if (el) el.style.display = 'block';
  const bd = document.getElementById('ratedPopupBackdrop');
  if (bd) bd.onclick = closeRatedPopup;
}
function closeRatedPopup(){
  const el = document.getElementById('ratedPopupModal');
  if (el) el.style.display = 'none';
}

// === All Rated Popup (row-based categories) ===


function renderAllRatedPopup(){
  try{
    const tb = document.querySelector('#allRatedPopupTable tbody');
    if (!tb) return;
    const rows = [];
    const source = Array.isArray(logData) ? logData : [];
    source.forEach(r => {
      const t = (r.timestamp || '');
      const rush = computeRatingCategory(r.rushSum);
      const mood = computeRatingCategory(r.moodSum);
      const social = computeRatingCategory(r.socialSum);
      const energy = computeRatingCategory(r.energySum);
      const focus = computeRatingCategory(r.focusSum);
      const anxiety = computeRatingCategory('anxiety', r.anxietySum);
      const impair = computeRatingCategory('impair', r.impairSum);
      const _rush=computeRatingCategory(r.rushSum), _mood=computeRatingCategory(r.moodSum), _social=computeRatingCategory(r.socialSum), _energy=computeRatingCategory(r.energySum), _focus=computeRatingCategory(r.focusSum), _anxiety=computeRatingCategory('anxiety', r.anxietySum), _impair=computeRatingCategory('impair', r.impairSum);
rows.push(`<tr>
  <td>${t}</td>
  <td class="cat ${_rush.cls}"><span class="badge ${_rush.cls}">${_rush.label}</span></td>
  <td class="cat ${_mood.cls}"><span class="badge ${_mood.cls}">${_mood.label}</span></td>
  <td class="cat ${_social.cls}"><span class="badge ${_social.cls}">${_social.label}</span></td>
  <td class="cat ${_energy.cls}"><span class="badge ${_energy.cls}">${_energy.label}</span></td>
  <td class="cat ${_focus.cls}"><span class="badge ${_focus.cls}">${_focus.label}</span></td>
  <td class="cat ${_anxiety.cls}"><span class="badge ${_anxiety.cls}">${_anxiety.label}</span></td>
  <td class="cat ${_impair.cls}"><span class="badge ${_impair.cls}">${_impair.label}</span></td>
</tr>`);
    });
    tb.innerHTML = rows.join('');
  }catch(e){
    console.error('renderAllRatedPopup error', e);
  }
}
function openAllRatedPopup(){
  renderAllRatedPopup();
  const el = document.getElementById('allRatedPopupModal');
  if (el) el.style.display = 'block';
  const bd = document.getElementById('allRatedPopupBackdrop');
  if (bd) bd.onclick = closeAllRatedPopup;
}
function closeAllRatedPopup(){
  const el = document.getElementById('allRatedPopupModal');
  if (el) el.style.display = 'none';
}
</script>

<script>
// === STS Canonical maths (single source of truth) ===
(function(){
  function STS_computeComposite(means){
    if (!means) return null;
    const m = means.means || means;
    const score = (+m.rush + +m.mood + +m.social + +m.energy + +m.focus) - (+m.anxiety + +m.impair);
    const max   = Math.max(+m.rush, +m.mood, +m.social, +m.energy, +m.focus);
    const min   = Math.min(+m.rush, +m.mood, +m.social, +m.energy, +m.focus);
    const weighted = (((+m.rush*6) + (+m.mood*4) + (+m.social*4) + (+m.energy*4) + (+m.focus*4) - (+m.anxiety*4) - (+m.impair*4)) / 10);
    const fiveMax  = ((+m.rush + +m.mood + +m.social + +m.energy + +m.focus - (+m.anxiety) - (+m.impair)) / 5) + 5;
    return {score, max, min, weighted, fiveMax};
  }
  // Patch existing variants to delegate to canonical (if present on page)
  try { window.computeCompositeFromMeans = (M)=>STS_computeComposite(M); } catch(e){}
  try { window.computeCompositeFromMeansHour = (M)=>STS_computeComposite(M); } catch(e){}
  try { window.computeCompositeFromMeansUniversal = STS_computeComposite; } catch(e){}
})();
</script>

<script>
(function(){
  // Minute-aligned auto summary scheduler (replaces per-second churn)
  let _autoTimer = null;
  let _autoActive = false;

  function _emitAutoMinute(){
    try {
      const endMs = Date.now();
      if (typeof computeRollingMeans !== 'function') return;
      const M = computeRollingMeans(endMs, (typeof SUMMARY_WINDOW_MINUTES!=='undefined'? SUMMARY_WINDOW_MINUTES : 5));
      const C = (typeof computeCompositeFromMeans === 'function') ? computeCompositeFromMeans(M) : null;
      const d = new Date();
      if (M && typeof appendSummaryRowToTable === 'function'){
        appendSummaryRowToTable('autoSummaryTable', d, M, C, {bold:false, labelSuffix:' 5m Now'});
      }
    } catch(e){ console.warn(e); }
  }

  function toggleAutoSummaryPatched(){
    _autoActive = !_autoActive;
    const btn1 = document.getElementById('autoSummaryBtn');
    const btn2 = document.getElementById('autoSummaryToggleBtn');
    if (_autoActive){
      if (btn1) btn1.textContent = 'Auto (On)';
      if (btn2) btn2.textContent = 'Auto (On)';
      // emit once immediately
      _emitAutoMinute();
      // align to next minute
      const now = new Date();
      const msToNext = (60 - now.getSeconds())*1000 - now.getMilliseconds();
      setTimeout(()=>{
        if (_autoTimer) clearInterval(_autoTimer);
        _emitAutoMinute();
        _autoTimer = setInterval(_emitAutoMinute, 60000);
      }, Math.max(0, msToNext));
    } else {
      if (btn1) btn1.textContent = 'Auto (Off)';
      if (btn2) btn2.textContent = 'Auto';
      if (_autoTimer){ clearInterval(_autoTimer); _autoTimer = null; }
    }
  }

  // Replace global toggle if present
  try { window.toggleAutoSummary = toggleAutoSummaryPatched; } catch(e){}
})();
</script>



<script>
// Debounced saver for tripLog (to reduce churn)
(function(){
  let _saveT = null;
  function setTripLogDebounced(data){
    try {
      const s = JSON.stringify(data);
      if (_saveT) clearTimeout(_saveT);
      _saveT = setTimeout(()=>{
        try { localStorage.setItem('tripLog', s); } catch(e){ console.warn('tripLog save failed', e); }
      }, 300);
    } catch(e){ console.warn(e); }
  }
  window.setTripLogDebounced = setTripLogDebounced;
})();
</script>

<script>
// === Reusable table builder (conservative integration) ===
(function(){
  function STS_buildRowHTML(row){
    function val(v){ return (v==null||v==='') ? '' : v; }
    const cols = [];
    const order = ['timestamp','sincedose','elapsed','info','scale','drug','qty','roa',
      'rush','rush_label','mood','mood_label','social','social_label','energy','energy_label',
      'focus','focus_label','anxiety','anxiety_label','impair','impair_label',
      'auto','auto_label','jitter','jitter_label','dopamine','dopamine_label',
      'score','max','min','weighted','fiveMax','customNotes','notes'];
    for (let k of order){
      let v = row[k];
      if (k==='info'||k==='scale'||k==='drug'||k==='qty'||k==='roa'||k==='customNotes'||k==='notes'){
        v = (typeof __esc==='function') ? __esc(v||'') : (v||'');
      }
      cols.push(`<td${k?` data-col="${k}"`:''}>${val(v)}</td>`);
    }
    return `<tr>${cols.join('')}</tr>`;
  }
  function STS_buildTableHTML(rows){
    const parts = ['<tbody>'];
    for (let r of rows){ parts.push(STS_buildRowHTML(r)); }
    parts.push('</tbody>');
    return parts.join('');
  }
  window.STS_buildRowHTML = STS_buildRowHTML;
  window.STS_buildTableHTML = STS_buildTableHTML;

  try {
    const _origRender = window.renderTable;
    if (typeof _origRender === 'function'){
      window.renderTable = function(){
        try {
          const table = document.getElementById('mainLogTable');
          if (!table) return _origRender.apply(this, arguments);
          _origRender.apply(this, arguments);
          const tbody = table.querySelector('tbody');
          if (!Array.isArray(window.logData)){ return; }
          const html = STS_buildTableHTML(window.logData);
          if (tbody){
            const frag = document.createElement('tbody');
            frag.innerHTML = html.replace(/^<tbody>|<\/tbody>$/g,'');
            table.replaceChild(frag, tbody);
          }
        } catch(e){ console.warn('renderTable patch failed', e); _origRender.apply(this, arguments); }
      };
    }
  } catch(e){}
})();
</script>

<script>
(function(){
  const STORAGE_KEY = 'hiddenColumnsV1';
  function loadHidden(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEY)||'[]'); }catch(e){ return []; } }
  function saveHidden(arr){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(arr)); }catch(e){} }

  function applyHidden(table, hidden){
    if (!table) return;
    const set = new Set(hidden);
    const ths = table.querySelectorAll('th[data-col]');
    ths.forEach((th)=>{
      const col = th.getAttribute('data-col');
      const hide = set.has(col);
      th.style.display = hide ? 'none' : '';
      const tds = table.querySelectorAll(`td[data-col="${CSS.escape(col)}"]`);
      tds.forEach(td => td.style.display = hide ? 'none' : '');
    });
  }

  function buildChooser(){
    const table = document.getElementById('mainLogTable');
    if (!table) return;
    const list = document.getElementById('columnChooserList');
    if (!list) return;
    const hidden = loadHidden();
    const ths = table.querySelectorAll('th[data-col]');
    list.innerHTML='';
    ths.forEach(th=>{
      const col = th.getAttribute('data-col');
      const id = 'chk_'+col;
      const checked = hidden.indexOf(col)===-1;
      const div = document.createElement('div');
      div.innerHTML = `<label><input type="checkbox" id="${id}" ${checked?'checked':''}/> ${col}</label>`;
      list.appendChild(div);
      div.querySelector('input').addEventListener('change', ()=>{
        const h = new Set(loadHidden());
        if (div.querySelector('input').checked){ h.delete(col); } else { h.add(col); }
        saveHidden(Array.from(h));
        applyHidden(table, Array.from(h));
  });
  }

  function initChooser(){
    const btn = document.getElementById('colChooserToggle');
    const panel = document.getElementById('columnChooser');
    const close = document.getElementById('colChooserClose');
    const table = document.getElementById('mainLogTable');
    if (!btn || !panel || !table) return;
    btn.addEventListener('click', ()=>{
      const visible = panel.style.display==='block';
      if (!visible){ buildChooser(); }
      panel.style.display = visible ? 'none' : 'block';
    });
    if (close){ close.addEventListener('click', ()=> panel.style.display='none'); }
    applyHidden(table, loadHidden());
  }

  document.addEventListener('DOMContentLoaded', initChooser);
  window.addEventListener('load', ()=>{
    setTimeout(()=>{
      const table = document.getElementById('mainLogTable');
      applyHidden(table, loadHidden());
    }, 500);
  });
})();
</script>

<script>
(function(){
  function pad(n){ return (n<10?'0':'')+n; }
  function formatYMDHMS(d){
    try{
      if(!(d instanceof Date)) d = new Date(d);
      const Y = d.getFullYear();
      const M = pad(d.getMonth()+1);
      const D = pad(d.getDate());
      const h = pad(d.getHours());
      const m = pad(d.getMinutes());
      const s = pad(d.getSeconds());
      return `${Y}/${M}/${D} ${h}:${m}:${s}`;
    }catch(e){ return ''; }
  }
  window.STS_formatYMDHMS = formatYMDHMS;
  function normaliseTimestampCells(){
    const table = document.getElementById('mainLogTable');
    if(!table) return;
    const cells = table.querySelectorAll('td[data-col="timestamp"]');
    cells.forEach(td=>{
      const raw = td.textContent || td.innerText || '';
      const d = new Date(raw);
      if(!isNaN(d.getTime())) td.textContent = formatYMDHMS(d);
    });
  }
  document.addEventListener('DOMContentLoaded', ()=> setTimeout(normaliseTimestampCells, 300));
  window.addEventListener('load', ()=> setTimeout(normaliseTimestampCells, 600));
  window.STS_normaliseTimestampCells = normaliseTimestampCells;
})();
</script>

<script>
(function(){
  document.addEventListener('keydown', function(ev){
    if (ev.key === 'Escape'){
      const panel = document.getElementById('columnChooser');
      if (panel && panel.style.display==='block'){ panel.style.display='none'; }
    }
  });
})();
</script>

<style>
:root{
  --bg:#f9f9fb; --text:#111; --card:#fff; --muted:#cfd3da; --brand:#007aff; --modalBack: rgba(0,0,0,0.45);
  --btn-text:#fff; --btn-bg: var(--brand);
  --table-border:#d7dbe3; --table-head:#f2f3f7;
  --positive:#16a34a; --negative:#dc2626; --accent:#2563eb;
}
:root[data-theme="dark"]{
  --bg:#0f1115; --text:#e6e6e6; --card:#161a20; --muted:#2a2f3a; --brand:#58a6ff; --modalBack: rgba(0,0,0,0.55);
  --btn-text:#0b1117; --btn-bg:#8ecbff;
  --table-border:#2a2f3a; --table-head:#1b2028;
  --positive:#22c55e; --negative:#f87171; --accent:#60a5fa;
}
body{ background:var(--bg); color:var(--text); }
table{ background:var(--card); }
table, th, td{ border-color: var(--table-border); }
thead th{ background: var(--table-head); }
.summary-controls button{ background: var(--btn-bg); color: var(--btn-text); }
#ratedPopupBackdrop{ background: var(--modalBack); }
</style>
<script>
(function(){
  const KEY='stsTheme';
  function applyTheme(t){
    document.documentElement.dataset.theme = t;
    try{ localStorage.setItem(KEY, t); }catch(e){}
    const btn = document.getElementById('themeToggleBtn');
    if (btn) btn.textContent = (t==='dark') ? 'Light' : 'Dark';
  }
  function initTheme(){
    const saved = localStorage.getItem(KEY);
    if (saved){ applyTheme(saved); return; }
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    applyTheme(prefersDark ? 'dark' : 'light');
  }
  document.addEventListener('DOMContentLoaded', ()=>{
    initTheme();
    const btn = document.createElement('button');
btn.classList.add('metric-btn');
    btn.id = 'themeToggleBtn';
    btn.style.position='fixed'; btn.style.top='70px'; btn.style.right='92px'; btn.style.zIndex='10000';
    btn.textContent = (localStorage.getItem(KEY)==='dark') ? 'Light' : 'Dark';
    btn.addEventListener('click', ()=>{
      const cur = document.documentElement.dataset.theme || 'light';
      applyTheme(cur==='dark' ? 'light' : 'dark');
    });
    document.body.appendChild(btn);
  });
  try {
    const mq = window.matchMedia('(prefers-color-scheme: dark)');
    mq.addEventListener('change', (e)=>{
      const saved = localStorage.getItem(KEY);
      if (!saved){ applyTheme(e.matches ? 'dark' : 'light'); }
    });
  } catch(e){}
})();
</script>

<style>
/* Inputs/Textareas theme-aware */
input[type="text"], input[type="number"], input[type="search"], input[type="time"], input[type="date"], textarea, select{
  background: var(--input-bg, #fff);
  color: var(--input-text, #111);
  border: 1px solid var(--input-border, #ccc);
}
:root[data-theme="dark"] input[type="text"],
:root[data-theme="dark"] input[type="number"],
:root[data-theme="dark"] input[type="search"],
:root[data-theme="dark"] input[type="time"],
:root[data-theme="dark"] input[type="date"],
:root[data-theme="dark"] textarea,
:root[data-theme="dark"] select{
  --input-bg: #1e232a;
  --input-text: #e6e6e6;
  --input-border: #3a3f4a;
}

/* Metric buttons */
[data-metric], .metric-btn{
  background: var(--metric-bg, #f2f2f2);
  color: var(--metric-text, #111);
  border: 1px solid var(--metric-border, #ccc);
  border-radius: 6px;
}
:root[data-theme="dark"] [data-metric],
:root[data-theme="dark"] .metric-btn{
  --metric-bg: #2a2f3a;
  --metric-text: #e6e6e6;
  --metric-border: #3a3f4a;
}
/* Active state shading stays legible on both themes */
[data-metric][data-active="true"],
.metric-btn[data-active="true"],
[data-metric].active, .metric-btn.active,
[data-metric].selected, .metric-btn.selected{
  background: var(--metric-active, rgba(0,122,255,0.25));
}
:root[data-theme="dark"] [data-metric][data-active="true"],
:root[data-theme="dark"] .metric-btn[data-active="true"],
:root[data-theme="dark"] [data-metric].active, :root[data-theme="dark"] .metric-btn.active,
:root[data-theme="dark"] [data-metric].selected, :root[data-theme="dark"] .metric-btn.selected{
  --metric-active: rgba(88,166,255,0.35);
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function(){
  try {
    document.querySelectorAll('[data-metric]').forEach(el=>{
      if (!el.classList.contains('metric-btn')) el.classList.add('metric-btn');
    });
  } catch(e){}
});
</script>

	

<!-- === STS: Shading Parity + Auto Slider C/D (injected 2025/10/21 12:00:00) === -->
<script>
(function(){
  // Timestamp util
  function pad(n){ return String(n).padStart(2,'0'); }
  function tsLabel(ms){
    var d = new Date(ms||Date.now());
    return d.getFullYear()+"/"+pad(d.getMonth()+1)+"/"+pad(d.getDate())+" "+pad(d.getHours())+":"+pad(d.getMinutes())+":"+pad(d.getSeconds());
  }

  // Tag a row's cells with data-col names using table's THEAD
  function tagCellsFromHeader(tr){
    try{
      var table = tr.closest('table'); if (!table) return;
      var ths = Array.from(table.querySelectorAll('thead th'));
      Array.from(tr.children).forEach(function(td, idx){
        var name = ths[idx] ? (ths[idx].textContent||"").trim() : "";
        if (name) td.setAttribute('data-col', name);
        // If numeric, store data-value for shading to use machine value
        var num = parseFloat((td.textContent||"").replace(/[^0-9\.\-]+/g,''));
        if (!Number.isNaN(num)) td.setAttribute('data-value', String(num));
      });
    }catch(e){}
  }

  // Shade last row of a given table id
  function shadeLastRow(tableId){
    try{
      var tbl = document.getElementById(tableId);
      if (!tbl) return;
      var rows = tbl.querySelectorAll('tbody tr');
      if (!rows || !rows.length) return;
      var tr = rows[rows.length-1];
      tagCellsFromHeader(tr);
      try { if (typeof applyRowShading === 'function') applyRowShading(tr); } catch(e){}
      try { if (typeof applyUiColumnVisibility === 'function') applyUiColumnVisibility(); } catch(e) {}
    }catch(e){}
  }
  window._stsShadeLastRow = shadeLastRow;

  // Wrap helpers: after append, tag & shade
  function wrapAppender(fnName, tableArgIndex){
    try{
      var orig = window[fnName];
      if (typeof orig !== 'function') return;
      if (orig._stsWrapped) return;
      window[fnName] = function(){
        var res = orig.apply(this, arguments);
        try {
          var tid = arguments[tableArgIndex];
          if (typeof tid === 'string') shadeLastRow(tid);
        } catch(e){}
        return res;
      };
      window[fnName]._stsWrapped = true;
    }catch(e){}
  }

  // Known appenders in this build
  wrapAppender('appendSummaryRowToTable', 0);
  wrapAppender('appendStatRowToTable', 0);
  wrapAppender('appendStatHourRowToTable', 0);
  wrapAppender('appendSignificantRow', 0);

  // Also post-process any existing rows in those tables on DOMContentLoaded
  document.addEventListener('DOMContentLoaded', function(){
    ['autoSummaryTable','summary5Table','summary15Table','summary60Table',
     'statAnalysisTable','statAnalysisHourTable','significant5mTable','doseReviewsTable'
    ].forEach(function(id){
      var tbl = document.getElementById(id);
      if (!tbl) return;
      Array.from(tbl.querySelectorAll('tbody tr')).forEach(function(tr){
        tagCellsFromHeader(tr);
        try { if (typeof applyRowShading === 'function') applyRowShading(tr); } catch(e){}
      });
    });
  });

  // ===== Auto Slider C / D =====
  // UI: add minimal modals if missing
  function ensureModal(id, title){
    var modal = document.getElementById(id);
    if (modal) return modal;
    modal = document.createElement('div');
    modal.id = id;
    Object.assign(modal.style, {display:'none', position:'fixed', top:'8%', left:'50%', transform:'translateX(-50%)',
      background:'#fff', color:'#000', padding:'16px', border:'2px solid #007aff', borderRadius:'8px',
      boxShadow:'0 4px 8px rgba(0,0,0,0.2)', zIndex:'10003', maxHeight:'80%', overflow:'auto', minWidth:'72%'});
    modal.innerHTML = ''
      + '<div class="as-toolbar">'
      +   '<button onclick="window._stsExportC()">Export CSV</button>'
      +   '<button onclick="window._stsClearC()">Clear</button>'
      +   '<button onclick="document.getElementById(\''+id+'\').style.display=\'none\'">Close</button>'
      + '</div>'
      + '<h3 style="margin:6px 0;">'+title+'</h3>'
      + '<table id="'+id.replace('Modal','Table')+'">'
      +   '<thead><tr><th>Time</th><th>Rush</th><th>Mood</th><th>Social</th><th>Energy</th><th>Focus</th><th>Anxiety</th><th>Impair</th><th>Score</th><th>Max</th><th>Min</th><th>Weighted</th><th>5Max</th></tr></thead>'
      +   '<tbody></tbody>'
      + '</table>';
    document.body.appendChild(modal);
    return modal;
  }

  // Snapshot core sums from main table
  function _snap(){
    var rows = Array.from(document.querySelectorAll('#logTable tbody tr'));
    return rows.map(function(tr){
      var ts = +(tr.getAttribute('data-ts')||0);
      function get(field){
        var td = tr.querySelector('td[data-field="'+field+'Sum"]');
        if(!td) return 0;
        var v = parseFloat(td.getAttribute('data-value')||td.textContent||'0');
        return Number.isFinite(v) ? v : 0;
      }
      return {_ts:ts,
        rush:get('rush'), mood:get('mood'), social:get('social'), energy:get('energy'),
        focus:get('focus'), anxiety:get('anxiety'), impair:get('impair')};
    }).filter(function(o){ return o._ts>0; });
  }

  // Compute parity composites (real Score/Max/Min + Weighted + 5Max)
  function _composites(M){
    var score = (M.rush+M.mood+M.social+M.energy+M.focus) - (M.anxiety+M.impair);
    var max   = (M.rush+M.mood+M.social+M.energy+M.focus);
    var min   = (M.anxiety+M.impair);
    var weighted = (typeof computeWeighted==='function') ? computeWeighted(M) : 0;
    var fiveMax  = (typeof computeFiveMax==='function') ? computeFiveMax(M) : ((score/5)+5);
    return {score:+score, max:+max, min:+min, weighted:+(+weighted), fiveMax:+(+fiveMax)};
  }

  function _fmt2(x){ var n=Number(x); return Number.isFinite(n)? n.toFixed(2):""; }

  function _appendTo(id, ms, means, comp){
    var tb = document.querySelector('#'+id+' tbody'); if (!tb) return;
    var tr = document.createElement('tr');
    function td(col, val){
      var c = document.createElement('td'); c.textContent = val; c.setAttribute('data-col', col);
      var num = parseFloat(val); if (!Number.isNaN(num)) c.setAttribute('data-value', String(num));
      return c;
    }
    tr.appendChild(td('Time', tsLabel(ms)));
    ['Rush','Mood','Social','Energy','Focus','Anxiety','Impair'].forEach(function(col){
      var lc = col.toLowerCase(); tr.appendChild(td(col, _fmt2(means[lc])));
    });
    tr.appendChild(td('Score', _fmt2(comp.score)));
    tr.appendChild(td('Max', _fmt2(comp.max)));
    tr.appendChild(td('Min', _fmt2(comp.min)));
    tr.appendChild(td('Weighted', _fmt2(comp.weighted)));
    tr.appendChild(td('5Max', _fmt2(comp.fiveMax)));
    try { if (typeof applyRowShading==='function') applyRowShading(tr); } catch(e){}
    try { if (typeof applyUiColumnVisibility==='function') applyUiColumnVisibility(); } catch(e){}
    tb.appendChild(tr);
  }

  // ===== Auto Slider C =====
  (function(){
    var LS_KEY = 'autoSliderC_rows';
    function load(){ try{ return JSON.parse(localStorage.getItem(LS_KEY)||'[]'); }catch(e){ return []; } }
    function save(rows){ try{ localStorage.setItem(LS_KEY, JSON.stringify(rows)); }catch(e){} }

    window.openAutoSliderC = function(){
      ensureModal('autoSliderCModal','Auto Slider C (windowRows mean)');
      var rows = load();
      var tb = document.querySelector('#autoSliderCTable tbody'); if (tb) { tb.innerHTML=''; rows.forEach(function(r){ _appendTo('autoSliderCTable', r.ms, r.means, r.comp); }); }
      document.getElementById('autoSliderCModal').style.display='block';
    };

    function computeAtTail(){
      var snap = _snap(); if (!snap.length) return null;
      var N = (window.CONFIG && CONFIG.popups && CONFIG.popups.autoSliderC && +CONFIG.popups.autoSliderC.windowRows) || 5;
      var start = Math.max(0, snap.length - N);
      var cnt = snap.length - start;
      var sums = {rush:0,mood:0,social:0,energy:0,focus:0,anxiety:0,impair:0};
      for (var j=start; j<snap.length; j++){
        var r = snap[j];
        sums.rush+=r.rush; sums.mood+=r.mood; sums.social+=r.social; sums.energy+=r.energy;
        sums.focus+=r.focus; sums.anxiety+=r.anxiety; sums.impair+=r.impair;
      }
      var means = {rush:sums.rush/cnt, mood:sums.mood/cnt, social:sums.social/cnt, energy:sums.energy/cnt,
                   focus:sums.focus/cnt, anxiety:sums.anxiety/cnt, impair:sums.impair/cnt};
      return { ms: snap[snap.length-1]._ts, means: means, comp: _composites(means), n: cnt };
    }

    // Hook addEntry to emit C row when Auto is ON (parity with B behaviour)
    try{
      var _origAdd = window.addEntry;
      if (typeof _origAdd === 'function') {
        window.addEntry = function(){
          var res = _origAdd.apply(this, arguments);
          try {
            if (window.autoSummaryActive){
              var row = computeAtTail();
              if (row){
                var rows = load(); rows.push(row); save(rows);
                ensureModal('autoSliderCModal','Auto Slider C (windowRows mean)');
                _appendTo('autoSliderCTable', row.ms, row.means, row.comp);
              }
            }
          } catch(e){}
          return res;
        };
      }
    }catch(e){}

    window._stsExportC = function(){
      var rows = load();
      var header = ["Time","Rush","Mood","Social","Energy","Focus","Anxiety","Impair","Score","Max","Min","Weighted","5Max","N"];
      var lines = [header.join(",")];
      rows.forEach(function(r){
        lines.push([tsLabel(r.ms), r.means.rush, r.means.mood, r.means.social, r.means.energy, r.means.focus, r.means.anxiety, r.means.impair,
                    r.comp.score, r.comp.max, r.comp.min, r.comp.weighted, r.comp.fiveMax, r.n]
                   .map(function(x){ var s=String(Number.isFinite(+x)?(+x).toFixed(2):x); return '"'+s.replace(/"/g,'""')+'"'; }).join(","));
      });
      var blob = new Blob([lines.join("\n")], {type:"text/csv"});
      var url = URL.createObjectURL(blob), a=document.createElement('a');
      a.href=url; a.download = "auto_slider_C.csv"; a.click(); URL.revokeObjectURL(url);
    };
    window._stsClearC = function(){
      save([]);
      var tb = document.querySelector('#autoSliderCTable tbody'); if (tb) tb.innerHTML='';
    };
  })();

  // ===== Auto Slider D =====
  (function(){
    var LS_KEY = 'autoSliderD_rows';
    function load(){ try{ return JSON.parse(localStorage.getItem(LS_KEY)||'[]'); }catch(e){ return []; } }
    function save(rows){ try{ localStorage.setItem(LS_KEY, JSON.stringify(rows)); }catch(e){} }

    window.openAutoSliderD = function(){
      ensureModal('autoSliderDModal','Auto Slider D (last N rows mean; real Score/Max/Min)');
      var rows = load();
      var tb = document.querySelector('#autoSliderDTable tbody'); if (tb) { tb.innerHTML=''; rows.forEach(function(r){ _appendTo('autoSliderDTable', r.ms, r.means, r.comp); }); }
      document.getElementById('autoSliderDModal').style.display='block';
    };

    function computeAtTail(){
      var snap = _snap(); if (!snap.length) return null;
      var N = (window.CONFIG && CONFIG.popups && CONFIG.popups.autoSliderD && +CONFIG.popups.autoSliderD.windowRows) || 2;
      var start = Math.max(0, snap.length - N);
      var cnt = snap.length - start;
      var sums = {rush:0,mood:0,social:0,energy:0,focus:0,anxiety:0,impair:0};
      for (var j=start; j<snap.length; j++){
        var r = snap[j];
        sums.rush+=r.rush; sums.mood+=r.mood; sums.social+=r.social; sums.energy+=r.energy;
        sums.focus+=r.focus; sums.anxiety+=r.anxiety; sums.impair+=r.impair;
      }
      var means = {rush:sums.rush/cnt, mood:sums.mood/cnt, social:sums.social/cnt, energy:sums.energy/cnt,
                   focus:sums.focus/cnt, anxiety:sums.anxiety/cnt, impair:sums.impair/cnt};
      return { ms: snap[snap.length-1]._ts, means: means, comp: _composites(means), n: cnt };
    }

    // Emit on 30 s aligned cadence when Auto is ON
    var timer = null;
    function kick(){
      try{
        var row = computeAtTail();
        if (row){
          var rows = load(); rows.push(row); save(rows);
          ensureModal('autoSliderDModal','Auto Slider D (last N rows mean; real Score/Max/Min)');
          _appendTo('autoSliderDTable', row.ms, row.means, row.comp);
        }
      }catch(e){}
    }
    function start(){
      if (timer) return;
      var interval = (window.CONFIG && CONFIG.popups && CONFIG.popups.autoSliderD && +CONFIG.popups.autoSliderD.intervalMs) || 30000;
      // align on interval
      var now = Date.now();
      var delay = interval - (now % interval);
      timer = setTimeout(function t(){ kick(); timer = setInterval(kick, interval); }, delay);
    }
    function stop(){
      if (timer && typeof timer==='number'){ clearTimeout(timer); }
      if (timer && typeof timer==='object'){ clearInterval(timer); }
      timer = null;
    }

    // Track autoSummaryActive
    var last = !!window.autoSummaryActive;
    setInterval(function(){
      var cur = !!window.autoSummaryActive;
      if (cur !== last){
        if (cur) start(); else stop();
        last = cur;
      }
    }, 1000);

    window._stsExportD = function(){
      var rows = load();
      var header = ["Time","Rush","Mood","Social","Energy","Focus","Anxiety","Impair","Score","Max","Min","Weighted","5Max","N"];
      var lines = [header.join(",")];
      rows.forEach(function(r){
        lines.push([tsLabel(r.ms), r.means.rush, r.means.mood, r.means.social, r.means.energy, r.means.focus, r.means.anxiety, r.means.impair,
                    r.comp.score, r.comp.max, r.comp.min, r.comp.weighted, r.comp.fiveMax, r.n]
                   .map(function(x){ var s=String(Number.isFinite(+x)?(+x).toFixed(2):x); return '"'+s.replace(/"/g,'""')+'"'; }).join(","));
      });
      var blob = new Blob([lines.join("\n")], {type:"text/csv"});
      var url = URL.createObjectURL(blob), a=document.createElement('a');
      a.href=url; a.download = "auto_slider_D.csv"; a.click(); URL.revokeObjectURL(url);
    };
    window._stsClearD = function(){
      save([]);
      var tb = document.querySelector('#autoSliderDTable tbody'); if (tb) tb.innerHTML='';
    };
  })();

  // Public for potential future hooks
  window._stsTagCellsFromHeader = tagCellsFromHeader;

})();

// ===== Unlocked Mode (Horizontal, Rapid baseline) =====
function openUnlockedMode(){
  try { buildUnlockedModeButtons(); } catch(e){ console.warn(e); }
  try { buildUnlockedYellowNotes(); } catch(e){ console.warn(e); }
  var m = document.getElementById('unlockedModeModal');
  if (m) m.style.display = 'block';
}
function closeUnlockedMode(){
  var m = document.getElementById('unlockedModeModal');
  if (m) m.style.display = 'none';
}

function buildUnlockedYellowNotes(){
  const grid = document.getElementById('unlockedYellowGrid');
  if (!grid) return;
  grid.innerHTML = '';
  try{
    const yellow = (CONFIG && CONFIG.notes && Array.isArray(CONFIG.notes.yellow)) ? CONFIG.notes.yellow : [];
    yellow.forEach(lbl => {
      const b = document.createElement('button');
b.classList.add('metric-btn');
      b.type = 'button';
      b.className = 'note-btn';
      b.textContent = lbl;
      b.setAttribute('data-category','yellow');
      b.addEventListener('click', () => {
        const ta = document.getElementById('notesInput');
        if (!ta) {
          console.warn('Unlocked Yellow Note click: #notesInput not found');
          return;
        }
        const toks = (ta.value || '').split(/\s+/).filter(Boolean);
        const i = toks.indexOf(lbl);
        if (i >= 0) {
          toks.splice(i, 1);
          b.classList.remove('selected-score');
        } else {
          toks.push(lbl);
          b.classList.add('selected-score');
        }
        ta.value = toks.join(' ');
      });

      grid.appendChild(b);
    });
  } catch(e){ console.warn(e); }
}

function buildUnlockedModeButtons(){
  const host = document.getElementById('unlockedModeButtons');
  if (!host) return;
  host.innerHTML = '';
  try {
    // We only include the 7 primary metrics horizontally
    const primary = ['rush','mood','social','energy','focus','anxiety','impair'];
    primary.forEach(metric => {
      const col = document.createElement('div');
      col.className = 'score-column';
      const t = document.createElement('strong');
      t.innerText = metric.charAt(0).toUpperCase() + metric.slice(1);
      col.appendChild(t);

      (getUnlockedValues(metric) || getMetricButtons(metric) || []).forEach(v => {
        const b = document.createElement('button');
        b.classList.add('metric-btn');

        let customLabel = '';
        if (v === -0.25 || v === -0.5 || v === -0.75) customLabel = '-';
        else if (v === 0.25 || v === 0.75) customLabel = '+';
        else if (v === 4.99) customLabel = 'Extreme';
        else customLabel = getMetricLabel(metric, v);

        b.innerText = String(v) + ': ' + (customLabel || '');
        b.addEventListener('click', () => {
          if (!Array.isArray(selections[metric])) selections[metric] = [];
          const i = selections[metric].indexOf(v);
          if (i < 0) {
            selections[metric].push(v);
            b.classList.add('selected-score');
          } else {
            selections[metric].splice(i, 1);
            b.classList.remove('selected-score');
          }
        });
        col.appendChild(b);
      });
      host.appendChild(col);
    });
  } catch (e) {
    console.warn(e);
  }
}

function applyUnlocked(){
  // No addEntry() call; selection persists; modal remains open
  // This mirrors Rapid "Apply" behaviour.
  return true;
}
function applyUnlockedAndAdd(){
  try { addEntry('main'); } catch(e){ console.warn(e); }
  // Reset yellow note button visual state to not-selected
  try {
    const grid = document.getElementById('unlockedYellowGrid');
    if (grid) Array.from(grid.querySelectorAll('.note-btn.selected-score')).forEach(btn => btn.classList.remove('selected-score'));
  } catch(e){ console.warn(e); }
  return true; // do not auto-close
}
function applyUnlockedAndAddStay(){
  try { addEntry('main'); } catch(e){ console.warn(e); }
  // Keep modal open, and reset yellow note selections visually
  try {
    const grid = document.getElementById('unlockedYellowGrid');
    if (grid) Array.from(grid.querySelectorAll('.note-btn.selected-score')).forEach(btn => btn.classList.remove('selected-score'));
  } catch(e){ console.warn(e); }
  return true;
}
// ===== /Unlocked Mode =====
</script>
<!-- === /STS inject === -->

 <!-- Fast Mode Modal -->
<div id="fastModeModal"
     style="display:none; position:fixed; top:15%; left:50%; transform:translateX(-50%);
            background:#fff; padding:20px; border:2px solid #007aff; border-radius:8px;
            box-shadow:0 4px 8px rgba(0,0,0,0.2); z-index:1000; max-width:min(96vw, 1400px);">
  <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px;">
    <div style="font-weight:700; font-size:18px;">Fast Mode</div>
    <button aria-label="Close" onclick="closeFastMode()">Close</button>
  </div>
  <div class="score-columns" id="fastModeButtons"></div>
  <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:12px;">
    <button onclick="applyFastMode()">Apply</button>
    <button onclick="applyFastModeAndAdd()">Apply &amp; Add Entry</button>
    <button onclick="applyFastModeAndAddStay()">Apply, Add &amp; Stay</button>
  </div>
</div>

<script id="fast-mode-logic">
(function(){
  // Per-metric values for Fast Mode
//   BOOKMARK FAST MODE LABELS AND VALUES
  const FAST_MODE_VALUES = {
    rush:    [6.00, 5.00, 4.00, 3.00, 2.00, 1.00, 0.00, '---------------', 0.50,-0.50],
    mood:    [6.00, 5.00, 4.00, 3.00, 2.00, 1.00, 0.00, '---------------', 0.50,-0.50],
    social:  [6.00, 5.00, 4.00, 3.00, 2.00, 1.00, 0.00, '---------------', 0.50,-0.50],
    energy:  [6.00, 5.00, 4.00, 3.00, 2.00, 1.00, 0.00, '---------------', 0.50,-0.50],
    focus:   [6.00, 5.00, 4.00, 3.00, 2.00, 1.00, 0.00, '---------------', 0.50,-0.50],
    anxiety: [6.00, 5.00, 4.00, 3.00, 2.00, 1.00, 0.00, '---------------', 0.50,-0.50],
    impair:  [6.00, 5.00, 4.00, 3.00, 2.00, 1.00, 0.00, '---------------', 0.50,-0.50],
    __default: [6,5,4,3,2,1,0,'---------------',0.5,-0.5]
  };


  // Unlocked Mode-specific values (independent of main per-metric buttons)
  const UNLOCKED_MODE_VALUES = {
    rush:    [6.00, 5.00, 4.50, 4.00, 3.50, 3.00, 2.50, 2.00, 1.50, 1.00, 0.75, 0.50, 0.25, 0.00],
    mood:    [6.00, 5.00, 4.50, 4.00, 3.50, 3.00, 2.50, 2.00, 1.50, 1.00, 0.75, 0.50, 0.25, 0.00],
    social:  [6.00, 5.00, 4.50, 4.00, 3.50, 3.00, 2.50, 2.00, 1.50, 1.00, 0.75, 0.50, 0.25, 0.00],
    energy:  [6.00, 5.00, 4.50, 4.00, 3.50, 3.00, 2.50, 2.00, 1.50, 1.00, 0.75, 0.50, 0.25, 0.00],
    focus:   [6.00, 5.00, 4.50, 4.00, 3.50, 3.00, 2.50, 2.00, 1.50, 1.00, 0.75, 0.50, 0.25, 0.00],
    anxiety: [6.00, 5.00, 4.50, 4.00, 3.50, 3.00, 2.50, 2.00, 1.50, 1.00, 0.75, 0.50, 0.25, 0.00],
    impair:  [6.00, 5.00, 4.50, 4.00, 3.50, 3.00, 2.50, 2.00, 1.50, 1.00, 0.75, 0.50, 0.25, 0.00],
    __default: [6,5,4,3,2,1,0]
  };

  function getUnlockedValues(metric){
    const key = String(metric || '').toLowerCase();
    if (UNLOCKED_MODE_VALUES[key] && Array.isArray(UNLOCKED_MODE_VALUES[key])) {
      return UNLOCKED_MODE_VALUES[key];
    }
    return UNLOCKED_MODE_VALUES.__default;
  }

  // Fast Mode-specific labels used on buttons and written into the table
  const FAST_MODE_LABELS = {
  rush: { 6.00: 'Overwhelming', 5.00: 'Extreme', 4.00: 'Intense + Uncontrol', 3.00: 'Energetic + Physical', 2.00: 'Mental + Contained', 1.00: 'Some / Mild', 0.00: 'No Rush', 0.50: '+' },
  mood: { 6.00: 'Autopilot', 5.00: 'Euphoria', 4.00: 'Obvious', 3.00: 'Clear + Good', 2.00: 'Distinct + Definite', 1.00: 'Required Thought', 0.00: 'No/Avoidant', 0.50: '+' },
  social: { 6.00: 'Disinhibited', 5.00: 'Empathy/Love', 4.00: 'Outgoing/Great', 3.00: 'Flow/Natural', 2.00: 'Push/Motivated', 1.00: 'Want/Urge/Aroused', 0.00: 'No/Avoidant', 0.50: '+' },
  energy: { 6.00: 'Hyper', 5.00: 'Manic', 4.00: 'Strong Physical', 3.00: 'Energetic/Push', 2.00: 'Noticeable', 1.00: 'Some', 0.00: 'None', 0.50: '+' },
  focus: { 6.00: 'Wired', 5.00: 'Laser', 4.00: 'Strong/Obsessive', 3.00: 'Engaged', 2.00: 'Focused', 1.00: 'Some', 0.00: 'None', 0.50: '+' },
  anxiety: { 6.00: 'Physical Terror', 5.00: 'Panic, Visceral, Fear', 4.00: 'Impact Behaviour', 3.00: 'Affecting, Adverse', 2.00: 'Ignorable', 1.00: 'Low/Negligible', 0.00: 'None', 0.50: '+' },
  impair: { 6.00: 'Dangerous', 5.00: 'Crippled', 4.00: 'Major Adverse', 3.00: 'Hinderance, Affecting', 2.00: 'Can Compensate', 1.00: 'Minor, Side Effects', 0.00: 'None', 0.50: '+' },
  };

  const FAST_MODE_METRICS = ['rush','mood','social','energy','focus','anxiety','impair'];

  const fastModeSelections = Object.create(null);

  function getValuesForMetric(metric){
    const v = FAST_MODE_VALUES[metric];
    return Array.isArray(v) ? v : (FAST_MODE_VALUES.__default || [6,5,4,3,2,1,0,'---------------',0.5,-0.5]);
    }

  function getFastModeLabel(metric, value){
    try{
      const keyNum = Number(value);
      const key = Number.isFinite(keyNum) ? keyNum.toFixed(2) : String(value);
      const fm = FAST_MODE_LABELS[metric];
      if (fm) {
        if (fm[key] != null) return String(fm[key]);
        if (fm[keyNum] != null) return String(fm[keyNum]);
      }
      // optional fallback to CONFIG if present
      const cfg = (window.CONFIG && window.CONFIG.labels) || {};
      const R = (cfg.rapidLabels && cfg.rapidLabels[metric] && cfg.rapidLabels[metric][key]) || '';
      if (R) return R;
      const L = (cfg.labelMappings && cfg.labelMappings[metric] && cfg.labelMappings[metric][key]) || '';
      return L || '';
    }catch(e){}
    return '';
  }

  function sortNumericDescStable(a,b){
    const an = (typeof a === 'number') ? a : Number(a);
    const bn = (typeof b === 'number') ? b : Number(b);
    const aNum = Number.isFinite(an), bNum = Number.isFinite(bn);
    if (aNum && bNum) return bn - an;
    if (aNum && !bNum) return -1;
    if (!aNum && bNum) return 1;
    return String(b).localeCompare(String(a));
  }

  // UI build
  window.buildFastModeButtons = function(){
    try{
      const container = document.getElementById('fastModeButtons');
      if (!container) return;
      container.innerHTML = '';
      FAST_MODE_METRICS.forEach(metric=>{
        const col = document.createElement('div');
        col.className = 'score-column';
        const t = document.createElement('strong');
        t.innerText = metric.charAt(0).toUpperCase() + metric.slice(1);
        col.appendChild(t);
        getValuesForMetric(metric).forEach(v=>{
          if (v === ''){ const sep = document.createElement('div'); sep.style.height='6px'; col.appendChild(sep); return; }
          const b = document.createElement('button');
          b.classList.add('metric-btn');
          const label = getFastModeLabel(metric, v);
          b.innerText = label ? `${v}: ${label}` : String(v);
          b.onclick = ()=>{
            if (!Array.isArray(fastModeSelections[metric])) fastModeSelections[metric] = [];
            const i = fastModeSelections[metric].indexOf(v);
            if (i < 0){ fastModeSelections[metric].push(v); b.classList.add('selected-score'); }
            else { fastModeSelections[metric].splice(i,1); b.classList.remove('selected-score'); }
          };
          if (Array.isArray(fastModeSelections[metric]) && fastModeSelections[metric].includes(v)){
            b.classList.add('selected-score');
          }
          col.appendChild(b);
        });
        container.appendChild(col);
      });
    }catch(e){ console.warn(e); }
  };

  // Open/close
  window.openFastMode = function(){
    try{
      buildFastModeButtons();
      const m = document.getElementById('fastModeModal');
      if (!m) return;
      if (m.parentElement !== document.body) document.body.appendChild(m);
      m.style.zIndex = '10000';
      m.style.display = 'block';
    }catch(e){ console.warn(e); }
  };
  window.closeFastMode = function(){
    try{ const m = document.getElementById('fastModeModal'); if (m) m.style.display = 'none'; }catch(e){}
  };

  function normalizeFastModeSelections(){
    try{
      FAST_MODE_METRICS.forEach(f=>{
        if (!Array.isArray(fastModeSelections[f])) fastModeSelections[f] = [];
        fastModeSelections[f] = Array.from(new Set(fastModeSelections[f])).sort(sortNumericDescStable);
      });
    }catch(e){}
  }

  // Apply into global 'selections' buffer only
  window.applyFastMode = function(){
    try{
      normalizeFastModeSelections();
      if (typeof selections === 'object' && selections){
        FAST_MODE_METRICS.forEach(f=>{ selections[f] = fastModeSelections[f] ? fastModeSelections[f].slice() : []; });
      }
      closeFastMode();
      try { if (typeof buildButtons==='function') buildButtons(); } catch(e){}
    }catch(e){ console.warn(e); }
  };

  // Stamp labels/values into the last-added entry and refresh table
  function finalizeFastEntryAsFastMode(){
    try{
      if (!Array.isArray(logData) || !logData.length) return;
      const entry = logData[logData.length - 1];
      entry.inputSource = 'FastMode';
      entry.fastMode = true;

      FAST_MODE_METRICS.forEach(metric=>{
        try{
          const chosen = Array.isArray(fastModeSelections[metric]) ? fastModeSelections[metric].slice() : [];
          entry[metric] = chosen;
          const labels = [];
          Array.from(new Set(chosen)).sort(sortNumericDescStable).forEach(v=>{
            const L = getFastModeLabel(metric, v);
            if (L) labels.push(L);
          });
          entry[metric + 'Label'] = labels.join(', ');
        }catch(e){}
      });

      try { if (typeof setTripLogDebounced==='function') setTripLogDebounced(logData); } catch(e){}
      try { if (typeof renderTable==='function') renderTable(); } catch(e){}
    }catch(e){ console.warn(e); }
  }

  window.applyFastModeAndAdd = function(){
    try{
      applyFastMode();
      window._rapidLabelMode = false;
      window._rapidInputSource = 'FastMode';
      if (typeof addEntry === 'function') addEntry('fastMode');
      finalizeFastEntryAsFastMode();
      window.clearFastModeSelections();
      window._rapidInputSource = 'Main';
    }catch(e){ console.warn(e); }
  };

  window.applyFastModeAndAddStay = function(){
    try{
      normalizeFastModeSelections();
      if (typeof selections === 'object' && selections){
        FAST_MODE_METRICS.forEach(f=>{ selections[f] = fastModeSelections[f] ? fastModeSelections[f].slice() : []; });
      }
      window._rapidInputSource = 'FastMode';
      if (typeof addEntry === 'function') addEntry('fastMode');
      finalizeFastEntryAsFastMode();
      window.clearFastModeSelections();
      window._rapidInputSource = 'Main';
      try{ buildFastModeButtons(); }catch(e){}
      try{ const m=document.getElementById('fastModeModal'); if (m) m.style.display='block'; }catch(e){}
    }catch(e){ console.warn(e); }
  };

  window.clearFastModeSelections = function(){
    try{
      Object.keys(fastModeSelections).forEach(k => { fastModeSelections[k] = []; });
      try{
        if (typeof selections === 'object' && selections){
          FAST_MODE_METRICS.forEach(f=>{ selections[f] = []; });
        }
      }catch(e){}
      const modal = document.getElementById('fastModeModal');
      if (modal && modal.style.display !== 'none'){
        const btns = modal.querySelectorAll('.score-column button.selected-score');
        btns.forEach(b => b.classList.remove('selected-score'));
      }
    }catch(e){ console.warn(e); }
  };
})();
</script> 

<!-- Rapid Scores 2 Patch (injected) - 2025/10/26 17:10:09 -->
<script>
(() => {
  'use strict';
  // ===== Config defaults for Rapid 2 (mirror Rapid 1 unless explicitly set) BOOKMARK =====
  if (!window.CONFIG) window.CONFIG = {};
  if (!CONFIG.buttons) CONFIG.buttons = {};

  const mirrorValues = (CONFIG.buttons.rapidValues && Array.isArray(CONFIG.buttons.rapidValues))
    ? CONFIG.buttons.rapidValues.slice()
    : [6,5,4.5,4,3.5,3,2.5,2,1.5,1,0.5,0,'',0.25,-0.25];

  const mirrorMetrics = (CONFIG.buttons.rapidMetrics && Array.isArray(CONFIG.buttons.rapidMetrics))
    ? CONFIG.buttons.rapidMetrics.slice()
    : ['rush','mood','social','energy','focus','anxiety','impair'];

  if (!Array.isArray(CONFIG.buttons.rapid2Values))  CONFIG.buttons.rapid2Values  = mirrorValues;
  if (!Array.isArray(CONFIG.buttons.rapid2Metrics)) CONFIG.buttons.rapid2Metrics = mirrorMetrics;

  const RAPID2_VALUES  = CONFIG.buttons.rapid2Values;
  const RAPID2_METRICS = CONFIG.buttons.rapid2Metrics;
  const RAPID2_LABELS  = CONFIG.buttons.rapid2LabelMap || null;

  // ===== State =====
  const selections2 = {};

  function labelForRapid2Value(v){
    if (RAPID2_LABELS && Object.prototype.hasOwnProperty.call(RAPID2_LABELS, String(v))) {
      return String(RAPID2_LABELS[String(v)]);
    }
    return (v === '' ? '' : String(v));
  }

  // ===== Modal creation =====
  function ensureRapid2Modal(){
    if (document.getElementById('rapid2ScoresModal')) return;
    const modal = document.createElement('div');
    modal.id = 'rapid2ScoresModal';
    Object.assign(modal.style, {
      display: 'none',
      position: 'fixed',
      top: '10%',
      left: '50%',
      transform: 'translateX(-50%)',
      width: 'min(1100px, 96vw)',
      maxHeight: '82vh',
      overflow: 'auto',
      background: '#fff',
      padding: '12px',
      borderRadius: '8px',
      boxShadow: '0 4px 8px rgba(0,0,0,0.2)',
      zIndex: '1000'
    });

    const header = document.createElement('div');
    Object.assign(header.style, {
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'space-between',
      gap: '8px',
      marginBottom: '10px'
    });

    const title = document.createElement('div');
    title.textContent = 'Rapid Scores 2';
    Object.assign(title.style, { fontWeight: '700', fontSize: '18px' });

    const closeBtn = document.createElement('button');
closeBtn.classList.add('metric-btn');
    closeBtn.type = 'button';
    closeBtn.setAttribute('aria-label', 'Close');
    closeBtn.textContent = 'Close';
    closeBtn.addEventListener('click', closeRapidScores2);

    header.appendChild(title);
    header.appendChild(closeBtn);

    const gridHost = document.createElement('div');
    gridHost.id = 'rapid2ScoresButtons';
    gridHost.className = 'score-columns';

    const controls = document.createElement('div');
    Object.assign(controls.style, {
      display: 'flex',
      gap: '8px',
      justifyContent: 'flex-end',
      marginTop: '10px'
    });

    const btnApply = document.createElement('button');
btnApply.classList.add('metric-btn');
    btnApply.type = 'button';
    btnApply.textContent = 'Apply';
    btnApply.addEventListener('click', applyRapid2Scores);

    const btnApplyAdd = document.createElement('button');
btnApplyAdd.classList.add('metric-btn');
    btnApplyAdd.type = 'button';
    btnApplyAdd.innerHTML = 'Apply &amp; Add Entry';
    btnApplyAdd.addEventListener('click', applyRapid2ScoresAndAdd);

    const btnApplyAddStay = document.createElement('button');
btnApplyAddStay.classList.add('metric-btn');
    btnApplyAddStay.type = 'button';
    btnApplyAddStay.innerHTML = 'Apply &amp; Add &amp; Stay';
    btnApplyAddStay.addEventListener('click', applyRapid2ScoresAndAddStay);

    controls.appendChild(btnApply);
    controls.appendChild(btnApplyAdd);
    controls.appendChild(btnApplyAddStay);

    modal.appendChild(header);
    modal.appendChild(gridHost);
    modal.appendChild(controls);

    document.body.appendChild(modal);
  }

  function buildRapid2ScoresButtons(){
    ensureRapid2Modal();
    const host = document.getElementById('rapid2ScoresButtons');
    if (!host) return;

    host.innerHTML = '';
    host.style.display = 'grid';
    host.style.gridTemplateColumns = `repeat(${RAPID2_METRICS.length}, minmax(140px, 1fr))`;
    host.style.gap = '8px';

    RAPID2_METRICS.forEach((field) => {
      const col = document.createElement('div');
      Object.assign(col.style, {
        display: 'flex',
        flexDirection: 'column',
        gap: '8px'
      });

      const header = document.createElement('div');
      header.textContent = field;
      Object.assign(header.style, {
        fontWeight: '700',
        textAlign: 'center'
      });
      col.appendChild(header);

      const grid = document.createElement('div');
      Object.assign(grid.style, {
        display: 'grid',
        gridTemplateColumns: 'repeat(5, minmax(0,1fr))',
        gap: '6px'
      });
      if (!Array.isArray(selections2[field])) selections2[field] = [];

      RAPID2_VALUES.forEach((val) => {
        if (val === '') {
          const spacer = document.createElement('div');
          spacer.style.height = '8px';
          grid.appendChild(spacer);
          return;
        }
        const btn = document.createElement('button');
btn.classList.add('metric-btn');
        btn.type = 'button';
        btn.textContent = labelForRapid2Value(val);
        btn.dataset.metric = field;
        btn.dataset.value = String(val);
        Object.assign(btn.style, {
          padding: '6px 8px',
          borderRadius: '6px',
          border: '1px solid #ccc',
          fontSize: '13px',
          cursor: 'pointer'
        });

        const applySelectedStyle = (on) => {
          btn.style.background = on ? '#eef6ff' : '';
          btn.style.borderColor = on ? '#4495ff' : '#ccc';
          btn.style.fontWeight = on ? '700' : '400';
        };
        applySelectedStyle(selections2[field].includes(val));

        btn.addEventListener('click', () => {
          const arr = selections2[field] || [];
          const i = arr.findIndex(x => x === val);
          if (i === -1) arr.push(val); else arr.splice(i, 1);
          selections2[field] = Array.from(new Set(arr)).sort((a,b)=> (b||0) - (a||0));
          applySelectedStyle(i === -1);
        });

        grid.appendChild(btn);
      });

      col.appendChild(grid);
      host.appendChild(col);
    });
  }

  function openRapidScores2(){
    buildRapid2ScoresButtons();
    ensureRapid2Modal();
    const m = document.getElementById('rapid2ScoresModal');
    if (m) m.style.display = 'block';
  }

  function closeRapidScores2(){
    const m = document.getElementById('rapid2ScoresModal');
    if (m) m.style.display = 'none';
  }

  function writeRapid2SelectionsToInputs(){
    RAPID2_METRICS.forEach((field) => {
      const arr = Array.isArray(selections2[field]) ? selections2[field] : [];
      if (!arr.length) return;
      const chosen = arr.slice().sort((a,b)=> (b||0)-(a||0))[0];
      const input = document.querySelector(`[name="${field}"]`) || document.getElementById(field) || null;
      if (input) {
        input.value = String(chosen);
        input.dispatchEvent(new Event('input', { bubbles: true }));
        input.dispatchEvent(new Event('change', { bubbles: true }));
      }
    });
  }

  function finalizeRapidEntryAsRapid2(){
    try {
      const src = document.querySelector('[name="inputSource"]');
      if (src) {
        src.value = 'Rapid2';
        src.dispatchEvent(new Event('change', { bubbles: true }));
      }
    } catch {}
  }

  function applyRapid2Scores(){
    try {
      writeRapid2SelectionsToInputs();
      closeRapidScores2();
    } catch (e) {
      console.error('[Rapid2] apply error', e);
    }
  }

  function applyRapid2ScoresAndAdd(){
    try {
      writeRapid2SelectionsToInputs();
      finalizeRapidEntryAsRapid2();
      if (typeof window.addEntry === 'function') {
        window.addEntry();
      }
      closeRapidScores2();
    } catch (e) {
      console.error('[Rapid2] apply+add error', e);
    }
  }

  function applyRapid2ScoresAndAddStay(){
    try {
      writeRapid2SelectionsToInputs();
      finalizeRapidEntryAsRapid2();
      if (typeof window.addEntry === 'function') {
        window.addEntry();
      }
      // stay open
    } catch (e) {
      console.error('[Rapid2] apply+add+stay error', e);
    }
  }

  // Expose globals
  window.openRapidScores2 = openRapidScores2;
  window.closeRapidScores2 = closeRapidScores2;
  window.applyRapid2Scores = applyRapid2Scores;
  window.applyRapid2ScoresAndAdd = applyRapid2ScoresAndAdd;
  window.applyRapid2ScoresAndAddStay = applyRapid2ScoresAndAddStay;

  // ===== Insert launcher button next to existing Rapid Scores button =====
  function insertRapid2Launcher(){
    // Heuristic: prefer a button that calls openRapidScores(), otherwise a button whose text matches /Rapid\s*Scores/i
    let anchorBtn = Array.from(document.querySelectorAll('button, a')).find(el => {
      const oc = (el.getAttribute('onclick') || '').toLowerCase();
      return oc.includes('openrapidscores');
    });
    if (!anchorBtn) {
      anchorBtn = Array.from(document.querySelectorAll('button, a')).find(el => /\brapid\s*scores\b/i.test(el.textContent || ''));
    }
    const newBtn = document.createElement(anchorBtn ? anchorBtn.tagName.toLowerCase() : 'button');
    newBtn.type = 'button';
    newBtn.id = 'rapid2Btn';
    newBtn.textContent = 'Rapid 2';
    newBtn.addEventListener('click', openRapidScores2);

    // Style the new button to be visually consistent if the anchor has classes
    if (anchorBtn && anchorBtn.className) newBtn.className = anchorBtn.className;

    // Place it after the anchor button, or append to a sensible container
    if (anchorBtn && anchorBtn.parentElement) {
      anchorBtn.parentElement.insertBefore(newBtn, anchorBtn.nextSibling);
    } else {
      // Fallback: add to a common toolbar container if present, else add to body top
      const toolbar = document.querySelector('#toolbar, .toolbar, header, .controls');
      if (toolbar) toolbar.appendChild(newBtn);
      else document.body.insertBefore(newBtn, document.body.firstChild);
    }
  }

  document.addEventListener('DOMContentLoaded', insertRapid2Launcher);
})();
</script>


<script>
(() => {
  'use strict';
  function requireFunctions(fnNames) {
    const missing = fnNames.filter(n => typeof window[n] !== 'function');
    if (missing.length) {
      const msg = `[Init] Missing required functions: ${missing.join(', ')}`;
      console.error(msg);
      if (!window.__shownMissingFns) { window.__shownMissingFns = true; try { alert(msg); } catch {} }
      return false;
    }
    return true;
  }
  window.requireFunctions = requireFunctions;
})();
</script>



<script>
(() => {
  'use strict';
  function __parseAULocalTimestamp(text) {
    const r = /^\s*(\d{1,2})[\/-](\d{1,2})[\/-](\d{4})\s+(\d{1,2}):(\d{2})(?::(\d{2}))?\s*$/;
    const m = r.exec(text);
    if (!m) return null;
    const dd = +m[1], MM = +m[2]-1, yyyy = +m[3], hh = +m[4], mm = +m[5], ss = m[6] ? +m[6] : 0;
    const d = new Date(yyyy, MM, dd, hh, mm, ss);
    return isNaN(d.getTime()) ? null : d;
  }
  function __findHeaderIndexes(tableEl) {
    const header = tableEl?.querySelector('thead tr');
    const names = Array.from(header ? header.children : []).map(th => th.textContent.trim());
    const idx = {};
    const candidates = (window.CONFIG?.backfill?.timestampHeaderNames || []);
    for (const wanted of candidates) {
      const i = names.findIndex(n => n.toLowerCase() === wanted.toLowerCase());
      if (i >= 0) { idx.timestamp = i; break; }
    }
    return idx;
  }
  function* __iterDataRows(tableEl) {
    const body = tableEl?.querySelector('tbody');
    if (!body) return;
    for (const tr of Array.from(body.children)) yield tr;
  }
  window.__parseAULocalTimestamp = __parseAULocalTimestamp;
  window.__findHeaderIndexes = __findHeaderIndexes;
  window.__iterDataRows = __iterDataRows;
})();
</script>



<script>
(() => {
  'use strict';
  // If a canonical function exists, export once, else keep existing user-defined function
  if (typeof window.backfillAllCanonical === 'function') {
    if (!window.backfillAll) window.backfillAll = window.backfillAllCanonical;
  }
  function bindBackfillButtonOnce() {
    const btn = document.querySelector('#backfillAllBtn');
    if (!btn) return;
    const clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);
    clone.addEventListener('click', () => window.backfillAll && window.backfillAll());
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bindBackfillButtonOnce, { once: true });
  } else {
    bindBackfillButtonOnce();
  }
})();
</script>

<script>
(() => {
  'use strict';
  function applyModeButtonSizeTo(modalEl, modeKey) {
    const base = (window.CONFIG && window.CONFIG.ui && window.CONFIG.ui.metricButton) || {};
    const per = (window.CONFIG && window.CONFIG.ui && window.CONFIG.ui.perModeButtonSizes && window.CONFIG.ui.perModeButtonSizes[modeKey]) || {};
    const s = Object.assign({}, base, per);
    if (!modalEl) return;
    modalEl.style.setProperty('--metric-btn-min-w', (s.minWidthPx ?? 64) + 'px');
    modalEl.style.setProperty('--metric-btn-min-h', (s.minHeightPx ?? 30) + 'px');
    modalEl.style.setProperty('--metric-btn-pad-b', (s.paddingBlockPx ?? 6) + 'px');
    modalEl.style.setProperty('--metric-btn-pad-i', (s.paddingInlinePx ?? 10) + 'px');
    modalEl.style.setProperty('--metric-btn-font', (s.fontSizeRem ?? 0.95) + 'rem');
    modalEl.style.setProperty('--metric-btn-gap', (s.gapPx ?? 6) + 'px');
  }
  function initPerModeSizing() {
    const ids = [
      ['rush','rushModeModal'],
      ['rapid','rapidScoresModal'],
      ['fast','fastModeModal'],
      ['unlocked','unlockedModeModal']
    ];
    ids.forEach(([mode,id]) => {
      const el = document.getElementById(id);
      if (el) applyModeButtonSizeTo(el, mode);
    });
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initPerModeSizing, { once: true });
  } else {
    initPerModeSizing();
  }
  window.applyModeButtonSizeTo = applyModeButtonSizeTo;
})();
</script>

<!-- Backfill Control (2025/11/01 13:25:00) -->
<button id="backfillControlBtn" type="button">Backfill All (5/15/60)</button>
<script>
(() => {
  'use strict';
  const CFG = {
    windowsMin: [5, 15, 60],
    mainTableSelector: '#logTable',
    summaryTableByMin: { 5:'#summary5Table', 15:'#summary15Table', 60:'#summary60Table' },
    tsHeaderNames: (window.CONFIG?.backfill?.timestampHeaderNames) || [
      'Timestamp','Timestamp (Local)','Time','Local Time','Date/Time','Logged At'
    ]
  };
  function parseLocalAU(tsText, tdEl) {
  const epoch = tdEl?.getAttribute?.('data-epoch') || tdEl?.dataset?.epoch;
  if (epoch && !Number.isNaN(Number(epoch))) {
    const d = new Date(Number(epoch));
    return isNaN(d) ? null : d;
  }
  const raw = (tsText || '').trim();

  // AU: DD/MM/YYYY [HH[:MM[:SS]]]
  let m = raw.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:\s+(\d{1,2})(?::(\d{2})(?::(\d{2}))?)?)?$/);
  if (m) {
    const d  = Number(m[1]);
    const mo = Number(m[2]);
    const y  = Number(m[3]);
    const hh = Number(m[4] ?? 0);
    const mm = Number(m[5] ?? 0);
    const ss = Number(m[6] ?? 0);
    const dt = new Date(y, mo - 1, d, hh, mm, ss);
    return isNaN(dt) ? null : dt;
  }

  // ISO-ish: YYYY/MM/DD [HH[:MM[:SS]]]
  m = raw.match(/^(\d{4})\/(\d{1,2})\/(\d{1,2})(?:\s+(\d{1,2})(?::(\d{2})(?::(\d{2}))?)?)?$/);
  if (m) {
    const y  = Number(m[1]);
    const mo = Number(m[2]);
    const d  = Number(m[3]);
    const hh = Number(m[4] ?? 0);
    const mm = Number(m[5] ?? 0);
    const ss = Number(m[6] ?? 0);
    const dt = new Date(y, mo - 1, d, hh, mm, ss);
    return isNaN(dt) ? null : dt;
  }

  const normalised = raw.replace(/-/g,'/').replace('T',' ').replace(/\.[0-9]+Z?$/,'');
  const dt = new Date(normalised);
  return isNaN(dt) ? null : dt;
}
    const s = (tsText||'').trim()
      .replace(/-/g,'/')
      .replace(/T/,' ')
      .replace(/\.[0-9]+Z?$/,'');
    const d = new Date(s);
    return isNaN(d) ? null : d;
  }
  function snapshotFromMainTable() {
  const table = document.querySelector(CFG.mainTableSelector);
  if (!table) return [];

  const thead = table.tHead || table.querySelector('thead');
  const tbody = table.tBodies?.[0] || table.querySelector('tbody');

  let headers = [];
  if (thead) {
    headers = Array.from(thead.querySelectorAll('th')).map(th => th.textContent.trim());
  } else {
    const firstRow = table.querySelector('tr');
    if (firstRow) headers = Array.from(firstRow.cells).map(td => td.textContent.trim());
  }
  if (!headers.length) return [];

  const tsIdx = (() => {
    const wanted = (window.CONFIG?.backfill?.timestampHeaderNames) || CFG.tsHeaderNames;
    const idxExact = headers.findIndex(h => wanted.some(n => h.toLowerCase() === n.toLowerCase()));
    if (idxExact >= 0) return idxExact;
    const idxContains = headers.findIndex(h => /time|timestamp/i.test(h));
    return idxContains;
  })();
  if (tsIdx < 0) return [];

  const rowEls = tbody ? Array.from(tbody.rows)
                       : Array.from(table.querySelectorAll('tr')).slice(1);
  const rows = [];
  for (const tr of rowEls) {
    if (tr.classList?.contains('backfill-summary-row')) continue;
    const tds = Array.from(tr.cells);
    if (tds.length <= tsIdx) continue;
    const cells = tds.map(td => td.textContent.trim());
    const ts = parseLocalAU(cells[tsIdx], tds[tsIdx]);
    if (ts) rows.push({_ts: ts.getTime(), tr, cells});
  }
  rows.sort((a,b)=>a._ts-b._ts);

  if (!rows.length) {
    console.warn('[Backfill] Snapshot empty. Headers=', headers, 'tsIdx=', tsIdx, 'rowCount=', rowEls.length);
  }
  return rows;
}
    rows.sort((a,b)=>a._ts-b._ts);
    return rows;
  }
  function computeRollingMeans(snapshot, endMs, windowMin) {
    if (!snapshot.length) return null;
    const startMs = endMs - windowMin*60*1000;
    const inRange = snapshot.filter(r => r._ts > startMs && r._ts <= endMs);
    if (!inRange.length) return null;
    const colCount = inRange[0].cells.length;
    const sums = new Array(colCount).fill(0);
    const counts = new Array(colCount).fill(0);
    for (const r of inRange) {
      r.cells.forEach((txt,i)=>{
        const v = Number((txt||'').replace(/[^0-9.+-]/g,''));
        if (!Number.isNaN(v)) { sums[i]+=v; counts[i]++; }
      });
    }
    const means = sums.map((s,i)=> counts[i] ? s/counts[i] : null);
    return {n: inRange.length, means, endMs, windowMin};
  }
  function insertSummaryRow(result) {
    const sel = CFG.summaryTableByMin[result.windowMin];
    const table = document.querySelector(sel);
    if (!table) return false;
    const tbody = table.tBodies[0] || table.querySelector('tbody') || table.appendChild(document.createElement('tbody'));
    const label = new Date(result.endMs).toLocaleString();
    const existing = Array.from(tbody.rows).find(tr => tr.dataset.label === label && tr.dataset.windowMin === String(result.windowMin));
    if (existing) return true;
    const tr = document.createElement('tr');
    tr.dataset.label = label;
    tr.dataset.windowMin = String(result.windowMin);
    const tdTime = document.createElement('td');  tdTime.textContent = label;
    const tdWin  = document.createElement('td');  tdWin.textContent  = result.windowMin + ' min';
    const tdN    = document.createElement('td');  tdN.textContent    = String(result.n);
    const tdM    = document.createElement('td');  tdM.textContent    = JSON.stringify(result.means);
    tr.appendChild(tdTime); tr.appendChild(tdWin); tr.appendChild(tdN); tr.appendChild(tdM);
    tbody.appendChild(tr);
    return true;
  }
  function backfillAllWindows() {
    const snapshot = snapshotFromMainTable();
    if (!snapshot.length) { console.warn('[Backfill] No rows found.'); return {ok:false, reason:'no_rows'}; }
    const firstMs = snapshot[0]._ts;
    const nowMs   = Date.now();
    let inserted = 0;
    for (const w of (window.CONFIG?.backfill?.windowsMin || CFG.windowsMin)) {
      const stepMs = w*60*1000;
      let t = Math.ceil(firstMs/stepMs)*stepMs;
      for (; t <= nowMs; t += stepMs) {
        const res = computeRollingMeans(snapshot, t, w);
        if (res && insertSummaryRow(res)) inserted++;
      }
    }
    console.log(`[Backfill] Inserted ${inserted} summary rows.`);
    return {ok:true, inserted};
  }
  function bindButton() {
    const btn = document.querySelector('#backfillControlBtn');
    if (!btn) { console.warn('[Backfill] Control button not found.'); return; }
    const fresh = btn.cloneNode(true);
    btn.replaceWith(fresh);
    fresh.addEventListener('click', () => {
      const rv = backfillAllWindows();
      fresh.textContent = rv.ok ? `Backfilled (${rv.inserted})` : 'Backfill: No data';
      setTimeout(()=>{ fresh.textContent = 'Backfill All (5/15/60)'; }, 1500);
    });
    console.log('[Backfill] Bound #backfillControlBtn');
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bindButton, {once:true});
  } else {
    bindButton();
  }
  window.backfillControl = { run: backfillAllWindows };
})();
</script>

<script>
(() => {
  'use strict';
  function initImportGuard() {
    const hasFileReader = typeof window.FileReader === 'function';
    const input = document.querySelector('#csvImportInput');
    if (!input) return;
    if (!hasFileReader) {
      console.warn('[Import] FileReader unavailable (Safari Lockdown). Disabling local import.');
      input.disabled = true;
      const note = document.createElement('div');
      note.textContent = 'Local file import disabled by Safari Lockdown.';
      note.style.fontSize = '12px';
      input.insertAdjacentElement('afterend', note);
    }
  }
  function ensureSummaryTables() {
    const targets = [
      { id:'summary5Table',  label:'Summary 5m'  },
      { id:'summary15Table', label:'Summary 15m' },
      { id:'summary60Table', label:'Summary 60m' }
    ];
    const host = document.querySelector('#summaryArea') || document.body;
    targets.forEach(t=>{
      if (document.getElementById(t.id)) return;
      const wrap = document.createElement('div');
      const h = document.createElement('h3'); h.textContent = t.label;
      const table = document.createElement('table'); table.id = t.id;
      const thead = document.createElement('thead');
      thead.innerHTML = '<tr><th>Time</th><th>Window</th><th>N</th><th>Means</th></tr>';
      const tbody = document.createElement('tbody');
      table.appendChild(thead); table.appendChild(tbody);
      wrap.appendChild(h); wrap.appendChild(table);
      host.appendChild(wrap);
    });
  }
  function rebindLegacyBackfillButtons() {
    if (!window.backfillControl?.run) return;
    ['#backfillBtn','#backfillBtnGlobal','#backfill','#backfillAllBtn'].forEach(sel=>{
      const el = document.querySelector(sel);
      if (!el) return;
      const fresh = el.cloneNode(true);
      el.replaceWith(fresh);
      fresh.addEventListener('click', () => window.backfillControl.run());
    });
    console.log('[Backfill] Legacy buttons rebound to universal runner.');
  }
  function boot() { initImportGuard(); ensureSummaryTables(); rebindLegacyBackfillButtons(); }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', boot, { once: true });
  } else { boot(); }
})();
</script>

<!-- === Metric Button Order Preferences (auto-injected, 2025/11/05 08:00:00 AEST) === -->
<style>
  #btnOrderGear{position:fixed; right:68px; bottom:18px; z-index:9999; width:42px; height:42px; border-radius:50%;
    border:1px solid rgba(0,0,0,0.2); background:#fff; cursor:pointer; box-shadow:0 2px 10px rgba(0,0,0,0.2);
    display:flex; align-items:center; justify-content:center; font-size:20px;}
  #btnOrderModal{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.45); z-index:10000;}
  #btnOrderCard{width:min(900px,92vw); max-height:86vh; overflow:auto; background:#fff; border-radius:10px; padding:16px 18px;
    box-shadow:0 10px 30px rgba(0,0,0,0.35); font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif;}
  #btnOrderCard h2{margin:0 0 10px 0;}
  .bo-row{display:grid; grid-template-columns: 160px 1fr; gap:10px; margin:8px 0; align-items:center;}
  .bo-controls{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;}
  .bo-controls button{padding:6px 10px; border-radius:6px; border:1px solid #ccc; background:#f7f7f7; cursor:pointer;}
  #bo-preview{border:1px solid #ddd; border-radius:8px; padding:8px; max-height:240px; overflow:auto; font-size:12px; background:#fafafa;}
  #bo-status{font-size:12px; opacity:0.75; margin-top:6px;}
  .bo-badge{display:inline-block; padding:3px 6px; border-radius:6px; background:#eee; margin:2px; border:1px solid #ddd;}
</style>
<div id="btnOrderModal" role="dialog" aria-modal="true" aria-labelledby="bo-title">
  <div id="btnOrderCard">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:8px;">
      <h2 id="bo-title">Metric Button Order</h2>
      <button id="bo-close" title="Close" style="border:1px solid #ccc; background:#fff; border-radius:6px; padding:6px 10px; cursor:pointer;">×</button>
    </div>
    <div class="bo-row">
      <label for="bo-metric">Metric</label>
      <select id="bo-metric"></select>
    </div>
    <div class="bo-row">
      <label for="bo-values">Values (comma‑separated)</label>
      <input id="bo-values" type="text" placeholder="e.g., 6,5.5,'',5,4.5,4,3.5,3,2.5,2,1.5,1,0.5,0" style="width:100%;"/>
    </div>
    <div class="bo-controls">
      <button id="bo-load-default">Load defaults</button>
      <button id="bo-reset-metric">Reset metric override</button>
      <button id="bo-save-apply" style="background:#007aff; color:#fff; border:none;">Save & Apply</button>
    </div>
    <div id="bo-preview"></div>
    <div id="bo-status"></div>
  </div>
</div>
<button id="btnOrderGear" title="Button Order">⚙︎</button>
<script>
(function(){
  // Parse helper: supports numbers and empty-string token '' for gaps
  function parseList(str){
    if (!str) return [];
    return str.split(/[,\\s]+/).filter(s=>s.length>0).map(tok=>{
      if (tok === "''" or tok == "“”" or tok == '""') return '';
      if (tok === "''" || tok === "“”" || tok === '""' || tok === '–' || tok === '—') return '';
      if (tok === "''" || tok === "''") return ''; // redundant safe-guards
      if (tok === "''") return '';
      if (tok === "''") return '';
      if (tok === "''") return '';
      // allow bare '' typed without quotes as two apostrophes
      if (tok == "''") return '';
      // allow plus/minus tokens like + or - to pass through as symbols
      if (tok === '+' || tok === '-') return tok;
      const n = Number(tok);
      return Number.isFinite(n) ? n : tok;
    });
  }
  function listToString(arr){
    return (Array.isArray(arr)?arr:[]).map(v => (v===''? "''" : String(v))).join(', ');
  }
  function getDefaultButtons(metric){
    try{
      if (typeof getMetricButtons === 'function'){
        // getMetricButtons already resolves localStorage; we want the PROJECT defaults:
        // try to read hard defaults if exposed; else fall back to CONFIG.*
        if (window.CONFIG && CONFIG.buttons && CONFIG.buttons.perMetricButtons && CONFIG.buttons.perMetricButtons[metric]){
          return CONFIG.buttons.perMetricButtons[metric].slice();
        }
      }
    }catch(e){}
    // r unified config
    try{
      if (window.CONFIG && Array.isArray(CONFIG.values) && CONFIG.values.length){
        return CONFIG.values.slice();
      }
    }catch(e){}
    // final fallback
    return [6,5,4,3,2,1,0];
  }
  function getCurrentButtons(metric){
    // Prefer runtime override in localStorage
    try{
      const data = JSON.parse(localStorage.getItem('metricButtonOrder')||'{}');
      if (data && Array.isArray(data[metric])) return data[metric].slice();
    }catch(e){}
    // Else project defaults
    return getDefaultButtons(metric);
  }
  function saveButtons(metric, arr){
    try{
      // If app exposes saveMetricButtons, use it so any in-app hooks fire
      if (typeof saveMetricButtons === 'function'){ saveMetricButtons(metric, arr); return; }
    }catch(e){}
    // else write to localStorage using same schema
    try{
      const data = (()=>{ try { return JSON.parse(localStorage.getItem('metricButtonOrder')||'{}'); } catch(e){ return {}; } })();
      data[metric] = Array.isArray(arr) ? arr.slice() : [];
      localStorage.setItem('metricButtonOrder', JSON.stringify(data));
    }catch(e){ console.warn(e); }
  }
  function resetMetric(metric){
    try{
      const data = (()=>{ try { return JSON.parse(localStorage.getItem('metricButtonOrder')||'{}'); } catch(e){ return {}; } })();
      delete data[metric];
      localStorage.setItem('metricButtonOrder', JSON.stringify(data));
    }catch(e){ console.warn(e); }
  }
  function rebuildGrids(){
    try{ if (typeof buildButtons === 'function') buildButtons(); }catch(e){}
    try{
      const rapid = document.getElementById('rapidScoresModal');
      if (rapid && typeof buildRapidScoresButtons === 'function') buildRapidScoresButtons();
    }catch(e){}
  }
  // UI wiring
  const gear = document.getElementById('btnOrderGear');
  const modal = document.getElementById('btnOrderModal');
  const closeBtn = document.getElementById('bo-close');
  const metricSel = document.getElementById('bo-metric');
  const valuesInp = document.getElementById('bo-values');
  const preview = document.getElementById('bo-preview');
  const status = document.getElementById('bo-status');
  const resetBtn = document.getElementById('bo-reset-metric');
  const loadBtn = document.getElementById('bo-load-default');
  const saveBtn = document.getElementById('bo-save-apply');

  function setStatus(msg){ try{ status.textContent = msg || ''; }catch(e){} }

  function refreshPreview(arr){
    preview.innerHTML = '';
    const list = Array.isArray(arr)?arr:[];
    const wrap = document.createElement('div');
    list.forEach(v=>{
      const span = document.createElement('span');
      span.className = 'bo-badge';
      span.textContent = (v===''? "''" : String(v));
      wrap.appendChild(span);
    });
    preview.appendChild(wrap);
  }

  function populateMetrics(){
    // Prefer app-defined metric list
    let list = [];
    try{ if (Array.isArray(window.metrics)) list = window.metrics.slice(); }catch(e){}
    if (!list.length){
      try{
        if (window.CONFIG){
          if (Array.isArray(CONFIG.core?.metrics)) list = CONFIG.core.metrics.slice();
          else if (Array.isArray(CONFIG.metrics)) list = CONFIG.metrics.slice();
        }
      }catch(e){}
    }
    if (!list.length) list = ['rush','mood','social','energy','focus','anxiety','impair'];
    metricSel.innerHTML = '';
    list.forEach(m=>{
      const opt = document.createElement('option');
      opt.value = m; opt.textContent = m.charAt(0).toUpperCase()+m.slice(1);
      metricSel.appendChild(opt);
    });
  }

  function loadMetric(m){
    const cur = getCurrentButtons(m);
    valuesInp.value = listToString(cur);
    refreshPreview(cur);
    setStatus('');
  }

  function open(){
    populateMetrics();
    const m = metricSel.value || metricSel.options[0]?.value || 'rush';
    loadMetric(m);
    modal.style.display = 'flex';
  }
  function close(){ modal.style.display = 'none'; }

  gear?.addEventListener('click', open);
  closeBtn?.addEventListener('click', close);
  modal?.addEventListener('click', (e)=>{ if (e.target === modal) close(); });
  metricSel?.addEventListener('change', ()=> loadMetric(metricSel.value));
  loadBtn?.addEventListener('click', ()=>{
    const m = metricSel.value;
    const def = getDefaultButtons(m);
    valuesInp.value = listToString(def);
    refreshPreview(def);
    setStatus('Loaded defaults for '+m);
  });
  resetBtn?.addEventListener('click', ()=>{
    const m = metricSel.value;
    resetMetric(m);
    const cur = getCurrentButtons(m);
    valuesInp.value = listToString(cur);
    refreshPreview(cur);
    setStatus('Reset override for '+m);
    rebuildGrids();
  });
  valuesInp?.addEventListener('input', ()=>{
    const arr = parseList(valuesInp.value);
    refreshPreview(arr);
  });
  saveBtn?.addEventListener('click', ()=>{
    const m = metricSel.value;
    const arr = parseList(valuesInp.value);
    saveButtons(m, arr);
    setStatus('Saved override for '+m);
    rebuildGrids();
  });
})();
</script>
